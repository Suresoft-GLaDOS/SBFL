        -:    0:Source:grammar.c
        -:    0:Graph:/home/workspace/libyara/grammar.gcno
        -:    0:Data:/home/workspace/libyara/grammar.gcda
        -:    0:Runs:7
        -:    0:Programs:7
        -:    1:/* A Bison parser, made by GNU Bison 3.0.4.  */
        -:    2:
        -:    3:/* Bison implementation for Yacc-like parsers in C
        -:    4:
        -:    5:   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
        -:    6:
        -:    7:   This program is free software: you can redistribute it and/or modify
        -:    8:   it under the terms of the GNU General Public License as published by
        -:    9:   the Free Software Foundation, either version 3 of the License, or
        -:   10:   (at your option) any later version.
        -:   11:
        -:   12:   This program is distributed in the hope that it will be useful,
        -:   13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   15:   GNU General Public License for more details.
        -:   16:
        -:   17:   You should have received a copy of the GNU General Public License
        -:   18:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   19:
        -:   20:/* As a special exception, you may create a larger work that contains
        -:   21:   part or all of the Bison parser skeleton and distribute that work
        -:   22:   under terms of your choice, so long as that work isn't itself a
        -:   23:   parser generator using the skeleton or a modified version thereof
        -:   24:   as a parser skeleton.  Alternatively, if you modify or redistribute
        -:   25:   the parser skeleton itself, you may (at your option) remove this
        -:   26:   special exception, which will cause the skeleton and the resulting
        -:   27:   Bison output files to be licensed under the GNU General Public
        -:   28:   License without this special exception.
        -:   29:
        -:   30:   This special exception was added by the Free Software Foundation in
        -:   31:   version 2.2 of Bison.  */
        -:   32:
        -:   33:/* C LALR(1) parser skeleton written by Richard Stallman, by
        -:   34:   simplifying the original so-called "semantic" parser.  */
        -:   35:
        -:   36:/* All symbols defined below should begin with yy or YY, to avoid
        -:   37:   infringing on user name space.  This should be done even for local
        -:   38:   variables, as they might otherwise be expanded by user macros.
        -:   39:   There are some unavoidable exceptions within include files to
        -:   40:   define necessary library symbols; they are noted "INFRINGES ON
        -:   41:   USER NAME SPACE" below.  */
        -:   42:
        -:   43:/* Identify Bison output.  */
        -:   44:#define YYBISON 1
        -:   45:
        -:   46:/* Bison version.  */
        -:   47:#define YYBISON_VERSION "3.0.4"
        -:   48:
        -:   49:/* Skeleton name.  */
        -:   50:#define YYSKELETON_NAME "yacc.c"
        -:   51:
        -:   52:/* Pure parsers.  */
        -:   53:#define YYPURE 1
        -:   54:
        -:   55:/* Push parsers.  */
        -:   56:#define YYPUSH 0
        -:   57:
        -:   58:/* Pull parsers.  */
        -:   59:#define YYPULL 1
        -:   60:
        -:   61:
        -:   62:/* Substitute the variable and function names.  */
        -:   63:#define yyparse         yara_yyparse
        -:   64:#define yylex           yara_yylex
        -:   65:#define yyerror         yara_yyerror
        -:   66:#define yydebug         yara_yydebug
        -:   67:#define yynerrs         yara_yynerrs
        -:   68:
        -:   69:
        -:   70:/* Copy the first part of user declarations.  */
        -:   71:#line 30 "grammar.y" /* yacc.c:339  */
        -:   72:
        -:   73:
        -:   74:
        -:   75:#include <assert.h>
        -:   76:#include <stdio.h>
        -:   77:#include <string.h>
        -:   78:#include <limits.h>
        -:   79:#include <stdlib.h>
        -:   80:#include <stddef.h>
        -:   81:
        -:   82:#include <yara/integers.h>
        -:   83:#include <yara/utils.h>
        -:   84:#include <yara/strutils.h>
        -:   85:#include <yara/compiler.h>
        -:   86:#include <yara/object.h>
        -:   87:#include <yara/sizedstr.h>
        -:   88:#include <yara/exec.h>
        -:   89:#include <yara/error.h>
        -:   90:#include <yara/mem.h>
        -:   91:#include <yara/lexer.h>
        -:   92:#include <yara/parser.h>
        -:   93:
        -:   94:#if defined(_MSC_VER)
        -:   95:#define llabs _abs64
        -:   96:#endif
        -:   97:
        -:   98:#define YYERROR_VERBOSE
        -:   99:
        -:  100:#define YYMALLOC yr_malloc
        -:  101:#define YYFREE yr_free
        -:  102:
        -:  103:#define INTEGER_SET_ENUMERATION   1
        -:  104:#define INTEGER_SET_RANGE         2
        -:  105:
        -:  106:#define FOR_EXPRESSION_ALL 1
        -:  107:#define FOR_EXPRESSION_ANY 2
        -:  108:
        -:  109:#define fail_if_error(e) \
        -:  110:    if (e != ERROR_SUCCESS) \
        -:  111:    { \
        -:  112:      compiler->last_error = e; \
        -:  113:      yyerror(yyscanner, compiler, NULL); \
        -:  114:      YYERROR; \
        -:  115:    } \
        -:  116:
        -:  117:
        -:  118:#define check_type_with_cleanup(expression, expected_type, op, cleanup) \
        -:  119:    if (((expression.type) & (expected_type)) == 0) \
        -:  120:    { \
        -:  121:      switch(expression.type) \
        -:  122:      { \
        -:  123:        case EXPRESSION_TYPE_INTEGER: \
        -:  124:          yr_compiler_set_error_extra_info( \
        -:  125:              compiler, "wrong type \"integer\" for " op " operator"); \
        -:  126:          break; \
        -:  127:        case EXPRESSION_TYPE_FLOAT: \
        -:  128:          yr_compiler_set_error_extra_info( \
        -:  129:              compiler, "wrong type \"float\" for " op " operator"); \
        -:  130:          break; \
        -:  131:        case EXPRESSION_TYPE_STRING: \
        -:  132:          yr_compiler_set_error_extra_info( \
        -:  133:              compiler, "wrong type \"string\" for " op " operator"); \
        -:  134:          break; \
        -:  135:        case EXPRESSION_TYPE_BOOLEAN: \
        -:  136:          yr_compiler_set_error_extra_info( \
        -:  137:              compiler, "wrong type \"boolean\" for " op " operator"); \
        -:  138:          break; \
        -:  139:      } \
        -:  140:      cleanup; \
        -:  141:      compiler->last_error = ERROR_WRONG_TYPE; \
        -:  142:      yyerror(yyscanner, compiler, NULL); \
        -:  143:      YYERROR; \
        -:  144:    }
        -:  145:
        -:  146:
        -:  147:#define check_type(expression, expected_type, op) \
        -:  148:    check_type_with_cleanup(expression, expected_type, op, )
        -:  149:
        -:  150:
        -:  151:#line 152 "grammar.c" /* yacc.c:339  */
        -:  152:
        -:  153:# ifndef YY_NULLPTR
        -:  154:#  if defined __cplusplus && 201103L <= __cplusplus
        -:  155:#   define YY_NULLPTR nullptr
        -:  156:#  else
        -:  157:#   define YY_NULLPTR 0
        -:  158:#  endif
        -:  159:# endif
        -:  160:
        -:  161:/* Enabling verbose error messages.  */
        -:  162:#ifdef YYERROR_VERBOSE
        -:  163:# undef YYERROR_VERBOSE
        -:  164:# define YYERROR_VERBOSE 1
        -:  165:#else
        -:  166:# define YYERROR_VERBOSE 0
        -:  167:#endif
        -:  168:
        -:  169:/* In a future release of Bison, this section will be replaced
        -:  170:   by #include "y.tab.h".  */
        -:  171:#ifndef YY_YARA_YY_GRAMMAR_H_INCLUDED
        -:  172:# define YY_YARA_YY_GRAMMAR_H_INCLUDED
        -:  173:/* Debug traces.  */
        -:  174:#ifndef YYDEBUG
        -:  175:# define YYDEBUG 0
        -:  176:#endif
        -:  177:#if YYDEBUG
        -:  178:extern int yara_yydebug;
        -:  179:#endif
        -:  180:
        -:  181:/* Token type.  */
        -:  182:#ifndef YYTOKENTYPE
        -:  183:# define YYTOKENTYPE
        -:  184:  enum yytokentype
        -:  185:  {
        -:  186:    _END_OF_FILE_ = 0,
        -:  187:    _END_OF_INCLUDED_FILE_ = 258,
        -:  188:    _DOT_DOT_ = 259,
        -:  189:    _RULE_ = 260,
        -:  190:    _PRIVATE_ = 261,
        -:  191:    _GLOBAL_ = 262,
        -:  192:    _META_ = 263,
        -:  193:    _STRINGS_ = 264,
        -:  194:    _CONDITION_ = 265,
        -:  195:    _IDENTIFIER_ = 266,
        -:  196:    _STRING_IDENTIFIER_ = 267,
        -:  197:    _STRING_COUNT_ = 268,
        -:  198:    _STRING_OFFSET_ = 269,
        -:  199:    _STRING_LENGTH_ = 270,
        -:  200:    _STRING_IDENTIFIER_WITH_WILDCARD_ = 271,
        -:  201:    _NUMBER_ = 272,
        -:  202:    _DOUBLE_ = 273,
        -:  203:    _INTEGER_FUNCTION_ = 274,
        -:  204:    _TEXT_STRING_ = 275,
        -:  205:    _HEX_STRING_ = 276,
        -:  206:    _REGEXP_ = 277,
        -:  207:    _ASCII_ = 278,
        -:  208:    _WIDE_ = 279,
        -:  209:    _XOR_ = 280,
        -:  210:    _NOCASE_ = 281,
        -:  211:    _FULLWORD_ = 282,
        -:  212:    _AT_ = 283,
        -:  213:    _FILESIZE_ = 284,
        -:  214:    _ENTRYPOINT_ = 285,
        -:  215:    _ALL_ = 286,
        -:  216:    _ANY_ = 287,
        -:  217:    _IN_ = 288,
        -:  218:    _OF_ = 289,
        -:  219:    _FOR_ = 290,
        -:  220:    _THEM_ = 291,
        -:  221:    _MATCHES_ = 292,
        -:  222:    _CONTAINS_ = 293,
        -:  223:    _IMPORT_ = 294,
        -:  224:    _TRUE_ = 295,
        -:  225:    _FALSE_ = 296,
        -:  226:    _OR_ = 297,
        -:  227:    _AND_ = 298,
        -:  228:    _NOT_ = 299,
        -:  229:    _EQ_ = 300,
        -:  230:    _NEQ_ = 301,
        -:  231:    _LT_ = 302,
        -:  232:    _LE_ = 303,
        -:  233:    _GT_ = 304,
        -:  234:    _GE_ = 305,
        -:  235:    _SHIFT_LEFT_ = 306,
        -:  236:    _SHIFT_RIGHT_ = 307,
        -:  237:    UNARY_MINUS = 308
        -:  238:  };
        -:  239:#endif
        -:  240:/* Tokens.  */
        -:  241:#define _END_OF_FILE_ 0
        -:  242:#define _END_OF_INCLUDED_FILE_ 258
        -:  243:#define _DOT_DOT_ 259
        -:  244:#define _RULE_ 260
        -:  245:#define _PRIVATE_ 261
        -:  246:#define _GLOBAL_ 262
        -:  247:#define _META_ 263
        -:  248:#define _STRINGS_ 264
        -:  249:#define _CONDITION_ 265
        -:  250:#define _IDENTIFIER_ 266
        -:  251:#define _STRING_IDENTIFIER_ 267
        -:  252:#define _STRING_COUNT_ 268
        -:  253:#define _STRING_OFFSET_ 269
        -:  254:#define _STRING_LENGTH_ 270
        -:  255:#define _STRING_IDENTIFIER_WITH_WILDCARD_ 271
        -:  256:#define _NUMBER_ 272
        -:  257:#define _DOUBLE_ 273
        -:  258:#define _INTEGER_FUNCTION_ 274
        -:  259:#define _TEXT_STRING_ 275
        -:  260:#define _HEX_STRING_ 276
        -:  261:#define _REGEXP_ 277
        -:  262:#define _ASCII_ 278
        -:  263:#define _WIDE_ 279
        -:  264:#define _XOR_ 280
        -:  265:#define _NOCASE_ 281
        -:  266:#define _FULLWORD_ 282
        -:  267:#define _AT_ 283
        -:  268:#define _FILESIZE_ 284
        -:  269:#define _ENTRYPOINT_ 285
        -:  270:#define _ALL_ 286
        -:  271:#define _ANY_ 287
        -:  272:#define _IN_ 288
        -:  273:#define _OF_ 289
        -:  274:#define _FOR_ 290
        -:  275:#define _THEM_ 291
        -:  276:#define _MATCHES_ 292
        -:  277:#define _CONTAINS_ 293
        -:  278:#define _IMPORT_ 294
        -:  279:#define _TRUE_ 295
        -:  280:#define _FALSE_ 296
        -:  281:#define _OR_ 297
        -:  282:#define _AND_ 298
        -:  283:#define _NOT_ 299
        -:  284:#define _EQ_ 300
        -:  285:#define _NEQ_ 301
        -:  286:#define _LT_ 302
        -:  287:#define _LE_ 303
        -:  288:#define _GT_ 304
        -:  289:#define _GE_ 305
        -:  290:#define _SHIFT_LEFT_ 306
        -:  291:#define _SHIFT_RIGHT_ 307
        -:  292:#define UNARY_MINUS 308
        -:  293:
        -:  294:/* Value type.  */
        -:  295:#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
        -:  296:
        -:  297:union YYSTYPE
        -:  298:{
        -:  299:#line 242 "grammar.y" /* yacc.c:355  */
        -:  300:
        -:  301:  EXPRESSION      expression;
        -:  302:  SIZED_STRING*   sized_string;
        -:  303:  char*           c_string;
        -:  304:  int64_t         integer;
        -:  305:  double          double_;
        -:  306:  YR_STRING*      string;
        -:  307:  YR_META*        meta;
        -:  308:  YR_RULE*        rule;
        -:  309:
        -:  310:#line 311 "grammar.c" /* yacc.c:355  */
        -:  311:};
        -:  312:
        -:  313:typedef union YYSTYPE YYSTYPE;
        -:  314:# define YYSTYPE_IS_TRIVIAL 1
        -:  315:# define YYSTYPE_IS_DECLARED 1
        -:  316:#endif
        -:  317:
        -:  318:
        -:  319:
        -:  320:int yara_yyparse (void *yyscanner, YR_COMPILER* compiler);
        -:  321:
        -:  322:#endif /* !YY_YARA_YY_GRAMMAR_H_INCLUDED  */
        -:  323:
        -:  324:/* Copy the second part of user declarations.  */
        -:  325:
        -:  326:#line 327 "grammar.c" /* yacc.c:358  */
        -:  327:
        -:  328:#ifdef short
        -:  329:# undef short
        -:  330:#endif
        -:  331:
        -:  332:#ifdef YYTYPE_UINT8
        -:  333:typedef YYTYPE_UINT8 yytype_uint8;
        -:  334:#else
        -:  335:typedef unsigned char yytype_uint8;
        -:  336:#endif
        -:  337:
        -:  338:#ifdef YYTYPE_INT8
        -:  339:typedef YYTYPE_INT8 yytype_int8;
        -:  340:#else
        -:  341:typedef signed char yytype_int8;
        -:  342:#endif
        -:  343:
        -:  344:#ifdef YYTYPE_UINT16
        -:  345:typedef YYTYPE_UINT16 yytype_uint16;
        -:  346:#else
        -:  347:typedef unsigned short int yytype_uint16;
        -:  348:#endif
        -:  349:
        -:  350:#ifdef YYTYPE_INT16
        -:  351:typedef YYTYPE_INT16 yytype_int16;
        -:  352:#else
        -:  353:typedef short int yytype_int16;
        -:  354:#endif
        -:  355:
        -:  356:#ifndef YYSIZE_T
        -:  357:# ifdef __SIZE_TYPE__
        -:  358:#  define YYSIZE_T __SIZE_TYPE__
        -:  359:# elif defined size_t
        -:  360:#  define YYSIZE_T size_t
        -:  361:# elif ! defined YYSIZE_T
        -:  362:#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  363:#  define YYSIZE_T size_t
        -:  364:# else
        -:  365:#  define YYSIZE_T unsigned int
        -:  366:# endif
        -:  367:#endif
        -:  368:
        -:  369:#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
        -:  370:
        -:  371:#ifndef YY_
        -:  372:# if defined YYENABLE_NLS && YYENABLE_NLS
        -:  373:#  if ENABLE_NLS
        -:  374:#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
        -:  375:#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
        -:  376:#  endif
        -:  377:# endif
        -:  378:# ifndef YY_
        -:  379:#  define YY_(Msgid) Msgid
        -:  380:# endif
        -:  381:#endif
        -:  382:
        -:  383:#ifndef YY_ATTRIBUTE
        -:  384:# if (defined __GNUC__                                               \
        -:  385:      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
        -:  386:     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
        -:  387:#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
        -:  388:# else
        -:  389:#  define YY_ATTRIBUTE(Spec) /* empty */
        -:  390:# endif
        -:  391:#endif
        -:  392:
        -:  393:#ifndef YY_ATTRIBUTE_PURE
        -:  394:# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
        -:  395:#endif
        -:  396:
        -:  397:#ifndef YY_ATTRIBUTE_UNUSED
        -:  398:# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
        -:  399:#endif
        -:  400:
        -:  401:#if !defined _Noreturn \
        -:  402:     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
        -:  403:# if defined _MSC_VER && 1200 <= _MSC_VER
        -:  404:#  define _Noreturn __declspec (noreturn)
        -:  405:# else
        -:  406:#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
        -:  407:# endif
        -:  408:#endif
        -:  409:
        -:  410:/* Suppress unused-variable warnings by "using" E.  */
        -:  411:#if ! defined lint || defined __GNUC__
        -:  412:# define YYUSE(E) ((void) (E))
        -:  413:#else
        -:  414:# define YYUSE(E) /* empty */
        -:  415:#endif
        -:  416:
        -:  417:#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
        -:  418:/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
        -:  419:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
        -:  420:    _Pragma ("GCC diagnostic push") \
        -:  421:    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
        -:  422:    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
        -:  423:# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
        -:  424:    _Pragma ("GCC diagnostic pop")
        -:  425:#else
        -:  426:# define YY_INITIAL_VALUE(Value) Value
        -:  427:#endif
        -:  428:#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  429:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  430:# define YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  431:#endif
        -:  432:#ifndef YY_INITIAL_VALUE
        -:  433:# define YY_INITIAL_VALUE(Value) /* Nothing. */
        -:  434:#endif
        -:  435:
        -:  436:
        -:  437:#if ! defined yyoverflow || YYERROR_VERBOSE
        -:  438:
        -:  439:/* The parser invokes alloca or malloc; define the necessary symbols.  */
        -:  440:
        -:  441:# ifdef YYSTACK_USE_ALLOCA
        -:  442:#  if YYSTACK_USE_ALLOCA
        -:  443:#   ifdef __GNUC__
        -:  444:#    define YYSTACK_ALLOC __builtin_alloca
        -:  445:#   elif defined __BUILTIN_VA_ARG_INCR
        -:  446:#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
        -:  447:#   elif defined _AIX
        -:  448:#    define YYSTACK_ALLOC __alloca
        -:  449:#   elif defined _MSC_VER
        -:  450:#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
        -:  451:#    define alloca _alloca
        -:  452:#   else
        -:  453:#    define YYSTACK_ALLOC alloca
        -:  454:#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
        -:  455:#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  456:      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
        -:  457:#     ifndef EXIT_SUCCESS
        -:  458:#      define EXIT_SUCCESS 0
        -:  459:#     endif
        -:  460:#    endif
        -:  461:#   endif
        -:  462:#  endif
        -:  463:# endif
        -:  464:
        -:  465:# ifdef YYSTACK_ALLOC
        -:  466:   /* Pacify GCC's 'empty if-body' warning.  */
        -:  467:#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
        -:  468:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  469:    /* The OS might guarantee only one guard page at the bottom of the stack,
        -:  470:       and a page size can be as small as 4096 bytes.  So we cannot safely
        -:  471:       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
        -:  472:       to allow for a few compiler-allocated temporary stack slots.  */
        -:  473:#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
        -:  474:#  endif
        -:  475:# else
        -:  476:#  define YYSTACK_ALLOC YYMALLOC
        -:  477:#  define YYSTACK_FREE YYFREE
        -:  478:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  479:#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
        -:  480:#  endif
        -:  481:#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        -:  482:       && ! ((defined YYMALLOC || defined malloc) \
        -:  483:             && (defined YYFREE || defined free)))
        -:  484:#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  485:#   ifndef EXIT_SUCCESS
        -:  486:#    define EXIT_SUCCESS 0
        -:  487:#   endif
        -:  488:#  endif
        -:  489:#  ifndef YYMALLOC
        -:  490:#   define YYMALLOC malloc
        -:  491:#   if ! defined malloc && ! defined EXIT_SUCCESS
        -:  492:void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
        -:  493:#   endif
        -:  494:#  endif
        -:  495:#  ifndef YYFREE
        -:  496:#   define YYFREE free
        -:  497:#   if ! defined free && ! defined EXIT_SUCCESS
        -:  498:void free (void *); /* INFRINGES ON USER NAME SPACE */
        -:  499:#   endif
        -:  500:#  endif
        -:  501:# endif
        -:  502:#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
        -:  503:
        -:  504:
        -:  505:#if (! defined yyoverflow \
        -:  506:     && (! defined __cplusplus \
        -:  507:         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
        -:  508:
        -:  509:/* A type that is properly aligned for any stack member.  */
        -:  510:union yyalloc
        -:  511:{
        -:  512:  yytype_int16 yyss_alloc;
        -:  513:  YYSTYPE yyvs_alloc;
        -:  514:};
        -:  515:
        -:  516:/* The size of the maximum gap between one aligned stack and the next.  */
        -:  517:# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
        -:  518:
        -:  519:/* The size of an array large to enough to hold all stacks, each with
        -:  520:   N elements.  */
        -:  521:# define YYSTACK_BYTES(N) \
        -:  522:     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
        -:  523:      + YYSTACK_GAP_MAXIMUM)
        -:  524:
        -:  525:# define YYCOPY_NEEDED 1
        -:  526:
        -:  527:/* Relocate STACK from its old location to the new one.  The
        -:  528:   local variables YYSIZE and YYSTACKSIZE give the old and new number of
        -:  529:   elements in the stack, and YYPTR gives the new location of the
        -:  530:   stack.  Advance YYPTR to a properly aligned location for the next
        -:  531:   stack.  */
        -:  532:# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
        -:  533:    do                                                                  \
        -:  534:      {                                                                 \
        -:  535:        YYSIZE_T yynewbytes;                                            \
        -:  536:        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        -:  537:        Stack = &yyptr->Stack_alloc;                                    \
        -:  538:        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
        -:  539:        yyptr += yynewbytes / sizeof (*yyptr);                          \
        -:  540:      }                                                                 \
        -:  541:    while (0)
        -:  542:
        -:  543:#endif
        -:  544:
        -:  545:#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
        -:  546:/* Copy COUNT objects from SRC to DST.  The source and destination do
        -:  547:   not overlap.  */
        -:  548:# ifndef YYCOPY
        -:  549:#  if defined __GNUC__ && 1 < __GNUC__
        -:  550:#   define YYCOPY(Dst, Src, Count) \
        -:  551:      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
        -:  552:#  else
        -:  553:#   define YYCOPY(Dst, Src, Count)              \
        -:  554:      do                                        \
        -:  555:        {                                       \
        -:  556:          YYSIZE_T yyi;                         \
        -:  557:          for (yyi = 0; yyi < (Count); yyi++)   \
        -:  558:            (Dst)[yyi] = (Src)[yyi];            \
        -:  559:        }                                       \
        -:  560:      while (0)
        -:  561:#  endif
        -:  562:# endif
        -:  563:#endif /* !YYCOPY_NEEDED */
        -:  564:
        -:  565:/* YYFINAL -- State number of the termination state.  */
        -:  566:#define YYFINAL  2
        -:  567:/* YYLAST -- Last index in YYTABLE.  */
        -:  568:#define YYLAST   374
        -:  569:
        -:  570:/* YYNTOKENS -- Number of terminals.  */
        -:  571:#define YYNTOKENS  74
        -:  572:/* YYNNTS -- Number of nonterminals.  */
        -:  573:#define YYNNTS  41
        -:  574:/* YYNRULES -- Number of rules.  */
        -:  575:#define YYNRULES  124
        -:  576:/* YYNSTATES -- Number of states.  */
        -:  577:#define YYNSTATES  212
        -:  578:
        -:  579:/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
        -:  580:   by yylex, with out-of-bounds checking.  */
        -:  581:#define YYUNDEFTOK  2
        -:  582:#define YYMAXUTOK   309
        -:  583:
        -:  584:#define YYTRANSLATE(YYX)                                                \
        -:  585:  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
        -:  586:
        -:  587:/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
        -:  588:   as returned by yylex, without out-of-bounds checking.  */
        -:  589:static const yytype_uint8 yytranslate[] =
        -:  590:{
        -:  591:       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  592:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  593:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  594:       2,     2,     2,     2,     2,     2,     2,    60,    55,     2,
        -:  595:      71,    72,    58,    56,    73,    57,    68,     2,     2,     2,
        -:  596:       2,     2,     2,     2,     2,     2,     2,     2,    66,     2,
        -:  597:       2,    67,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  598:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  599:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  600:       2,    69,    59,    70,    54,     2,     2,     2,     2,     2,
        -:  601:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  602:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  603:       2,     2,     2,    64,    53,    65,    61,     2,     2,     2,
        -:  604:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  605:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  606:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  607:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  608:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  609:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  610:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  611:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  612:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  613:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  614:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  615:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  616:       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
        -:  617:       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
        -:  618:      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
        -:  619:      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
        -:  620:      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
        -:  621:      45,    46,    47,    48,    49,    50,    51,    52,    62,    63
        -:  622:};
        -:  623:
        -:  624:#if YYDEBUG
        -:  625:  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
        -:  626:static const yytype_uint16 yyrline[] =
        -:  627:{
        -:  628:       0,   256,   256,   258,   259,   260,   261,   262,   263,   271,
        -:  629:     284,   289,   283,   310,   313,   343,   346,   371,   376,   377,
        -:  630:     382,   383,   389,   392,   410,   419,   458,   459,   464,   481,
        -:  631:     495,   509,   523,   541,   542,   548,   547,   563,   562,   578,
        -:  632:     592,   593,   598,   599,   600,   601,   602,   607,   693,   740,
        -:  633:     799,   845,   846,   850,   878,   918,   961,   981,   988,   995,
        -:  634:    1007,  1017,  1031,  1046,  1057,  1068,  1185,  1067,  1367,  1366,
        -:  635:    1444,  1450,  1457,  1456,  1502,  1501,  1545,  1552,  1559,  1566,
        -:  636:    1573,  1580,  1587,  1591,  1599,  1600,  1605,  1629,  1642,  1660,
        -:  637:    1659,  1665,  1677,  1678,  1683,  1690,  1701,  1705,  1710,  1719,
        -:  638:    1723,  1731,  1743,  1757,  1765,  1772,  1797,  1809,  1821,  1837,
        -:  639:    1849,  1865,  1912,  1933,  1968,  2003,  2037,  2062,  2079,  2089,
        -:  640:    2099,  2109,  2119,  2139,  2159
        -:  641:};
        -:  642:#endif
        -:  643:
        -:  644:#if YYDEBUG || YYERROR_VERBOSE || 0
        -:  645:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
        -:  646:   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
        -:  647:static const char *const yytname[] =
        -:  648:{
        -:  649:  "\"end of file\"", "error", "$undefined", "\"end of included file\"",
        -:  650:  "\"..\"", "\"<rule>\"", "\"<private>\"", "\"<global>\"", "\"<meta>\"",
        -:  651:  "\"<strings>\"", "\"<condition>\"", "\"identifier\"",
        -:  652:  "\"string identifier\"", "\"string count\"", "\"string offset\"",
        -:  653:  "\"string length\"", "\"string identifier with wildcard\"",
        -:  654:  "\"integer number\"", "\"floating point number\"",
        -:  655:  "\"integer function\"", "\"text string\"", "\"hex string\"",
        -:  656:  "\"regular expression\"", "\"<ascii>\"", "\"<wide>\"", "\"<xor>\"",
        -:  657:  "\"<nocase>\"", "\"<fullword>\"", "\"<at>\"", "\"<filesize>\"",
        -:  658:  "\"<entrypoint>\"", "\"<all>\"", "\"<any>\"", "\"<in>\"", "\"<of>\"",
        -:  659:  "\"<for>\"", "\"<them>\"", "\"<matches>\"", "\"<contains>\"",
        -:  660:  "\"<import>\"", "\"<true>\"", "\"<false\"", "\"<or>\"", "\"<and>\"",
        -:  661:  "\"<not>\"", "\"==\"", "\"!=\"", "\"<\"", "\"<=\"", "\">\"", "\">=\"",
        -:  662:  "\"<<\"", "\">>\"", "'|'", "'^'", "'&'", "'+'", "'-'", "'*'", "'\\\\'",
        -:  663:  "'%'", "'~'", "UNARY_MINUS", "\"include\"", "'{'", "'}'", "':'", "'='",
        -:  664:  "'.'", "'['", "']'", "'('", "')'", "','", "$accept", "rules", "import",
        -:  665:  "rule", "@1", "$@2", "meta", "strings", "condition", "rule_modifiers",
        -:  666:  "rule_modifier", "tags", "tag_list", "meta_declarations",
        -:  667:  "meta_declaration", "string_declarations", "string_declaration", "$@3",
        -:  668:  "$@4", "string_modifiers", "string_modifier", "identifier", "arguments",
        -:  669:  "arguments_list", "regexp", "boolean_expression", "expression", "$@5",
        -:  670:  "$@6", "$@7", "$@8", "$@9", "integer_set", "range",
        -:  671:  "integer_enumeration", "string_set", "$@10", "string_enumeration",
        -:  672:  "string_enumeration_item", "for_expression", "primary_expression", YY_NULLPTR
        -:  673:};
        -:  674:#endif
        -:  675:
        -:  676:# ifdef YYPRINT
        -:  677:/* YYTOKNUM[NUM] -- (External) token number corresponding to the
        -:  678:   (internal) symbol number NUM (which must be that of a token).  */
        -:  679:static const yytype_uint16 yytoknum[] =
        -:  680:{
        -:  681:       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
        -:  682:     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
        -:  683:     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
        -:  684:     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
        -:  685:     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
        -:  686:     305,   306,   307,   124,    94,    38,    43,    45,    42,    92,
        -:  687:      37,   126,   308,   309,   123,   125,    58,    61,    46,    91,
        -:  688:      93,    40,    41,    44
        -:  689:};
        -:  690:# endif
        -:  691:
        -:  692:#define YYPACT_NINF -74
        -:  693:
        -:  694:#define yypact_value_is_default(Yystate) \
        -:  695:  (!!((Yystate) == (-74)))
        -:  696:
        -:  697:#define YYTABLE_NINF -97
        -:  698:
        -:  699:#define yytable_value_is_error(Yytable_value) \
        -:  700:  0
        -:  701:
        -:  702:  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
        -:  703:     STATE-NUM.  */
        -:  704:static const yytype_int16 yypact[] =
        -:  705:{
        -:  706:     -74,    95,   -74,   -30,   -74,   -12,   -74,   -74,    79,   -74,
        -:  707:     -74,   -74,   -74,    -7,   -74,   -74,   -74,   -74,   -55,     4,
        -:  708:     -42,   -74,    23,    18,   -74,     9,    59,    83,    33,   -74,
        -:  709:      30,    83,   -74,   107,   117,    15,   -74,    65,   107,   -74,
        -:  710:      69,    72,   -74,   -74,   -74,   -74,   121,     8,   -74,    47,
        -:  711:     -74,   -74,   -74,   124,   123,   -74,   -16,   -74,    70,    77,
        -:  712:     -74,   -74,    89,   -74,   -74,   -74,   -74,   -74,   -74,   111,
        -:  713:     -74,   -74,    47,   136,   136,    47,    12,   -74,    28,   -74,
        -:  714:     114,   212,   -74,   -74,   136,    91,   136,   136,   136,   136,
        -:  715:       2,   314,   -74,   -74,   -74,    28,    85,   184,   152,   136,
        -:  716:      47,   -74,   -74,    -8,   142,   136,   136,   136,   136,   136,
        -:  717:     136,   136,   136,   136,   136,   136,   136,   136,   136,   136,
        -:  718:     136,   136,    86,    86,   314,   136,   -74,   254,   274,   132,
        -:  719:     222,   -74,   134,    -8,   -74,   -74,   -74,   294,    97,   108,
        -:  720:      64,    47,    47,   -74,   -74,   -74,   -74,   314,   314,   314,
        -:  721:     314,   314,   314,   314,   195,   195,   119,   143,   168,    57,
        -:  722:      57,   -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,
        -:  723:     157,   -74,   -74,   -74,   -74,   130,   -74,   -74,    47,   137,
        -:  724:     -74,    -2,   136,   135,   -74,    64,   -74,   -74,    17,   -74,
        -:  725:     232,   136,   139,   -74,   174,   -74,    -2,   -74,    48,   157,
        -:  726:     -74,    47,   -74,   -74,   136,   176,   -18,   314,    47,   -74,
        -:  727:      31,   -74
        -:  728:};
        -:  729:
        -:  730:  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
        -:  731:     Performed when YYTABLE does not specify something else to do.  Zero
        -:  732:     means the default is an error.  */
        -:  733:static const yytype_uint8 yydefact[] =
        -:  734:{
        -:  735:       2,     0,     1,    18,     8,     0,     4,     3,     0,     7,
        -:  736:       6,     5,     9,     0,    20,    21,    19,    10,    22,     0,
        -:  737:       0,    24,    23,    13,    25,     0,    15,     0,     0,    11,
        -:  738:       0,    14,    26,     0,     0,     0,    27,     0,    16,    33,
        -:  739:       0,     0,    29,    28,    31,    32,     0,    35,    34,     0,
        -:  740:      12,    30,    39,     0,     0,    47,    61,   106,   108,   110,
        -:  741:     103,   104,     0,   105,    55,   100,   101,    97,    98,     0,
        -:  742:      57,    58,     0,     0,     0,     0,   111,   124,    17,    56,
        -:  743:       0,    82,    40,    40,     0,     0,     0,     0,     0,     0,
        -:  744:       0,    96,    71,   112,   121,     0,    56,    82,     0,     0,
        -:  745:      51,    74,    72,     0,     0,     0,     0,     0,     0,     0,
        -:  746:       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        -:  747:       0,     0,    36,    38,    62,     0,    63,     0,     0,     0,
        -:  748:       0,    64,     0,     0,    83,    99,    48,     0,     0,    52,
        -:  749:      53,     0,     0,    91,    89,    70,    59,    60,    80,    81,
        -:  750:      76,    78,    77,    79,   122,   123,   120,   118,   119,   113,
        -:  751:     114,   115,   116,   117,    43,    42,    46,    44,    45,    41,
        -:  752:       0,   107,   109,   102,    65,     0,    49,    50,     0,    75,
        -:  753:      73,     0,     0,     0,    68,    54,    94,    95,     0,    92,
        -:  754:       0,     0,     0,    85,     0,    90,     0,    86,     0,    87,
        -:  755:      66,     0,    93,    84,     0,     0,     0,    88,     0,    69,
        -:  756:       0,    67
        -:  757:};
        -:  758:
        -:  759:  /* YYPGOTO[NTERM-NUM].  */
        -:  760:static const yytype_int16 yypgoto[] =
        -:  761:{
        -:  762:     -74,   -74,   220,   245,   -74,   -74,   -74,   -74,   -74,   -74,
        -:  763:     -74,   -74,   -74,   -74,   262,   -74,   257,   -74,   -74,   213,
        -:  764:     -74,   -74,   -74,   -74,   193,   -49,   -73,   -74,   -74,   -74,
        -:  765:     -74,   -74,   -74,   115,   -74,   166,   -74,   -74,   104,   233,
        -:  766:     -68
        -:  767:};
        -:  768:
        -:  769:  /* YYDEFGOTO[NTERM-NUM].  */
        -:  770:static const yytype_int16 yydefgoto[] =
        -:  771:{
        -:  772:      -1,     1,     6,     7,    18,    34,    26,    29,    41,     8,
        -:  773:      16,    20,    22,    31,    32,    38,    39,    53,    54,   122,
        -:  774:     169,    76,   138,   139,    77,    95,    79,   183,   205,   194,
        -:  775:     142,   141,   192,   126,   198,   145,   181,   188,   189,    80,
        -:  776:      81
        -:  777:};
        -:  778:
        -:  779:  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
        -:  780:     positive, shift that token.  If negative, reduce the rule whose
        -:  781:     number is the opposite.  If YYTABLE_NINF, syntax error.  */
        -:  782:static const yytype_int16 yytable[] =
        -:  783:{
        -:  784:      78,    91,    96,   131,    17,    93,    94,    97,    12,     5,
        -:  785:     186,    19,    84,   132,   187,    21,   124,    85,   127,   128,
        -:  786:     129,   130,    23,    92,   101,   102,    25,   140,   143,    52,
        -:  787:     -37,   137,    42,     9,    24,    43,   133,   147,   148,   149,
        -:  788:     150,   151,   152,   153,   154,   155,   156,   157,   158,   159,
        -:  789:     160,   161,   162,   163,   209,    44,    45,   170,    55,    56,
        -:  790:      57,    58,    59,   144,    60,    61,    62,    63,    28,    64,
        -:  791:     101,   102,    46,   101,   102,    27,    65,    66,    67,    68,
        -:  792:      98,    99,    69,   100,    13,    14,    15,    70,    71,   195,
        -:  793:     196,    72,   179,   180,    30,     2,     3,    35,     4,    33,
        -:  794:     -18,   -18,   -18,   211,    73,   185,   -56,   -56,    74,   164,
        -:  795:     165,   166,   167,   168,   190,   119,   120,   121,    75,    37,
        -:  796:     203,   204,    55,   199,    57,    58,    59,    40,    60,    61,
        -:  797:      62,    63,    47,    64,     5,    49,   207,    50,    51,    86,
        -:  798:      65,    66,    67,    68,    82,    83,    87,    55,   103,    57,
        -:  799:      58,    59,   206,    60,    61,    62,    63,   134,    64,   210,
        -:  800:      88,   182,   125,   136,    64,    65,    66,   174,    73,   177,
        -:  801:     112,   113,    74,   115,   116,   117,   118,   119,   120,   121,
        -:  802:     102,   178,    89,   112,   113,   114,   115,   116,   117,   118,
        -:  803:     119,   120,   121,    73,   112,   113,   184,    74,   116,   117,
        -:  804:     118,   119,   120,   121,   173,   200,   191,    89,   112,   113,
        -:  805:     114,   115,   116,   117,   118,   119,   120,   121,   -96,   112,
        -:  806:     113,   104,   105,    10,   117,   118,   119,   120,   121,   106,
        -:  807:     107,   108,   109,   110,   111,   112,   113,   114,   115,   116,
        -:  808:     117,   118,   119,   120,   121,   201,   -96,   208,    11,   104,
        -:  809:     105,   117,   118,   119,   120,   121,   135,   106,   107,   108,
        -:  810:     109,   110,   111,   112,   113,   114,   115,   116,   117,   118,
        -:  811:     119,   120,   121,   112,   113,   114,   115,   116,   117,   118,
        -:  812:     119,   120,   121,   112,   113,   114,   115,   116,   117,   118,
        -:  813:     119,   120,   121,    36,   135,    48,   123,   146,   193,   175,
        -:  814:     202,     0,    90,     0,   197,   112,   113,   114,   115,   116,
        -:  815:     117,   118,   119,   120,   121,     0,     0,     0,     0,     0,
        -:  816:       0,     0,     0,     0,   171,   112,   113,   114,   115,   116,
        -:  817:     117,   118,   119,   120,   121,     0,     0,     0,     0,     0,
        -:  818:       0,     0,     0,     0,   172,   112,   113,   114,   115,   116,
        -:  819:     117,   118,   119,   120,   121,     0,     0,     0,     0,     0,
        -:  820:       0,     0,     0,     0,   176,   112,   113,   114,   115,   116,
        -:  821:     117,   118,   119,   120,   121
        -:  822:};
        -:  823:
        -:  824:static const yytype_int16 yycheck[] =
        -:  825:{
        -:  826:      49,    69,    75,     1,    11,    73,    74,    75,    20,    39,
        -:  827:      12,    66,    28,    11,    16,    11,    84,    33,    86,    87,
        -:  828:      88,    89,    64,    72,    42,    43,     8,   100,    36,    21,
        -:  829:      22,    99,    17,    63,    11,    20,    34,   105,   106,   107,
        -:  830:     108,   109,   110,   111,   112,   113,   114,   115,   116,   117,
        -:  831:     118,   119,   120,   121,    72,    40,    41,   125,    11,    12,
        -:  832:      13,    14,    15,    71,    17,    18,    19,    20,     9,    22,
        -:  833:      42,    43,    57,    42,    43,    66,    29,    30,    31,    32,
        -:  834:      68,    69,    35,    71,     5,     6,     7,    40,    41,    72,
        -:  835:      73,    44,   141,   142,    11,     0,     1,    67,     3,    66,
        -:  836:       5,     6,     7,    72,    57,   178,    42,    43,    61,    23,
        -:  837:      24,    25,    26,    27,   182,    58,    59,    60,    71,    12,
        -:  838:      72,    73,    11,   191,    13,    14,    15,    10,    17,    18,
        -:  839:      19,    20,    67,    22,    39,    66,   204,    65,    17,    69,
        -:  840:      29,    30,    31,    32,    20,    22,    69,    11,    34,    13,
        -:  841:      14,    15,   201,    17,    18,    19,    20,    72,    22,   208,
        -:  842:      71,     4,    71,    11,    22,    29,    30,    33,    57,    72,
        -:  843:      51,    52,    61,    54,    55,    56,    57,    58,    59,    60,
        -:  844:      43,    73,    71,    51,    52,    53,    54,    55,    56,    57,
        -:  845:      58,    59,    60,    57,    51,    52,    66,    61,    55,    56,
        -:  846:      57,    58,    59,    60,    72,    66,    71,    71,    51,    52,
        -:  847:      53,    54,    55,    56,    57,    58,    59,    60,    34,    51,
        -:  848:      52,    37,    38,     3,    56,    57,    58,    59,    60,    45,
        -:  849:      46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
        -:  850:      56,    57,    58,    59,    60,    71,    34,    71,     3,    37,
        -:  851:      38,    56,    57,    58,    59,    60,    72,    45,    46,    47,
        -:  852:      48,    49,    50,    51,    52,    53,    54,    55,    56,    57,
        -:  853:      58,    59,    60,    51,    52,    53,    54,    55,    56,    57,
        -:  854:      58,    59,    60,    51,    52,    53,    54,    55,    56,    57,
        -:  855:      58,    59,    60,    31,    72,    38,    83,   104,   183,   133,
        -:  856:     196,    -1,    69,    -1,    72,    51,    52,    53,    54,    55,
        -:  857:      56,    57,    58,    59,    60,    -1,    -1,    -1,    -1,    -1,
        -:  858:      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
        -:  859:      56,    57,    58,    59,    60,    -1,    -1,    -1,    -1,    -1,
        -:  860:      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
        -:  861:      56,    57,    58,    59,    60,    -1,    -1,    -1,    -1,    -1,
        -:  862:      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
        -:  863:      56,    57,    58,    59,    60
        -:  864:};
        -:  865:
        -:  866:  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
        -:  867:     symbol of state STATE-NUM.  */
        -:  868:static const yytype_uint8 yystos[] =
        -:  869:{
        -:  870:       0,    75,     0,     1,     3,    39,    76,    77,    83,    63,
        -:  871:      76,    77,    20,     5,     6,     7,    84,    11,    78,    66,
        -:  872:      85,    11,    86,    64,    11,     8,    80,    66,     9,    81,
        -:  873:      11,    87,    88,    66,    79,    67,    88,    12,    89,    90,
        -:  874:      10,    82,    17,    20,    40,    41,    57,    67,    90,    66,
        -:  875:      65,    17,    21,    91,    92,    11,    12,    13,    14,    15,
        -:  876:      17,    18,    19,    20,    22,    29,    30,    31,    32,    35,
        -:  877:      40,    41,    44,    57,    61,    71,    95,    98,    99,   100,
        -:  878:     113,   114,    20,    22,    28,    33,    69,    69,    71,    71,
        -:  879:     113,   114,    99,   114,   114,    99,   100,   114,    68,    69,
        -:  880:      71,    42,    43,    34,    37,    38,    45,    46,    47,    48,
        -:  881:      49,    50,    51,    52,    53,    54,    55,    56,    57,    58,
        -:  882:      59,    60,    93,    93,   114,    71,   107,   114,   114,   114,
        -:  883:     114,     1,    11,    34,    72,    72,    11,   114,    96,    97,
        -:  884:     100,   105,   104,    36,    71,   109,    98,   114,   114,   114,
        -:  885:     114,   114,   114,   114,   114,   114,   114,   114,   114,   114,
        -:  886:     114,   114,   114,   114,    23,    24,    25,    26,    27,    94,
        -:  887:     114,    70,    70,    72,    33,   109,    70,    72,    73,    99,
        -:  888:      99,   110,     4,   101,    66,   100,    12,    16,   111,   112,
        -:  889:     114,    71,   106,   107,   103,    72,    73,    72,   108,   114,
        -:  890:      66,    71,   112,    72,    73,   102,    99,   114,    71,    72,
        -:  891:      99,    72
        -:  892:};
        -:  893:
        -:  894:  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
        -:  895:static const yytype_uint8 yyr1[] =
        -:  896:{
        -:  897:       0,    74,    75,    75,    75,    75,    75,    75,    75,    76,
        -:  898:      78,    79,    77,    80,    80,    81,    81,    82,    83,    83,
        -:  899:      84,    84,    85,    85,    86,    86,    87,    87,    88,    88,
        -:  900:      88,    88,    88,    89,    89,    91,    90,    92,    90,    90,
        -:  901:      93,    93,    94,    94,    94,    94,    94,    95,    95,    95,
        -:  902:      95,    96,    96,    97,    97,    98,    99,   100,   100,   100,
        -:  903:     100,   100,   100,   100,   100,   101,   102,   100,   103,   100,
        -:  904:     100,   100,   104,   100,   105,   100,   100,   100,   100,   100,
        -:  905:     100,   100,   100,   100,   106,   106,   107,   108,   108,   110,
        -:  906:     109,   109,   111,   111,   112,   112,   113,   113,   113,   114,
        -:  907:     114,   114,   114,   114,   114,   114,   114,   114,   114,   114,
        -:  908:     114,   114,   114,   114,   114,   114,   114,   114,   114,   114,
        -:  909:     114,   114,   114,   114,   114
        -:  910:};
        -:  911:
        -:  912:  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
        -:  913:static const yytype_uint8 yyr2[] =
        -:  914:{
        -:  915:       0,     2,     0,     2,     2,     3,     3,     3,     2,     2,
        -:  916:       0,     0,    11,     0,     3,     0,     3,     3,     0,     2,
        -:  917:       1,     1,     0,     2,     1,     2,     1,     2,     3,     3,
        -:  918:       4,     3,     3,     1,     2,     0,     5,     0,     5,     3,
        -:  919:       0,     2,     1,     1,     1,     1,     1,     1,     3,     4,
        -:  920:       4,     0,     1,     1,     3,     1,     1,     1,     1,     3,
        -:  921:       3,     1,     3,     3,     3,     0,     0,    11,     0,     9,
        -:  922:       3,     2,     0,     4,     0,     4,     3,     3,     3,     3,
        -:  923:       3,     3,     1,     3,     3,     1,     5,     1,     3,     0,
        -:  924:       4,     1,     1,     3,     1,     1,     1,     1,     1,     3,
        -:  925:       1,     1,     4,     1,     1,     1,     1,     4,     1,     4,
        -:  926:       1,     1,     2,     3,     3,     3,     3,     3,     3,     3,
        -:  927:       3,     2,     3,     3,     1
        -:  928:};
        -:  929:
        -:  930:
        -:  931:#define yyerrok         (yyerrstatus = 0)
        -:  932:#define yyclearin       (yychar = YYEMPTY)
        -:  933:#define YYEMPTY         (-2)
        -:  934:#define YYEOF           0
        -:  935:
        -:  936:#define YYACCEPT        goto yyacceptlab
        -:  937:#define YYABORT         goto yyabortlab
        -:  938:#define YYERROR         goto yyerrorlab
        -:  939:
        -:  940:
        -:  941:#define YYRECOVERING()  (!!yyerrstatus)
        -:  942:
        -:  943:#define YYBACKUP(Token, Value)                                  \
        -:  944:do                                                              \
        -:  945:  if (yychar == YYEMPTY)                                        \
        -:  946:    {                                                           \
        -:  947:      yychar = (Token);                                         \
        -:  948:      yylval = (Value);                                         \
        -:  949:      YYPOPSTACK (yylen);                                       \
        -:  950:      yystate = *yyssp;                                         \
        -:  951:      goto yybackup;                                            \
        -:  952:    }                                                           \
        -:  953:  else                                                          \
        -:  954:    {                                                           \
        -:  955:      yyerror (yyscanner, compiler, YY_("syntax error: cannot back up")); \
        -:  956:      YYERROR;                                                  \
        -:  957:    }                                                           \
        -:  958:while (0)
        -:  959:
        -:  960:/* Error token number */
        -:  961:#define YYTERROR        1
        -:  962:#define YYERRCODE       256
        -:  963:
        -:  964:
        -:  965:
        -:  966:/* Enable debugging if requested.  */
        -:  967:#if YYDEBUG
        -:  968:
        -:  969:# ifndef YYFPRINTF
        -:  970:#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
        -:  971:#  define YYFPRINTF fprintf
        -:  972:# endif
        -:  973:
        -:  974:# define YYDPRINTF(Args)                        \
        -:  975:do {                                            \
        -:  976:  if (yydebug)                                  \
        -:  977:    YYFPRINTF Args;                             \
        -:  978:} while (0)
        -:  979:
        -:  980:/* This macro is provided for backward compatibility. */
        -:  981:#ifndef YY_LOCATION_PRINT
        -:  982:# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
        -:  983:#endif
        -:  984:
        -:  985:
        -:  986:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
        -:  987:do {                                                                      \
        -:  988:  if (yydebug)                                                            \
        -:  989:    {                                                                     \
        -:  990:      YYFPRINTF (stderr, "%s ", Title);                                   \
        -:  991:      yy_symbol_print (stderr,                                            \
        -:  992:                  Type, Value, yyscanner, compiler); \
        -:  993:      YYFPRINTF (stderr, "\n");                                           \
        -:  994:    }                                                                     \
        -:  995:} while (0)
        -:  996:
        -:  997:
        -:  998:/*----------------------------------------.
        -:  999:| Print this symbol's value on YYOUTPUT.  |
        -: 1000:`----------------------------------------*/
        -: 1001:
        -: 1002:static void
        -: 1003:yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1004:{
        -: 1005:  FILE *yyo = yyoutput;
        -: 1006:  YYUSE (yyo);
        -: 1007:  YYUSE (yyscanner);
        -: 1008:  YYUSE (compiler);
        -: 1009:  if (!yyvaluep)
        -: 1010:    return;
        -: 1011:# ifdef YYPRINT
        -: 1012:  if (yytype < YYNTOKENS)
        -: 1013:    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
        -: 1014:# endif
        -: 1015:  YYUSE (yytype);
        -: 1016:}
        -: 1017:
        -: 1018:
        -: 1019:/*--------------------------------.
        -: 1020:| Print this symbol on YYOUTPUT.  |
        -: 1021:`--------------------------------*/
        -: 1022:
        -: 1023:static void
        -: 1024:yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1025:{
        -: 1026:  YYFPRINTF (yyoutput, "%s %s (",
        -: 1027:             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
        -: 1028:
        -: 1029:  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yyscanner, compiler);
        -: 1030:  YYFPRINTF (yyoutput, ")");
        -: 1031:}
        -: 1032:
        -: 1033:/*------------------------------------------------------------------.
        -: 1034:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
        -: 1035:| TOP (included).                                                   |
        -: 1036:`------------------------------------------------------------------*/
        -: 1037:
        -: 1038:static void
        -: 1039:yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
        -: 1040:{
        -: 1041:  YYFPRINTF (stderr, "Stack now");
        -: 1042:  for (; yybottom <= yytop; yybottom++)
        -: 1043:    {
        -: 1044:      int yybot = *yybottom;
        -: 1045:      YYFPRINTF (stderr, " %d", yybot);
        -: 1046:    }
        -: 1047:  YYFPRINTF (stderr, "\n");
        -: 1048:}
        -: 1049:
        -: 1050:# define YY_STACK_PRINT(Bottom, Top)                            \
        -: 1051:do {                                                            \
        -: 1052:  if (yydebug)                                                  \
        -: 1053:    yy_stack_print ((Bottom), (Top));                           \
        -: 1054:} while (0)
        -: 1055:
        -: 1056:
        -: 1057:/*------------------------------------------------.
        -: 1058:| Report that the YYRULE is going to be reduced.  |
        -: 1059:`------------------------------------------------*/
        -: 1060:
        -: 1061:static void
        -: 1062:yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, void *yyscanner, YR_COMPILER* compiler)
        -: 1063:{
        -: 1064:  unsigned long int yylno = yyrline[yyrule];
        -: 1065:  int yynrhs = yyr2[yyrule];
        -: 1066:  int yyi;
        -: 1067:  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
        -: 1068:             yyrule - 1, yylno);
        -: 1069:  /* The symbols being reduced.  */
        -: 1070:  for (yyi = 0; yyi < yynrhs; yyi++)
        -: 1071:    {
        -: 1072:      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
        -: 1073:      yy_symbol_print (stderr,
        -: 1074:                       yystos[yyssp[yyi + 1 - yynrhs]],
        -: 1075:                       &(yyvsp[(yyi + 1) - (yynrhs)])
        -: 1076:                                              , yyscanner, compiler);
        -: 1077:      YYFPRINTF (stderr, "\n");
        -: 1078:    }
        -: 1079:}
        -: 1080:
        -: 1081:# define YY_REDUCE_PRINT(Rule)          \
        -: 1082:do {                                    \
        -: 1083:  if (yydebug)                          \
        -: 1084:    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner, compiler); \
        -: 1085:} while (0)
        -: 1086:
        -: 1087:/* Nonzero means print parse trace.  It is left uninitialized so that
        -: 1088:   multiple parsers can coexist.  */
        -: 1089:int yydebug;
        -: 1090:#else /* !YYDEBUG */
        -: 1091:# define YYDPRINTF(Args)
        -: 1092:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
        -: 1093:# define YY_STACK_PRINT(Bottom, Top)
        -: 1094:# define YY_REDUCE_PRINT(Rule)
        -: 1095:#endif /* !YYDEBUG */
        -: 1096:
        -: 1097:
        -: 1098:/* YYINITDEPTH -- initial size of the parser's stacks.  */
        -: 1099:#ifndef YYINITDEPTH
        -: 1100:# define YYINITDEPTH 200
        -: 1101:#endif
        -: 1102:
        -: 1103:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
        -: 1104:   if the built-in stack extension method is used).
        -: 1105:
        -: 1106:   Do not make this value too large; the results are undefined if
        -: 1107:   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
        -: 1108:   evaluated with infinite-precision integer arithmetic.  */
        -: 1109:
        -: 1110:#ifndef YYMAXDEPTH
        -: 1111:# define YYMAXDEPTH 10000
        -: 1112:#endif
        -: 1113:
        -: 1114:
        -: 1115:#if YYERROR_VERBOSE
        -: 1116:
        -: 1117:# ifndef yystrlen
        -: 1118:#  if defined __GLIBC__ && defined _STRING_H
        -: 1119:#   define yystrlen strlen
        -: 1120:#  else
        -: 1121:/* Return the length of YYSTR.  */
        -: 1122:static YYSIZE_T
        -: 1123:yystrlen (const char *yystr)
        -: 1124:{
        -: 1125:  YYSIZE_T yylen;
        -: 1126:  for (yylen = 0; yystr[yylen]; yylen++)
        -: 1127:    continue;
        -: 1128:  return yylen;
        -: 1129:}
        -: 1130:#  endif
        -: 1131:# endif
        -: 1132:
        -: 1133:# ifndef yystpcpy
        -: 1134:#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
        -: 1135:#   define yystpcpy stpcpy
        -: 1136:#  else
        -: 1137:/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
        -: 1138:   YYDEST.  */
        -: 1139:static char *
    #####: 1140:yystpcpy (char *yydest, const char *yysrc)
        -: 1141:{
    #####: 1142:  char *yyd = yydest;
    #####: 1143:  const char *yys = yysrc;
        -: 1144:
    #####: 1145:  while ((*yyd++ = *yys++) != '\0')
    #####: 1146:    continue;
        -: 1147:
    #####: 1148:  return yyd - 1;
        -: 1149:}
        -: 1150:#  endif
        -: 1151:# endif
        -: 1152:
        -: 1153:# ifndef yytnamerr
        -: 1154:/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
        -: 1155:   quotes and backslashes, so that it's suitable for yyerror.  The
        -: 1156:   heuristic is that double-quoting is unnecessary unless the string
        -: 1157:   contains an apostrophe, a comma, or backslash (other than
        -: 1158:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
        -: 1159:   null, do not copy; instead, return the length of what the result
        -: 1160:   would have been.  */
        -: 1161:static YYSIZE_T
    #####: 1162:yytnamerr (char *yyres, const char *yystr)
        -: 1163:{
    #####: 1164:  if (*yystr == '"')
        -: 1165:    {
    #####: 1166:      YYSIZE_T yyn = 0;
    #####: 1167:      char const *yyp = yystr;
        -: 1168:
        -: 1169:      for (;;)
    #####: 1170:        switch (*++yyp)
        -: 1171:          {
    #####: 1172:          case '\'':
        -: 1173:          case ',':
    #####: 1174:            goto do_not_strip_quotes;
        -: 1175:
    #####: 1176:          case '\\':
    #####: 1177:            if (*++yyp != '\\')
    #####: 1178:              goto do_not_strip_quotes;
        -: 1179:            /* Fall through.  */
        -: 1180:          default:
    #####: 1181:            if (yyres)
    #####: 1182:              yyres[yyn] = *yyp;
    #####: 1183:            yyn++;
    #####: 1184:            break;
        -: 1185:
    #####: 1186:          case '"':
    #####: 1187:            if (yyres)
    #####: 1188:              yyres[yyn] = '\0';
    #####: 1189:            return yyn;
        -: 1190:          }
    #####: 1191:    do_not_strip_quotes: ;
        -: 1192:    }
        -: 1193:
    #####: 1194:  if (! yyres)
    #####: 1195:    return yystrlen (yystr);
        -: 1196:
    #####: 1197:  return yystpcpy (yyres, yystr) - yyres;
        -: 1198:}
        -: 1199:# endif
        -: 1200:
        -: 1201:/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
        -: 1202:   about the unexpected token YYTOKEN for the state stack whose top is
        -: 1203:   YYSSP.
        -: 1204:
        -: 1205:   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
        -: 1206:   not large enough to hold the message.  In that case, also set
        -: 1207:   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
        -: 1208:   required number of bytes is too large to store.  */
        -: 1209:static int
    #####: 1210:yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
        -: 1211:                yytype_int16 *yyssp, int yytoken)
        -: 1212:{
    #####: 1213:  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
    #####: 1214:  YYSIZE_T yysize = yysize0;
        -: 1215:  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
        -: 1216:  /* Internationalized format string. */
    #####: 1217:  const char *yyformat = YY_NULLPTR;
        -: 1218:  /* Arguments of yyformat. */
        -: 1219:  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
        -: 1220:  /* Number of reported tokens (one for the "unexpected", one per
        -: 1221:     "expected"). */
    #####: 1222:  int yycount = 0;
        -: 1223:
        -: 1224:  /* There are many possibilities here to consider:
        -: 1225:     - If this state is a consistent state with a default action, then
        -: 1226:       the only way this function was invoked is if the default action
        -: 1227:       is an error action.  In that case, don't check for expected
        -: 1228:       tokens because there are none.
        -: 1229:     - The only way there can be no lookahead present (in yychar) is if
        -: 1230:       this state is a consistent state with a default action.  Thus,
        -: 1231:       detecting the absence of a lookahead is sufficient to determine
        -: 1232:       that there is no unexpected or expected token to report.  In that
        -: 1233:       case, just report a simple "syntax error".
        -: 1234:     - Don't assume there isn't a lookahead just because this state is a
        -: 1235:       consistent state with a default action.  There might have been a
        -: 1236:       previous inconsistent state, consistent state with a non-default
        -: 1237:       action, or user semantic action that manipulated yychar.
        -: 1238:     - Of course, the expected token list depends on states to have
        -: 1239:       correct lookahead information, and it depends on the parser not
        -: 1240:       to perform extra reductions after fetching a lookahead from the
        -: 1241:       scanner and before detecting a syntax error.  Thus, state merging
        -: 1242:       (from LALR or IELR) and default reductions corrupt the expected
        -: 1243:       token list.  However, the list is correct for canonical LR with
        -: 1244:       one exception: it will still contain any token that will not be
        -: 1245:       accepted due to an error action in a later state.
        -: 1246:  */
    #####: 1247:  if (yytoken != YYEMPTY)
        -: 1248:    {
    #####: 1249:      int yyn = yypact[*yyssp];
    #####: 1250:      yyarg[yycount++] = yytname[yytoken];
    #####: 1251:      if (!yypact_value_is_default (yyn))
        -: 1252:        {
        -: 1253:          /* Start YYX at -YYN if negative to avoid negative indexes in
        -: 1254:             YYCHECK.  In other words, skip the first -YYN actions for
        -: 1255:             this state because they are default actions.  */
    #####: 1256:          int yyxbegin = yyn < 0 ? -yyn : 0;
        -: 1257:          /* Stay within bounds of both yycheck and yytname.  */
    #####: 1258:          int yychecklim = YYLAST - yyn + 1;
    #####: 1259:          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
        -: 1260:          int yyx;
        -: 1261:
    #####: 1262:          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
    #####: 1263:            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
    #####: 1264:                && !yytable_value_is_error (yytable[yyx + yyn]))
        -: 1265:              {
    #####: 1266:                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
        -: 1267:                  {
    #####: 1268:                    yycount = 1;
    #####: 1269:                    yysize = yysize0;
    #####: 1270:                    break;
        -: 1271:                  }
    #####: 1272:                yyarg[yycount++] = yytname[yyx];
        -: 1273:                {
    #####: 1274:                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
    #####: 1275:                  if (! (yysize <= yysize1
        -: 1276:                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
    #####: 1277:                    return 2;
    #####: 1278:                  yysize = yysize1;
        -: 1279:                }
        -: 1280:              }
        -: 1281:        }
        -: 1282:    }
        -: 1283:
    #####: 1284:  switch (yycount)
        -: 1285:    {
        -: 1286:# define YYCASE_(N, S)                      \
        -: 1287:      case N:                               \
        -: 1288:        yyformat = S;                       \
        -: 1289:      break
    #####: 1290:      YYCASE_(0, YY_("syntax error"));
    #####: 1291:      YYCASE_(1, YY_("syntax error, unexpected %s"));
    #####: 1292:      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
    #####: 1293:      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
    #####: 1294:      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
    #####: 1295:      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
        -: 1296:# undef YYCASE_
        -: 1297:    }
        -: 1298:
        -: 1299:  {
    #####: 1300:    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
    #####: 1301:    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
    #####: 1302:      return 2;
    #####: 1303:    yysize = yysize1;
        -: 1304:  }
        -: 1305:
    #####: 1306:  if (*yymsg_alloc < yysize)
        -: 1307:    {
    #####: 1308:      *yymsg_alloc = 2 * yysize;
    #####: 1309:      if (! (yysize <= *yymsg_alloc
        -: 1310:             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
    #####: 1311:        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
    #####: 1312:      return 1;
        -: 1313:    }
        -: 1314:
        -: 1315:  /* Avoid sprintf, as that infringes on the user's name space.
        -: 1316:     Don't have undefined behavior even if the translation
        -: 1317:     produced a string with the wrong number of "%s"s.  */
        -: 1318:  {
    #####: 1319:    char *yyp = *yymsg;
    #####: 1320:    int yyi = 0;
    #####: 1321:    while ((*yyp = *yyformat) != '\0')
    #####: 1322:      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        -: 1323:        {
    #####: 1324:          yyp += yytnamerr (yyp, yyarg[yyi++]);
    #####: 1325:          yyformat += 2;
        -: 1326:        }
        -: 1327:      else
        -: 1328:        {
    #####: 1329:          yyp++;
    #####: 1330:          yyformat++;
        -: 1331:        }
        -: 1332:  }
    #####: 1333:  return 0;
        -: 1334:}
        -: 1335:#endif /* YYERROR_VERBOSE */
        -: 1336:
        -: 1337:/*-----------------------------------------------.
        -: 1338:| Release the memory associated to this symbol.  |
        -: 1339:`-----------------------------------------------*/
        -: 1340:
        -: 1341:static void
    #####: 1342:yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1343:{
        -: 1344:  YYUSE (yyvaluep);
        -: 1345:  YYUSE (yyscanner);
        -: 1346:  YYUSE (compiler);
    #####: 1347:  if (!yymsg)
    #####: 1348:    yymsg = "Deleting";
        -: 1349:  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
        -: 1350:
        -: 1351:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 1352:  switch (yytype)
        -: 1353:    {
    #####: 1354:          case 11: /* "identifier"  */
        -: 1355:#line 229 "grammar.y" /* yacc.c:1257  */
        -: 1356:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1357:#line 1358 "grammar.c" /* yacc.c:1257  */
    #####: 1358:        break;
        -: 1359:
    #####: 1360:    case 12: /* "string identifier"  */
        -: 1361:#line 233 "grammar.y" /* yacc.c:1257  */
        -: 1362:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1363:#line 1364 "grammar.c" /* yacc.c:1257  */
    #####: 1364:        break;
        -: 1365:
    #####: 1366:    case 13: /* "string count"  */
        -: 1367:#line 230 "grammar.y" /* yacc.c:1257  */
        -: 1368:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1369:#line 1370 "grammar.c" /* yacc.c:1257  */
    #####: 1370:        break;
        -: 1371:
    #####: 1372:    case 14: /* "string offset"  */
        -: 1373:#line 231 "grammar.y" /* yacc.c:1257  */
        -: 1374:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1375:#line 1376 "grammar.c" /* yacc.c:1257  */
    #####: 1376:        break;
        -: 1377:
    #####: 1378:    case 15: /* "string length"  */
        -: 1379:#line 232 "grammar.y" /* yacc.c:1257  */
        -: 1380:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1381:#line 1382 "grammar.c" /* yacc.c:1257  */
    #####: 1382:        break;
        -: 1383:
    #####: 1384:    case 16: /* "string identifier with wildcard"  */
        -: 1385:#line 234 "grammar.y" /* yacc.c:1257  */
        -: 1386:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1387:#line 1388 "grammar.c" /* yacc.c:1257  */
    #####: 1388:        break;
        -: 1389:
    #####: 1390:    case 20: /* "text string"  */
        -: 1391:#line 235 "grammar.y" /* yacc.c:1257  */
        -: 1392:      { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1393:#line 1394 "grammar.c" /* yacc.c:1257  */
    #####: 1394:        break;
        -: 1395:
    #####: 1396:    case 21: /* "hex string"  */
        -: 1397:#line 236 "grammar.y" /* yacc.c:1257  */
        -: 1398:      { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1399:#line 1400 "grammar.c" /* yacc.c:1257  */
    #####: 1400:        break;
        -: 1401:
    #####: 1402:    case 22: /* "regular expression"  */
        -: 1403:#line 237 "grammar.y" /* yacc.c:1257  */
        -: 1404:      { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1405:#line 1406 "grammar.c" /* yacc.c:1257  */
    #####: 1406:        break;
        -: 1407:
    #####: 1408:    case 96: /* arguments  */
        -: 1409:#line 239 "grammar.y" /* yacc.c:1257  */
        -: 1410:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1411:#line 1412 "grammar.c" /* yacc.c:1257  */
    #####: 1412:        break;
        -: 1413:
    #####: 1414:    case 97: /* arguments_list  */
        -: 1415:#line 240 "grammar.y" /* yacc.c:1257  */
        -: 1416:      { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1417:#line 1418 "grammar.c" /* yacc.c:1257  */
    #####: 1418:        break;
        -: 1419:
        -: 1420:
    #####: 1421:      default:
    #####: 1422:        break;
        -: 1423:    }
        -: 1424:  YY_IGNORE_MAYBE_UNINITIALIZED_END
    #####: 1425:}
        -: 1426:
        -: 1427:
        -: 1428:
        -: 1429:
        -: 1430:/*----------.
        -: 1431:| yyparse.  |
        -: 1432:`----------*/
        -: 1433:
        -: 1434:int
    #####: 1435:yyparse (void *yyscanner, YR_COMPILER* compiler)
        -: 1436:{
        -: 1437:/* The lookahead symbol.  */
        -: 1438:int yychar;
        -: 1439:
        -: 1440:
        -: 1441:/* The semantic value of the lookahead symbol.  */
        -: 1442:/* Default value used for initialization, for pacifying older GCCs
        -: 1443:   or non-GCC compilers.  */
        -: 1444:YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
        -: 1445:YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
        -: 1446:
        -: 1447:    /* Number of syntax errors so far.  */
        -: 1448:    int yynerrs;
        -: 1449:
        -: 1450:    int yystate;
        -: 1451:    /* Number of tokens to shift before error messages enabled.  */
        -: 1452:    int yyerrstatus;
        -: 1453:
        -: 1454:    /* The stacks and their tools:
        -: 1455:       'yyss': related to states.
        -: 1456:       'yyvs': related to semantic values.
        -: 1457:
        -: 1458:       Refer to the stacks through separate pointers, to allow yyoverflow
        -: 1459:       to reallocate them elsewhere.  */
        -: 1460:
        -: 1461:    /* The state stack.  */
        -: 1462:    yytype_int16 yyssa[YYINITDEPTH];
        -: 1463:    yytype_int16 *yyss;
        -: 1464:    yytype_int16 *yyssp;
        -: 1465:
        -: 1466:    /* The semantic value stack.  */
        -: 1467:    YYSTYPE yyvsa[YYINITDEPTH];
        -: 1468:    YYSTYPE *yyvs;
        -: 1469:    YYSTYPE *yyvsp;
        -: 1470:
        -: 1471:    YYSIZE_T yystacksize;
        -: 1472:
        -: 1473:  int yyn;
        -: 1474:  int yyresult;
        -: 1475:  /* Lookahead token as an internal (translated) token number.  */
    #####: 1476:  int yytoken = 0;
        -: 1477:  /* The variables used to return semantic value and location from the
        -: 1478:     action routines.  */
        -: 1479:  YYSTYPE yyval;
        -: 1480:
        -: 1481:#if YYERROR_VERBOSE
        -: 1482:  /* Buffer for error messages, and its allocated size.  */
        -: 1483:  char yymsgbuf[128];
    #####: 1484:  char *yymsg = yymsgbuf;
    #####: 1485:  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
        -: 1486:#endif
        -: 1487:
        -: 1488:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
        -: 1489:
        -: 1490:  /* The number of symbols on the RHS of the reduced rule.
        -: 1491:     Keep to zero when no symbol should be popped.  */
    #####: 1492:  int yylen = 0;
        -: 1493:
    #####: 1494:  yyssp = yyss = yyssa;
    #####: 1495:  yyvsp = yyvs = yyvsa;
    #####: 1496:  yystacksize = YYINITDEPTH;
        -: 1497:
        -: 1498:  YYDPRINTF ((stderr, "Starting parse\n"));
        -: 1499:
    #####: 1500:  yystate = 0;
    #####: 1501:  yyerrstatus = 0;
    #####: 1502:  yynerrs = 0;
    #####: 1503:  yychar = YYEMPTY; /* Cause a token to be read.  */
    #####: 1504:  goto yysetstate;
        -: 1505:
        -: 1506:/*------------------------------------------------------------.
        -: 1507:| yynewstate -- Push a new state, which is found in yystate.  |
        -: 1508:`------------------------------------------------------------*/
    #####: 1509: yynewstate:
        -: 1510:  /* In all cases, when you get here, the value and location stacks
        -: 1511:     have just been pushed.  So pushing a state here evens the stacks.  */
    #####: 1512:  yyssp++;
        -: 1513:
    #####: 1514: yysetstate:
    #####: 1515:  *yyssp = yystate;
        -: 1516:
    #####: 1517:  if (yyss + yystacksize - 1 <= yyssp)
        -: 1518:    {
        -: 1519:      /* Get the current used size of the three stacks, in elements.  */
    #####: 1520:      YYSIZE_T yysize = yyssp - yyss + 1;
        -: 1521:
        -: 1522:#ifdef yyoverflow
        -: 1523:      {
        -: 1524:        /* Give user a chance to reallocate the stack.  Use copies of
        -: 1525:           these so that the &'s don't force the real ones into
        -: 1526:           memory.  */
        -: 1527:        YYSTYPE *yyvs1 = yyvs;
        -: 1528:        yytype_int16 *yyss1 = yyss;
        -: 1529:
        -: 1530:        /* Each stack pointer address is followed by the size of the
        -: 1531:           data in use in that stack, in bytes.  This used to be a
        -: 1532:           conditional around just the two extra args, but that might
        -: 1533:           be undefined if yyoverflow is a macro.  */
        -: 1534:        yyoverflow (YY_("memory exhausted"),
        -: 1535:                    &yyss1, yysize * sizeof (*yyssp),
        -: 1536:                    &yyvs1, yysize * sizeof (*yyvsp),
        -: 1537:                    &yystacksize);
        -: 1538:
        -: 1539:        yyss = yyss1;
        -: 1540:        yyvs = yyvs1;
        -: 1541:      }
        -: 1542:#else /* no yyoverflow */
        -: 1543:# ifndef YYSTACK_RELOCATE
        -: 1544:      goto yyexhaustedlab;
        -: 1545:# else
        -: 1546:      /* Extend the stack our own way.  */
    #####: 1547:      if (YYMAXDEPTH <= yystacksize)
    #####: 1548:        goto yyexhaustedlab;
    #####: 1549:      yystacksize *= 2;
    #####: 1550:      if (YYMAXDEPTH < yystacksize)
    #####: 1551:        yystacksize = YYMAXDEPTH;
        -: 1552:
        -: 1553:      {
    #####: 1554:        yytype_int16 *yyss1 = yyss;
    #####: 1555:        union yyalloc *yyptr =
    #####: 1556:          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
    #####: 1557:        if (! yyptr)
    #####: 1558:          goto yyexhaustedlab;
    #####: 1559:        YYSTACK_RELOCATE (yyss_alloc, yyss);
    #####: 1560:        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        -: 1561:#  undef YYSTACK_RELOCATE
    #####: 1562:        if (yyss1 != yyssa)
    #####: 1563:          YYSTACK_FREE (yyss1);
        -: 1564:      }
        -: 1565:# endif
        -: 1566:#endif /* no yyoverflow */
        -: 1567:
    #####: 1568:      yyssp = yyss + yysize - 1;
    #####: 1569:      yyvsp = yyvs + yysize - 1;
        -: 1570:
        -: 1571:      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
        -: 1572:                  (unsigned long int) yystacksize));
        -: 1573:
    #####: 1574:      if (yyss + yystacksize - 1 <= yyssp)
    #####: 1575:        YYABORT;
        -: 1576:    }
        -: 1577:
        -: 1578:  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
        -: 1579:
    #####: 1580:  if (yystate == YYFINAL)
    #####: 1581:    YYACCEPT;
        -: 1582:
    #####: 1583:  goto yybackup;
        -: 1584:
        -: 1585:/*-----------.
        -: 1586:| yybackup.  |
        -: 1587:`-----------*/
    #####: 1588:yybackup:
        -: 1589:
        -: 1590:  /* Do appropriate processing given the current state.  Read a
        -: 1591:     lookahead token if we need one and don't already have one.  */
        -: 1592:
        -: 1593:  /* First try to decide what to do without reference to lookahead token.  */
    #####: 1594:  yyn = yypact[yystate];
    #####: 1595:  if (yypact_value_is_default (yyn))
    #####: 1596:    goto yydefault;
        -: 1597:
        -: 1598:  /* Not known => get a lookahead token if don't already have one.  */
        -: 1599:
        -: 1600:  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
    #####: 1601:  if (yychar == YYEMPTY)
        -: 1602:    {
        -: 1603:      YYDPRINTF ((stderr, "Reading a token: "));
    #####: 1604:      yychar = yylex (&yylval, yyscanner, compiler);
        -: 1605:    }
        -: 1606:
    #####: 1607:  if (yychar <= YYEOF)
        -: 1608:    {
    #####: 1609:      yychar = yytoken = YYEOF;
        -: 1610:      YYDPRINTF ((stderr, "Now at end of input.\n"));
        -: 1611:    }
        -: 1612:  else
        -: 1613:    {
    #####: 1614:      yytoken = YYTRANSLATE (yychar);
        -: 1615:      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
        -: 1616:    }
        -: 1617:
        -: 1618:  /* If the proper action on seeing token YYTOKEN is to reduce or to
        -: 1619:     detect an error, take that action.  */
    #####: 1620:  yyn += yytoken;
    #####: 1621:  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
        -: 1622:    goto yydefault;
    #####: 1623:  yyn = yytable[yyn];
    #####: 1624:  if (yyn <= 0)
        -: 1625:    {
        -: 1626:      if (yytable_value_is_error (yyn))
        -: 1627:        goto yyerrlab;
    #####: 1628:      yyn = -yyn;
    #####: 1629:      goto yyreduce;
        -: 1630:    }
        -: 1631:
        -: 1632:  /* Count tokens shifted since error; after three, turn off error
        -: 1633:     status.  */
    #####: 1634:  if (yyerrstatus)
    #####: 1635:    yyerrstatus--;
        -: 1636:
        -: 1637:  /* Shift the lookahead token.  */
        -: 1638:  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
        -: 1639:
        -: 1640:  /* Discard the shifted token.  */
    #####: 1641:  yychar = YYEMPTY;
        -: 1642:
    #####: 1643:  yystate = yyn;
        -: 1644:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 1645:  *++yyvsp = yylval;
        -: 1646:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1647:
    #####: 1648:  goto yynewstate;
        -: 1649:
        -: 1650:
        -: 1651:/*-----------------------------------------------------------.
        -: 1652:| yydefault -- do the default action for the current state.  |
        -: 1653:`-----------------------------------------------------------*/
    #####: 1654:yydefault:
    #####: 1655:  yyn = yydefact[yystate];
    #####: 1656:  if (yyn == 0)
    #####: 1657:    goto yyerrlab;
    #####: 1658:  goto yyreduce;
        -: 1659:
        -: 1660:
        -: 1661:/*-----------------------------.
        -: 1662:| yyreduce -- Do a reduction.  |
        -: 1663:`-----------------------------*/
    #####: 1664:yyreduce:
        -: 1665:  /* yyn is the number of a rule to reduce with.  */
    #####: 1666:  yylen = yyr2[yyn];
        -: 1667:
        -: 1668:  /* If YYLEN is nonzero, implement the default value of the action:
        -: 1669:     '$$ = $1'.
        -: 1670:
        -: 1671:     Otherwise, the following line sets YYVAL to garbage.
        -: 1672:     This behavior is undocumented and Bison
        -: 1673:     users should not rely upon it.  Assigning to YYVAL
        -: 1674:     unconditionally makes the parser a bit smaller, and it avoids a
        -: 1675:     GCC warning that YYVAL may be used uninitialized.  */
    #####: 1676:  yyval = yyvsp[1-yylen];
        -: 1677:
        -: 1678:
        -: 1679:  YY_REDUCE_PRINT (yyn);
    #####: 1680:  switch (yyn)
        -: 1681:    {
    #####: 1682:        case 8:
        -: 1683:#line 264 "grammar.y" /* yacc.c:1646  */
        -: 1684:    {
        -: 1685:        _yr_compiler_pop_file_name(compiler);
        -: 1686:      }
        -: 1687:#line 1688 "grammar.c" /* yacc.c:1646  */
    #####: 1688:    break;
        -: 1689:
    #####: 1690:  case 9:
        -: 1691:#line 272 "grammar.y" /* yacc.c:1646  */
        -: 1692:    {
        -: 1693:        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));
        -: 1694:
        -: 1695:        yr_free((yyvsp[0].sized_string));
        -: 1696:
        -: 1697:        fail_if_error(result);
        -: 1698:      }
        -: 1699:#line 1700 "grammar.c" /* yacc.c:1646  */
    #####: 1700:    break;
        -: 1701:
    #####: 1702:  case 10:
        -: 1703:#line 284 "grammar.y" /* yacc.c:1646  */
        -: 1704:    {
        -: 1705:        fail_if_error(yr_parser_reduce_rule_declaration_phase_1(
        -: 1706:            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string), &(yyval.rule)));
        -: 1707:      }
        -: 1708:#line 1709 "grammar.c" /* yacc.c:1646  */
    #####: 1709:    break;
        -: 1710:
    #####: 1711:  case 11:
        -: 1712:#line 289 "grammar.y" /* yacc.c:1646  */
        -: 1713:    {
        -: 1714:        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1
        -: 1715:
        -: 1716:        rule->tags = (yyvsp[-3].c_string);
        -: 1717:        rule->metas = (yyvsp[-1].meta);
        -: 1718:        rule->strings = (yyvsp[0].string);
        -: 1719:      }
        -: 1720:#line 1721 "grammar.c" /* yacc.c:1646  */
    #####: 1721:    break;
        -: 1722:
    #####: 1723:  case 12:
        -: 1724:#line 297 "grammar.y" /* yacc.c:1646  */
        -: 1725:    {
        -: 1726:        int result = yr_parser_reduce_rule_declaration_phase_2(
        -: 1727:            yyscanner, (yyvsp[-7].rule)); // rule created in phase 1
        -: 1728:
        -: 1729:        yr_free((yyvsp[-8].c_string));
        -: 1730:
        -: 1731:        fail_if_error(result);
        -: 1732:      }
        -: 1733:#line 1734 "grammar.c" /* yacc.c:1646  */
    #####: 1734:    break;
        -: 1735:
    #####: 1736:  case 13:
        -: 1737:#line 310 "grammar.y" /* yacc.c:1646  */
        -: 1738:    {
        -: 1739:        (yyval.meta) = NULL;
        -: 1740:      }
        -: 1741:#line 1742 "grammar.c" /* yacc.c:1646  */
    #####: 1742:    break;
        -: 1743:
    #####: 1744:  case 14:
        -: 1745:#line 314 "grammar.y" /* yacc.c:1646  */
        -: 1746:    {
        -: 1747:        int result;
        -: 1748:
        -: 1749:        // Each rule have a list of meta-data info, consisting in a
        -: 1750:        // sequence of YR_META structures. The last YR_META structure does
        -: 1751:        // not represent a real meta-data, it's just a end-of-list marker
        -: 1752:        // identified by a specific type (META_TYPE_NULL). Here we
        -: 1753:        // write the end-of-list marker.
        -: 1754:
        -: 1755:        YR_META null_meta;
        -: 1756:
        -: 1757:        memset(&null_meta, 0xFF, sizeof(YR_META));
        -: 1758:        null_meta.type = META_TYPE_NULL;
        -: 1759:
        -: 1760:        result = yr_arena_write_data(
        -: 1761:            compiler->metas_arena,
        -: 1762:            &null_meta,
        -: 1763:            sizeof(YR_META),
        -: 1764:            NULL);
        -: 1765:
        -: 1766:        (yyval.meta) = (yyvsp[0].meta);
        -: 1767:
        -: 1768:        fail_if_error(result);
        -: 1769:      }
        -: 1770:#line 1771 "grammar.c" /* yacc.c:1646  */
    #####: 1771:    break;
        -: 1772:
    #####: 1773:  case 15:
        -: 1774:#line 343 "grammar.y" /* yacc.c:1646  */
        -: 1775:    {
        -: 1776:        (yyval.string) = NULL;
        -: 1777:      }
        -: 1778:#line 1779 "grammar.c" /* yacc.c:1646  */
    #####: 1779:    break;
        -: 1780:
    #####: 1781:  case 16:
        -: 1782:#line 347 "grammar.y" /* yacc.c:1646  */
        -: 1783:    {
        -: 1784:        // Each rule have a list of strings, consisting in a sequence
        -: 1785:        // of YR_STRING structures. The last YR_STRING structure does not
        -: 1786:        // represent a real string, it's just a end-of-list marker
        -: 1787:        // identified by a specific flag (STRING_FLAGS_NULL). Here we
        -: 1788:        // write the end-of-list marker.
        -: 1789:
        -: 1790:        YR_STRING null_string;
        -: 1791:
        -: 1792:        memset(&null_string, 0xFF, sizeof(YR_STRING));
        -: 1793:        null_string.g_flags = STRING_GFLAGS_NULL;
        -: 1794:
        -: 1795:        fail_if_error(yr_arena_write_data(
        -: 1796:            compiler->strings_arena,
        -: 1797:            &null_string,
        -: 1798:            sizeof(YR_STRING),
        -: 1799:            NULL));
        -: 1800:
        -: 1801:        (yyval.string) = (yyvsp[0].string);
        -: 1802:      }
        -: 1803:#line 1804 "grammar.c" /* yacc.c:1646  */
    #####: 1804:    break;
        -: 1805:
    #####: 1806:  case 18:
        -: 1807:#line 376 "grammar.y" /* yacc.c:1646  */
        -: 1808:    { (yyval.integer) = 0;  }
        -: 1809:#line 1810 "grammar.c" /* yacc.c:1646  */
    #####: 1810:    break;
        -: 1811:
    #####: 1812:  case 19:
        -: 1813:#line 377 "grammar.y" /* yacc.c:1646  */
        -: 1814:    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
        -: 1815:#line 1816 "grammar.c" /* yacc.c:1646  */
    #####: 1816:    break;
        -: 1817:
    #####: 1818:  case 20:
        -: 1819:#line 382 "grammar.y" /* yacc.c:1646  */
        -: 1820:    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
        -: 1821:#line 1822 "grammar.c" /* yacc.c:1646  */
    #####: 1822:    break;
        -: 1823:
    #####: 1824:  case 21:
        -: 1825:#line 383 "grammar.y" /* yacc.c:1646  */
        -: 1826:    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
        -: 1827:#line 1828 "grammar.c" /* yacc.c:1646  */
    #####: 1828:    break;
        -: 1829:
    #####: 1830:  case 22:
        -: 1831:#line 389 "grammar.y" /* yacc.c:1646  */
        -: 1832:    {
        -: 1833:        (yyval.c_string) = NULL;
        -: 1834:      }
        -: 1835:#line 1836 "grammar.c" /* yacc.c:1646  */
    #####: 1836:    break;
        -: 1837:
    #####: 1838:  case 23:
        -: 1839:#line 393 "grammar.y" /* yacc.c:1646  */
        -: 1840:    {
        -: 1841:        // Tags list is represented in the arena as a sequence
        -: 1842:        // of null-terminated strings, the sequence ends with an
        -: 1843:        // additional null character. Here we write the ending null
        -: 1844:        //character. Example: tag1\0tag2\0tag3\0\0
        -: 1845:
        -: 1846:        int result = yr_arena_write_string(
        -: 1847:            yyget_extra(yyscanner)->sz_arena, "", NULL);
        -: 1848:
        -: 1849:        fail_if_error(result);
        -: 1850:
        -: 1851:        (yyval.c_string) = (yyvsp[0].c_string);
        -: 1852:      }
        -: 1853:#line 1854 "grammar.c" /* yacc.c:1646  */
    #####: 1854:    break;
        -: 1855:
    #####: 1856:  case 24:
        -: 1857:#line 411 "grammar.y" /* yacc.c:1646  */
        -: 1858:    {
        -: 1859:        int result = yr_arena_write_string(
        -: 1860:            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &(yyval.c_string));
        -: 1861:
        -: 1862:        yr_free((yyvsp[0].c_string));
        -: 1863:
        -: 1864:        fail_if_error(result);
        -: 1865:      }
        -: 1866:#line 1867 "grammar.c" /* yacc.c:1646  */
    #####: 1867:    break;
        -: 1868:
    #####: 1869:  case 25:
        -: 1870:#line 420 "grammar.y" /* yacc.c:1646  */
        -: 1871:    {
        -: 1872:        int result = ERROR_SUCCESS;
        -: 1873:
        -: 1874:        char* tag_name = (yyvsp[-1].c_string);
        -: 1875:        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -: 1876:
        -: 1877:        while (tag_length > 0)
        -: 1878:        {
        -: 1879:          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
        -: 1880:          {
        -: 1881:            yr_compiler_set_error_extra_info(compiler, tag_name);
        -: 1882:            result = ERROR_DUPLICATED_TAG_IDENTIFIER;
        -: 1883:            break;
        -: 1884:          }
        -: 1885:
        -: 1886:          tag_name = (char*) yr_arena_next_address(
        -: 1887:              yyget_extra(yyscanner)->sz_arena,
        -: 1888:              tag_name,
        -: 1889:              tag_length + 1);
        -: 1890:
        -: 1891:          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -: 1892:        }
        -: 1893:
        -: 1894:        if (result == ERROR_SUCCESS)
        -: 1895:          result = yr_arena_write_string(
        -: 1896:              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);
        -: 1897:
        -: 1898:        yr_free((yyvsp[0].c_string));
        -: 1899:
        -: 1900:        fail_if_error(result);
        -: 1901:
        -: 1902:        (yyval.c_string) = (yyvsp[-1].c_string);
        -: 1903:      }
        -: 1904:#line 1905 "grammar.c" /* yacc.c:1646  */
    #####: 1905:    break;
        -: 1906:
    #####: 1907:  case 26:
        -: 1908:#line 458 "grammar.y" /* yacc.c:1646  */
        -: 1909:    {  (yyval.meta) = (yyvsp[0].meta); }
        -: 1910:#line 1911 "grammar.c" /* yacc.c:1646  */
    #####: 1911:    break;
        -: 1912:
    #####: 1913:  case 27:
        -: 1914:#line 459 "grammar.y" /* yacc.c:1646  */
        -: 1915:    {  (yyval.meta) = (yyvsp[-1].meta); }
        -: 1916:#line 1917 "grammar.c" /* yacc.c:1646  */
    #####: 1917:    break;
        -: 1918:
    #####: 1919:  case 28:
        -: 1920:#line 465 "grammar.y" /* yacc.c:1646  */
        -: 1921:    {
        -: 1922:        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        -: 1923:
        -: 1924:        int result = yr_parser_reduce_meta_declaration(
        -: 1925:            yyscanner,
        -: 1926:            META_TYPE_STRING,
        -: 1927:            (yyvsp[-2].c_string),
        -: 1928:            sized_string->c_string,
        -: 1929:            0,
        -: 1930:            &(yyval.meta));
        -: 1931:
        -: 1932:        yr_free((yyvsp[-2].c_string));
        -: 1933:        yr_free((yyvsp[0].sized_string));
        -: 1934:
        -: 1935:        fail_if_error(result);
        -: 1936:      }
        -: 1937:#line 1938 "grammar.c" /* yacc.c:1646  */
    #####: 1938:    break;
        -: 1939:
    #####: 1940:  case 29:
        -: 1941:#line 482 "grammar.y" /* yacc.c:1646  */
        -: 1942:    {
        -: 1943:        int result = yr_parser_reduce_meta_declaration(
        -: 1944:            yyscanner,
        -: 1945:            META_TYPE_INTEGER,
        -: 1946:            (yyvsp[-2].c_string),
        -: 1947:            NULL,
        -: 1948:            (yyvsp[0].integer),
        -: 1949:            &(yyval.meta));
        -: 1950:
        -: 1951:        yr_free((yyvsp[-2].c_string));
        -: 1952:
        -: 1953:        fail_if_error(result);
        -: 1954:      }
        -: 1955:#line 1956 "grammar.c" /* yacc.c:1646  */
    #####: 1956:    break;
        -: 1957:
    #####: 1958:  case 30:
        -: 1959:#line 496 "grammar.y" /* yacc.c:1646  */
        -: 1960:    {
        -: 1961:        int result = yr_parser_reduce_meta_declaration(
        -: 1962:            yyscanner,
        -: 1963:            META_TYPE_INTEGER,
        -: 1964:            (yyvsp[-3].c_string),
        -: 1965:            NULL,
        -: 1966:            -(yyvsp[0].integer),
        -: 1967:            &(yyval.meta));
        -: 1968:
        -: 1969:        yr_free((yyvsp[-3].c_string));
        -: 1970:
        -: 1971:        fail_if_error(result);
        -: 1972:      }
        -: 1973:#line 1974 "grammar.c" /* yacc.c:1646  */
    #####: 1974:    break;
        -: 1975:
    #####: 1976:  case 31:
        -: 1977:#line 510 "grammar.y" /* yacc.c:1646  */
        -: 1978:    {
        -: 1979:        int result = yr_parser_reduce_meta_declaration(
        -: 1980:            yyscanner,
        -: 1981:            META_TYPE_BOOLEAN,
        -: 1982:            (yyvsp[-2].c_string),
        -: 1983:            NULL,
        -: 1984:            true,
        -: 1985:            &(yyval.meta));
        -: 1986:
        -: 1987:        yr_free((yyvsp[-2].c_string));
        -: 1988:
        -: 1989:        fail_if_error(result);
        -: 1990:      }
        -: 1991:#line 1992 "grammar.c" /* yacc.c:1646  */
    #####: 1992:    break;
        -: 1993:
    #####: 1994:  case 32:
        -: 1995:#line 524 "grammar.y" /* yacc.c:1646  */
        -: 1996:    {
        -: 1997:        int result = yr_parser_reduce_meta_declaration(
        -: 1998:            yyscanner,
        -: 1999:            META_TYPE_BOOLEAN,
        -: 2000:            (yyvsp[-2].c_string),
        -: 2001:            NULL,
        -: 2002:            false,
        -: 2003:            &(yyval.meta));
        -: 2004:
        -: 2005:        yr_free((yyvsp[-2].c_string));
        -: 2006:
        -: 2007:        fail_if_error(result);
        -: 2008:      }
        -: 2009:#line 2010 "grammar.c" /* yacc.c:1646  */
    #####: 2010:    break;
        -: 2011:
    #####: 2012:  case 33:
        -: 2013:#line 541 "grammar.y" /* yacc.c:1646  */
        -: 2014:    { (yyval.string) = (yyvsp[0].string); }
        -: 2015:#line 2016 "grammar.c" /* yacc.c:1646  */
    #####: 2016:    break;
        -: 2017:
    #####: 2018:  case 34:
        -: 2019:#line 542 "grammar.y" /* yacc.c:1646  */
        -: 2020:    { (yyval.string) = (yyvsp[-1].string); }
        -: 2021:#line 2022 "grammar.c" /* yacc.c:1646  */
    #####: 2022:    break;
        -: 2023:
    #####: 2024:  case 35:
        -: 2025:#line 548 "grammar.y" /* yacc.c:1646  */
        -: 2026:    {
        -: 2027:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2028:      }
        -: 2029:#line 2030 "grammar.c" /* yacc.c:1646  */
    #####: 2030:    break;
        -: 2031:
    #####: 2032:  case 36:
        -: 2033:#line 552 "grammar.y" /* yacc.c:1646  */
        -: 2034:    {
        -: 2035:        int result = yr_parser_reduce_string_declaration(
        -: 2036:            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2037:
        -: 2038:        yr_free((yyvsp[-4].c_string));
        -: 2039:        yr_free((yyvsp[-1].sized_string));
        -: 2040:
        -: 2041:        fail_if_error(result);
        -: 2042:        compiler->current_line = 0;
        -: 2043:      }
        -: 2044:#line 2045 "grammar.c" /* yacc.c:1646  */
    #####: 2045:    break;
        -: 2046:
    #####: 2047:  case 37:
        -: 2048:#line 563 "grammar.y" /* yacc.c:1646  */
        -: 2049:    {
        -: 2050:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2051:      }
        -: 2052:#line 2053 "grammar.c" /* yacc.c:1646  */
    #####: 2053:    break;
        -: 2054:
    #####: 2055:  case 38:
        -: 2056:#line 567 "grammar.y" /* yacc.c:1646  */
        -: 2057:    {
        -: 2058:        int result = yr_parser_reduce_string_declaration(
        -: 2059:            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2060:
        -: 2061:        yr_free((yyvsp[-4].c_string));
        -: 2062:        yr_free((yyvsp[-1].sized_string));
        -: 2063:
        -: 2064:        fail_if_error(result);
        -: 2065:
        -: 2066:        compiler->current_line = 0;
        -: 2067:      }
        -: 2068:#line 2069 "grammar.c" /* yacc.c:1646  */
    #####: 2069:    break;
        -: 2070:
    #####: 2071:  case 39:
        -: 2072:#line 579 "grammar.y" /* yacc.c:1646  */
        -: 2073:    {
        -: 2074:        int result = yr_parser_reduce_string_declaration(
        -: 2075:            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string), &(yyval.string));
        -: 2076:
        -: 2077:        yr_free((yyvsp[-2].c_string));
        -: 2078:        yr_free((yyvsp[0].sized_string));
        -: 2079:
        -: 2080:        fail_if_error(result);
        -: 2081:      }
        -: 2082:#line 2083 "grammar.c" /* yacc.c:1646  */
    #####: 2083:    break;
        -: 2084:
    #####: 2085:  case 40:
        -: 2086:#line 592 "grammar.y" /* yacc.c:1646  */
        -: 2087:    { (yyval.integer) = 0; }
        -: 2088:#line 2089 "grammar.c" /* yacc.c:1646  */
    #####: 2089:    break;
        -: 2090:
    #####: 2091:  case 41:
        -: 2092:#line 593 "grammar.y" /* yacc.c:1646  */
        -: 2093:    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
        -: 2094:#line 2095 "grammar.c" /* yacc.c:1646  */
    #####: 2095:    break;
        -: 2096:
    #####: 2097:  case 42:
        -: 2098:#line 598 "grammar.y" /* yacc.c:1646  */
        -: 2099:    { (yyval.integer) = STRING_GFLAGS_WIDE; }
        -: 2100:#line 2101 "grammar.c" /* yacc.c:1646  */
    #####: 2101:    break;
        -: 2102:
    #####: 2103:  case 43:
        -: 2104:#line 599 "grammar.y" /* yacc.c:1646  */
        -: 2105:    { (yyval.integer) = STRING_GFLAGS_ASCII; }
        -: 2106:#line 2107 "grammar.c" /* yacc.c:1646  */
    #####: 2107:    break;
        -: 2108:
    #####: 2109:  case 44:
        -: 2110:#line 600 "grammar.y" /* yacc.c:1646  */
        -: 2111:    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
        -: 2112:#line 2113 "grammar.c" /* yacc.c:1646  */
    #####: 2113:    break;
        -: 2114:
    #####: 2115:  case 45:
        -: 2116:#line 601 "grammar.y" /* yacc.c:1646  */
        -: 2117:    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
        -: 2118:#line 2119 "grammar.c" /* yacc.c:1646  */
    #####: 2119:    break;
        -: 2120:
    #####: 2121:  case 46:
        -: 2122:#line 602 "grammar.y" /* yacc.c:1646  */
        -: 2123:    { (yyval.integer) = STRING_GFLAGS_XOR; }
        -: 2124:#line 2125 "grammar.c" /* yacc.c:1646  */
    #####: 2125:    break;
        -: 2126:
    #####: 2127:  case 47:
        -: 2128:#line 608 "grammar.y" /* yacc.c:1646  */
        -: 2129:    {
        -: 2130:        int result = ERROR_SUCCESS;
        -: 2131:        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));
        -: 2132:
        -: 2133:        if (var_index >= 0)
        -: 2134:        {
        -: 2135:          result = yr_parser_emit_with_arg(
        -: 2136:              yyscanner,
        -: 2137:              OP_PUSH_M,
        -: 2138:              LOOP_LOCAL_VARS * var_index,
        -: 2139:              NULL,
        -: 2140:              NULL);
        -: 2141:
        -: 2142:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 2143:          (yyval.expression).value.integer = UNDEFINED;
        -: 2144:          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        -: 2145:        }
        -: 2146:        else
        -: 2147:        {
        -: 2148:          // Search for identifier within the global namespace, where the
        -: 2149:          // externals variables reside.
        -: 2150:
        -: 2151:          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
        -: 2152:              compiler->objects_table, (yyvsp[0].c_string), NULL);
        -: 2153:
        -: 2154:          if (object == NULL)
        -: 2155:          {
        -: 2156:            // If not found, search within the current namespace.
        -: 2157:            char* ns = compiler->current_namespace->name;
        -: 2158:
        -: 2159:            object = (YR_OBJECT*) yr_hash_table_lookup(
        -: 2160:                compiler->objects_table, (yyvsp[0].c_string), ns);
        -: 2161:          }
        -: 2162:
        -: 2163:          if (object != NULL)
        -: 2164:          {
        -: 2165:            char* id;
        -: 2166:
        -: 2167:            result = yr_arena_write_string(
        -: 2168:                compiler->sz_arena, (yyvsp[0].c_string), &id);
        -: 2169:
        -: 2170:            if (result == ERROR_SUCCESS)
        -: 2171:              result = yr_parser_emit_with_arg_reloc(
        -: 2172:                  yyscanner,
        -: 2173:                  OP_OBJ_LOAD,
        -: 2174:                  id,
        -: 2175:                  NULL,
        -: 2176:                  NULL);
        -: 2177:
        -: 2178:            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2179:            (yyval.expression).value.object = object;
        -: 2180:            (yyval.expression).identifier = object->identifier;
        -: 2181:          }
        -: 2182:          else
        -: 2183:          {
        -: 2184:            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
        -: 2185:                compiler->rules_table,
        -: 2186:                (yyvsp[0].c_string),
        -: 2187:                compiler->current_namespace->name);
        -: 2188:
        -: 2189:            if (rule != NULL)
        -: 2190:            {
        -: 2191:              result = yr_parser_emit_with_arg_reloc(
        -: 2192:                  yyscanner,
        -: 2193:                  OP_PUSH_RULE,
        -: 2194:                  rule,
        -: 2195:                  NULL,
        -: 2196:                  NULL);
        -: 2197:
        -: 2198:              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2199:              (yyval.expression).value.integer = UNDEFINED;
        -: 2200:              (yyval.expression).identifier = rule->identifier;
        -: 2201:            }
        -: 2202:            else
        -: 2203:            {
        -: 2204:              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 2205:              result = ERROR_UNDEFINED_IDENTIFIER;
        -: 2206:            }
        -: 2207:          }
        -: 2208:        }
        -: 2209:
        -: 2210:        yr_free((yyvsp[0].c_string));
        -: 2211:
        -: 2212:        fail_if_error(result);
        -: 2213:      }
        -: 2214:#line 2215 "grammar.c" /* yacc.c:1646  */
    #####: 2215:    break;
        -: 2216:
    #####: 2217:  case 48:
        -: 2218:#line 694 "grammar.y" /* yacc.c:1646  */
        -: 2219:    {
        -: 2220:        int result = ERROR_SUCCESS;
        -: 2221:        YR_OBJECT* field = NULL;
        -: 2222:
        -: 2223:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2224:            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        -: 2225:        {
        -: 2226:          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));
        -: 2227:
        -: 2228:          if (field != NULL)
        -: 2229:          {
        -: 2230:            char* ident;
        -: 2231:
        -: 2232:            result = yr_arena_write_string(
        -: 2233:                compiler->sz_arena, (yyvsp[0].c_string), &ident);
        -: 2234:
        -: 2235:            if (result == ERROR_SUCCESS)
        -: 2236:              result = yr_parser_emit_with_arg_reloc(
        -: 2237:                  yyscanner,
        -: 2238:                  OP_OBJ_FIELD,
        -: 2239:                  ident,
        -: 2240:                  NULL,
        -: 2241:                  NULL);
        -: 2242:
        -: 2243:            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2244:            (yyval.expression).value.object = field;
        -: 2245:            (yyval.expression).identifier = field->identifier;
        -: 2246:          }
        -: 2247:          else
        -: 2248:          {
        -: 2249:            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 2250:            result = ERROR_INVALID_FIELD_NAME;
        -: 2251:          }
        -: 2252:        }
        -: 2253:        else
        -: 2254:        {
        -: 2255:          yr_compiler_set_error_extra_info(
        -: 2256:              compiler, (yyvsp[-2].expression).identifier);
        -: 2257:
        -: 2258:          result = ERROR_NOT_A_STRUCTURE;
        -: 2259:        }
        -: 2260:
        -: 2261:        yr_free((yyvsp[0].c_string));
        -: 2262:
        -: 2263:        fail_if_error(result);
        -: 2264:      }
        -: 2265:#line 2266 "grammar.c" /* yacc.c:1646  */
    #####: 2266:    break;
        -: 2267:
    #####: 2268:  case 49:
        -: 2269:#line 741 "grammar.y" /* yacc.c:1646  */
        -: 2270:    {
        -: 2271:        int result = ERROR_SUCCESS;
        -: 2272:        YR_OBJECT_ARRAY* array;
        -: 2273:        YR_OBJECT_DICTIONARY* dict;
        -: 2274:
        -: 2275:        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2276:            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        -: 2277:        {
        -: 2278:          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 2279:          {
        -: 2280:            yr_compiler_set_error_extra_info(
        -: 2281:                compiler, "array indexes must be of integer type");
        -: 2282:            result = ERROR_WRONG_TYPE;
        -: 2283:          }
        -: 2284:
        -: 2285:          fail_if_error(result);
        -: 2286:
        -: 2287:          result = yr_parser_emit(
        -: 2288:              yyscanner, OP_INDEX_ARRAY, NULL);
        -: 2289:
        -: 2290:          array = object_as_array((yyvsp[-3].expression).value.object);
        -: 2291:
        -: 2292:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2293:          (yyval.expression).value.object = array->prototype_item;
        -: 2294:          (yyval.expression).identifier = array->identifier;
        -: 2295:        }
        -: 2296:        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2297:                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        -: 2298:        {
        -: 2299:          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
        -: 2300:          {
        -: 2301:            yr_compiler_set_error_extra_info(
        -: 2302:                compiler, "dictionary keys must be of string type");
        -: 2303:            result = ERROR_WRONG_TYPE;
        -: 2304:          }
        -: 2305:
        -: 2306:          fail_if_error(result);
        -: 2307:
        -: 2308:          result = yr_parser_emit(
        -: 2309:              yyscanner, OP_LOOKUP_DICT, NULL);
        -: 2310:
        -: 2311:          dict = object_as_dictionary((yyvsp[-3].expression).value.object);
        -: 2312:
        -: 2313:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2314:          (yyval.expression).value.object = dict->prototype_item;
        -: 2315:          (yyval.expression).identifier = dict->identifier;
        -: 2316:        }
        -: 2317:        else
        -: 2318:        {
        -: 2319:          yr_compiler_set_error_extra_info(
        -: 2320:              compiler, (yyvsp[-3].expression).identifier);
        -: 2321:
        -: 2322:          result = ERROR_NOT_INDEXABLE;
        -: 2323:        }
        -: 2324:
        -: 2325:        fail_if_error(result);
        -: 2326:      }
        -: 2327:#line 2328 "grammar.c" /* yacc.c:1646  */
    #####: 2328:    break;
        -: 2329:
    #####: 2330:  case 50:
        -: 2331:#line 800 "grammar.y" /* yacc.c:1646  */
        -: 2332:    {
        -: 2333:        int result = ERROR_SUCCESS;
        -: 2334:        YR_OBJECT_FUNCTION* function;
        -: 2335:        char* args_fmt;
        -: 2336:
        -: 2337:        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2338:            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        -: 2339:        {
        -: 2340:          result = yr_parser_check_types(
        -: 2341:              compiler, object_as_function((yyvsp[-3].expression).value.object), (yyvsp[-1].c_string));
        -: 2342:
        -: 2343:          if (result == ERROR_SUCCESS)
        -: 2344:            result = yr_arena_write_string(
        -: 2345:                compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);
        -: 2346:
        -: 2347:          if (result == ERROR_SUCCESS)
        -: 2348:            result = yr_parser_emit_with_arg_reloc(
        -: 2349:                yyscanner,
        -: 2350:                OP_CALL,
        -: 2351:                args_fmt,
        -: 2352:                NULL,
        -: 2353:                NULL);
        -: 2354:
        -: 2355:          function = object_as_function((yyvsp[-3].expression).value.object);
        -: 2356:
        -: 2357:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2358:          (yyval.expression).value.object = function->return_obj;
        -: 2359:          (yyval.expression).identifier = function->identifier;
        -: 2360:        }
        -: 2361:        else
        -: 2362:        {
        -: 2363:          yr_compiler_set_error_extra_info(
        -: 2364:              compiler, (yyvsp[-3].expression).identifier);
        -: 2365:
        -: 2366:          result = ERROR_NOT_A_FUNCTION;
        -: 2367:        }
        -: 2368:
        -: 2369:        yr_free((yyvsp[-1].c_string));
        -: 2370:
        -: 2371:        fail_if_error(result);
        -: 2372:      }
        -: 2373:#line 2374 "grammar.c" /* yacc.c:1646  */
    #####: 2374:    break;
        -: 2375:
    #####: 2376:  case 51:
        -: 2377:#line 845 "grammar.y" /* yacc.c:1646  */
        -: 2378:    { (yyval.c_string) = yr_strdup(""); }
        -: 2379:#line 2380 "grammar.c" /* yacc.c:1646  */
    #####: 2380:    break;
        -: 2381:
    #####: 2382:  case 52:
        -: 2383:#line 846 "grammar.y" /* yacc.c:1646  */
        -: 2384:    { (yyval.c_string) = (yyvsp[0].c_string); }
        -: 2385:#line 2386 "grammar.c" /* yacc.c:1646  */
    #####: 2386:    break;
        -: 2387:
    #####: 2388:  case 53:
        -: 2389:#line 851 "grammar.y" /* yacc.c:1646  */
        -: 2390:    {
        -: 2391:        (yyval.c_string) = (char*) yr_malloc(YR_MAX_FUNCTION_ARGS + 1);
        -: 2392:
        -: 2393:        if ((yyval.c_string) == NULL)
        -: 2394:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 2395:
        -: 2396:        switch((yyvsp[0].expression).type)
        -: 2397:        {
        -: 2398:          case EXPRESSION_TYPE_INTEGER:
        -: 2399:            strlcpy((yyval.c_string), "i", YR_MAX_FUNCTION_ARGS);
        -: 2400:            break;
        -: 2401:          case EXPRESSION_TYPE_FLOAT:
        -: 2402:            strlcpy((yyval.c_string), "f", YR_MAX_FUNCTION_ARGS);
        -: 2403:            break;
        -: 2404:          case EXPRESSION_TYPE_BOOLEAN:
        -: 2405:            strlcpy((yyval.c_string), "b", YR_MAX_FUNCTION_ARGS);
        -: 2406:            break;
        -: 2407:          case EXPRESSION_TYPE_STRING:
        -: 2408:            strlcpy((yyval.c_string), "s", YR_MAX_FUNCTION_ARGS);
        -: 2409:            break;
        -: 2410:          case EXPRESSION_TYPE_REGEXP:
        -: 2411:            strlcpy((yyval.c_string), "r", YR_MAX_FUNCTION_ARGS);
        -: 2412:            break;
        -: 2413:          default:
        -: 2414:            assert(false);
        -: 2415:        }
        -: 2416:      }
        -: 2417:#line 2418 "grammar.c" /* yacc.c:1646  */
    #####: 2418:    break;
        -: 2419:
    #####: 2420:  case 54:
        -: 2421:#line 879 "grammar.y" /* yacc.c:1646  */
        -: 2422:    {
        -: 2423:        int result = ERROR_SUCCESS;
        -: 2424:
        -: 2425:        if (strlen((yyvsp[-2].c_string)) == YR_MAX_FUNCTION_ARGS)
        -: 2426:        {
        -: 2427:          result = ERROR_TOO_MANY_ARGUMENTS;
        -: 2428:        }
        -: 2429:        else
        -: 2430:        {
        -: 2431:          switch((yyvsp[0].expression).type)
        -: 2432:          {
        -: 2433:            case EXPRESSION_TYPE_INTEGER:
        -: 2434:              strlcat((yyvsp[-2].c_string), "i", YR_MAX_FUNCTION_ARGS);
        -: 2435:              break;
        -: 2436:            case EXPRESSION_TYPE_FLOAT:
        -: 2437:              strlcat((yyvsp[-2].c_string), "f", YR_MAX_FUNCTION_ARGS);
        -: 2438:              break;
        -: 2439:            case EXPRESSION_TYPE_BOOLEAN:
        -: 2440:              strlcat((yyvsp[-2].c_string), "b", YR_MAX_FUNCTION_ARGS);
        -: 2441:              break;
        -: 2442:            case EXPRESSION_TYPE_STRING:
        -: 2443:              strlcat((yyvsp[-2].c_string), "s", YR_MAX_FUNCTION_ARGS);
        -: 2444:              break;
        -: 2445:            case EXPRESSION_TYPE_REGEXP:
        -: 2446:              strlcat((yyvsp[-2].c_string), "r", YR_MAX_FUNCTION_ARGS);
        -: 2447:              break;
        -: 2448:            default:
        -: 2449:              assert(false);
        -: 2450:          }
        -: 2451:        }
        -: 2452:
        -: 2453:        fail_if_error(result);
        -: 2454:
        -: 2455:        (yyval.c_string) = (yyvsp[-2].c_string);
        -: 2456:      }
        -: 2457:#line 2458 "grammar.c" /* yacc.c:1646  */
    #####: 2458:    break;
        -: 2459:
    #####: 2460:  case 55:
        -: 2461:#line 919 "grammar.y" /* yacc.c:1646  */
        -: 2462:    {
        -: 2463:        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        -: 2464:        RE* re;
        -: 2465:        RE_ERROR error;
        -: 2466:
        -: 2467:        int result = ERROR_SUCCESS;
        -: 2468:        int re_flags = 0;
        -: 2469:
        -: 2470:        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
        -: 2471:          re_flags |= RE_FLAGS_NO_CASE;
        -: 2472:
        -: 2473:        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
        -: 2474:          re_flags |= RE_FLAGS_DOT_ALL;
        -: 2475:
        -: 2476:        result = yr_re_compile(
        -: 2477:            sized_string->c_string,
        -: 2478:            re_flags,
        -: 2479:            compiler->re_code_arena,
        -: 2480:            &re,
        -: 2481:            &error);
        -: 2482:
        -: 2483:        yr_free((yyvsp[0].sized_string));
        -: 2484:
        -: 2485:        if (result == ERROR_INVALID_REGULAR_EXPRESSION)
        -: 2486:          yr_compiler_set_error_extra_info(compiler, error.message);
        -: 2487:
        -: 2488:        if (result == ERROR_SUCCESS)
        -: 2489:          result = yr_parser_emit_with_arg_reloc(
        -: 2490:              yyscanner,
        -: 2491:              OP_PUSH,
        -: 2492:              re,
        -: 2493:              NULL,
        -: 2494:              NULL);
        -: 2495:
        -: 2496:        fail_if_error(result);
        -: 2497:
        -: 2498:        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
        -: 2499:      }
        -: 2500:#line 2501 "grammar.c" /* yacc.c:1646  */
    #####: 2501:    break;
        -: 2502:
    #####: 2503:  case 56:
        -: 2504:#line 962 "grammar.y" /* yacc.c:1646  */
        -: 2505:    {
        -: 2506:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        -: 2507:        {
        -: 2508:          if ((yyvsp[0].expression).value.sized_string != NULL)
        -: 2509:          {
        -: 2510:            yywarning(yyscanner,
        -: 2511:              "Using literal string \"%s\" in a boolean operation.",
        -: 2512:              (yyvsp[0].expression).value.sized_string->c_string);
        -: 2513:          }
        -: 2514:
        -: 2515:          fail_if_error(yr_parser_emit(
        -: 2516:              yyscanner, OP_STR_TO_BOOL, NULL));
        -: 2517:        }
        -: 2518:
        -: 2519:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2520:      }
        -: 2521:#line 2522 "grammar.c" /* yacc.c:1646  */
    #####: 2522:    break;
        -: 2523:
    #####: 2524:  case 57:
        -: 2525:#line 982 "grammar.y" /* yacc.c:1646  */
        -: 2526:    {
        -: 2527:        fail_if_error(yr_parser_emit_with_arg(
        -: 2528:            yyscanner, OP_PUSH, 1, NULL, NULL));
        -: 2529:
        -: 2530:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2531:      }
        -: 2532:#line 2533 "grammar.c" /* yacc.c:1646  */
    #####: 2533:    break;
        -: 2534:
    #####: 2535:  case 58:
        -: 2536:#line 989 "grammar.y" /* yacc.c:1646  */
        -: 2537:    {
        -: 2538:        fail_if_error(yr_parser_emit_with_arg(
        -: 2539:            yyscanner, OP_PUSH, 0, NULL, NULL));
        -: 2540:
        -: 2541:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2542:      }
        -: 2543:#line 2544 "grammar.c" /* yacc.c:1646  */
    #####: 2544:    break;
        -: 2545:
    #####: 2546:  case 59:
        -: 2547:#line 996 "grammar.y" /* yacc.c:1646  */
        -: 2548:    {
        -: 2549:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, "matches");
        -: 2550:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, "matches");
        -: 2551:
        -: 2552:        fail_if_error(yr_parser_emit(
        -: 2553:            yyscanner,
        -: 2554:            OP_MATCHES,
        -: 2555:            NULL));
        -: 2556:
        -: 2557:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2558:      }
        -: 2559:#line 2560 "grammar.c" /* yacc.c:1646  */
    #####: 2560:    break;
        -: 2561:
    #####: 2562:  case 60:
        -: 2563:#line 1008 "grammar.y" /* yacc.c:1646  */
        -: 2564:    {
        -: 2565:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, "contains");
        -: 2566:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_STRING, "contains");
        -: 2567:
        -: 2568:        fail_if_error(yr_parser_emit(
        -: 2569:            yyscanner, OP_CONTAINS, NULL));
        -: 2570:
        -: 2571:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2572:      }
        -: 2573:#line 2574 "grammar.c" /* yacc.c:1646  */
    #####: 2574:    break;
        -: 2575:
    #####: 2576:  case 61:
        -: 2577:#line 1018 "grammar.y" /* yacc.c:1646  */
        -: 2578:    {
        -: 2579:        int result = yr_parser_reduce_string_identifier(
        -: 2580:            yyscanner,
        -: 2581:            (yyvsp[0].c_string),
        -: 2582:            OP_FOUND,
        -: 2583:            UNDEFINED);
        -: 2584:
        -: 2585:        yr_free((yyvsp[0].c_string));
        -: 2586:
        -: 2587:        fail_if_error(result);
        -: 2588:
        -: 2589:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2590:      }
        -: 2591:#line 2592 "grammar.c" /* yacc.c:1646  */
    #####: 2592:    break;
        -: 2593:
    #####: 2594:  case 62:
        -: 2595:#line 1032 "grammar.y" /* yacc.c:1646  */
        -: 2596:    {
        -: 2597:        int result;
        -: 2598:
        -: 2599:        check_type_with_cleanup((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "at", yr_free((yyvsp[-2].c_string)));
        -: 2600:
        -: 2601:        result = yr_parser_reduce_string_identifier(
        -: 2602:            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);
        -: 2603:
        -: 2604:        yr_free((yyvsp[-2].c_string));
        -: 2605:
        -: 2606:        fail_if_error(result);
        -: 2607:
        -: 2608:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2609:      }
        -: 2610:#line 2611 "grammar.c" /* yacc.c:1646  */
    #####: 2611:    break;
        -: 2612:
    #####: 2613:  case 63:
        -: 2614:#line 1047 "grammar.y" /* yacc.c:1646  */
        -: 2615:    {
        -: 2616:        int result = yr_parser_reduce_string_identifier(
        -: 2617:            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);
        -: 2618:
        -: 2619:        yr_free((yyvsp[-2].c_string));
        -: 2620:
        -: 2621:        fail_if_error(result);
        -: 2622:
        -: 2623:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2624:      }
        -: 2625:#line 2626 "grammar.c" /* yacc.c:1646  */
    #####: 2626:    break;
        -: 2627:
    #####: 2628:  case 64:
        -: 2629:#line 1058 "grammar.y" /* yacc.c:1646  */
        -: 2630:    {
        -: 2631:        if (compiler->loop_depth > 0)
        -: 2632:        {
        -: 2633:          compiler->loop_depth--;
        -: 2634:          compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 2635:        }
        -: 2636:
        -: 2637:        YYERROR;
        -: 2638:      }
        -: 2639:#line 2640 "grammar.c" /* yacc.c:1646  */
        -: 2640:    break;
        -: 2641:
    #####: 2642:  case 65:
        -: 2643:#line 1068 "grammar.y" /* yacc.c:1646  */
        -: 2644:    {
        -: 2645:        // for all i in (N..M) : (<expr>)
        -: 2646:        //
        -: 2647:        // 1       PUSH UNDEF  ; "all"
        -: 2648:        // 2       PUSH UNDEF  ; "end of list"
        -: 2649:        // 3       PUSH N      ; integer range lower bound
        -: 2650:        // 4       PUSH M      ; integer range upper bound
        -: 2651:        // 7       CLEAR_M 1   ; clear <expr> result accumulator
        -: 2652:        // 8       CLEAR_M 2   ; clear loop iteration counter
        -: 2653:        // 5       POP_M 3     ; store range upper bound
        -: 2654:        // 6       POP_M 0     ; store range lower bound
        -: 2655:        // 9    .->INCR_M 2    ; increment loop iteration counter
        -: 2656:        //      |  <expr>      ; here goes the code for <expr>, its result will
        -: 2657:        //      |                be at the top of the stack
        -: 2658:        // 10   |  SET_M 4     ; store boolean expression result in memory 4
        -: 2659:        // 11   |  ADD_M 1     ; add boolean_expression result to accumulator
        -: 2660:        // 12   |  INCR_M 0    ; increment range lower bound (more like current bound)
        -: 2661:        // 13   |  PUSH_M 4    ; boolean expression result
        -: 2662:        // 14 .-+--JFALSE_P    ; jump out of loop if last result is false
        -: 2663:        // 15 | |  PUSH_M 0    ; lower (current) bound
        -: 2664:        // 16 | |  PUSH_M 3    ; upper bound
        -: 2665:        // 17 | `--JLE_P       ; jump to start of loop if we haven't iterated enough
        -: 2666:        // 18 `--->POP         ; pop end of list
        -: 2667:        // 19      SWAPUNDEF 2 ; swap the UNDEF ("all") with loop iteration
        -: 2668:        //                       counter (memory 2)
        -: 2669:        // 20      PUSH_M 1    ; push the boolean_expression accumulator
        -: 2670:        // 21      INT_LE      ; compare boolean_expression accumulator to loop
        -: 2671:        //                       iteration counter
        -: 2672:
        -: 2673:        // for X i in (N..M) : (<expr>)
        -: 2674:        //
        -: 2675:        // 1       PUSH X      ;
        -: 2676:        // 2       SET_M 4     ; store primary_expression in m4
        -: 2677:        // 3       PUSH UNDEF  ; "end of list"
        -: 2678:        // 4       PUSH 0      ; integer range lower bound
        -: 2679:        // 5       PUSH 5      ; integer range upper bound
        -: 2680:        // 8       CLEAR_M 1   ; clear <expr> result accumulator
        -: 2681:        // 9       CLEAR_M 2   ; clear loop iteration counter
        -: 2682:        // 6       POP_M 3     ; store upper bound
        -: 2683:        // 7       POP_M 0     ; store lower bound
        -: 2684:        // 10   .->INCR_M 2    ; increment loop iteration counter
        -: 2685:        // 11   |  <expr>      ; here goes the code for <expr>, its result will
        -: 2686:        //      |              ; be at the  top of the stack
        -: 2687:        // 12   |  ADD_M 1     ; add boolean_expression result to accumulator
        -: 2688:        // 13   |  INCR_M 0    ; increment lower bound (more like current bound)
        -: 2689:        // 14   |  PUSH_M 4    ; primary expression minimum
        -: 2690:        // 15   |  PUSH_M 1    ; boolean_expression accumulator
        -: 2691:        // 16 .-+--JLE_P       ; jump out of loop if (minimum <= accumulator)
        -: 2692:        // 17 | |  PUSH_M 0    ; lower (current) bound
        -: 2693:        // 18 | |  PUSH_M 3    ; upper bound
        -: 2694:        // 19 | `--JLE_P       ; jump to start of loop if we haven't iterated enough
        -: 2695:        // 20 `--->POP         ; pop end of list
        -: 2696:        // 21      SWAPUNDEF 2 ; at this point only our "any" is on the stack,
        -: 2697:        //                       this is effectively a NOP
        -: 2698:        // 22      PUSH_M 1    ; push the boolean_expression accumulator
        -: 2699:        // 23      INT_LE      ; compare boolean_expression accumulator to X
        -: 2700:
        -: 2701:        // for X i in (A, B, C) : (<expr>)
        -: 2702:        //
        -: 2703:        // 1       PUSH X      ;
        -: 2704:        // 2       SET_M 4     ; store primary_expression in m4
        -: 2705:        // 3       PUSH UNDEF  ; "end of list"
        -: 2706:        // 4       PUSH A
        -: 2707:        // 5       PUSH B
        -: 2708:        // 6       PUSH C
        -: 2709:        // 7       CLEAR_M 1   ; clear <expr> result accumulator
        -: 2710:        // 8       CLEAR_M 2   ; clear loop iteration counter
        -: 2711:        // 9    .->INCR_M 2    ; increment loop iteration counter
        -: 2712:        // 10   |  POP_M 0     ; store current item in M[0]
        -: 2713:        // 11   |  <expr>      ; here goes the code for <expr>, its result will
        -: 2714:        //      |              ; be at the  top of the stack
        -: 2715:        // 12   |  ADD_M 1     ; add boolean_expression result to accumulator
        -: 2716:        // 13   `--JNUNDEF     ; if "end of list" was not reached, repeat.
        -: 2717:        // 14      POP         ; pop end of list
        -: 2718:        // 15      SWAPUNDEF 2 ; swap the UNDEF with loop iteration counter M[2]
        -: 2719:        // 16      PUSH_M 1    ; push boolean_expression result accumulator
        -: 2720:        // 17      INT_LE      ; compare boolean_expression accumulator to X
        -: 2721:
        -: 2722:
        -: 2723:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2724:        int result = ERROR_SUCCESS;
        -: 2725:        int var_index;
        -: 2726:
        -: 2727:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
        -: 2728:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 2729:
        -: 2730:        fail_if_error(result);
        -: 2731:
        -: 2732:        var_index = yr_parser_lookup_loop_variable(
        -: 2733:            yyscanner, (yyvsp[-1].c_string));
        -: 2734:
        -: 2735:        if (var_index >= 0)
        -: 2736:        {
        -: 2737:          yr_compiler_set_error_extra_info(
        -: 2738:              compiler, (yyvsp[-1].c_string));
        -: 2739:
        -: 2740:          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;
        -: 2741:        }
        -: 2742:
        -: 2743:        fail_if_error(result);
        -: 2744:
        -: 2745:        // "any" loops require us to store the primary expression for
        -: 2746:        // later evaluation, but "all" loops do not. The OP_SWAPUNDEF after the
        -: 2747:        // loop ensures we evaluate the proper values.
        -: 2748:        if ((yyvsp[-2].integer) == FOR_EXPRESSION_ANY)
        -: 2749:        {
        -: 2750:          yr_parser_emit_with_arg(
        -: 2751:            yyscanner, OP_SET_M, mem_offset + 4, NULL, NULL);
        -: 2752:        }
        -: 2753:
        -: 2754:        // Push end-of-list marker
        -: 2755:        result = yr_parser_emit_with_arg(
        -: 2756:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 2757:
        -: 2758:        fail_if_error(result);
        -: 2759:      }
        -: 2760:#line 2761 "grammar.c" /* yacc.c:1646  */
    #####: 2761:    break;
        -: 2762:
    #####: 2763:  case 66:
        -: 2764:#line 1185 "grammar.y" /* yacc.c:1646  */
        -: 2765:    {
        -: 2766:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2767:        uint8_t* addr;
        -: 2768:
        -: 2769:        // Clear counter for number of expressions evaluating
        -: 2770:        // to true.
        -: 2771:        yr_parser_emit_with_arg(
        -: 2772:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 2773:
        -: 2774:        // Clear iterations counter
        -: 2775:        yr_parser_emit_with_arg(
        -: 2776:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 2777:
        -: 2778:        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        -: 2779:        {
        -: 2780:          // Increment iterations counter
        -: 2781:          yr_parser_emit_with_arg(
        -: 2782:              yyscanner, OP_INCR_M, mem_offset + 2, &addr, NULL);
        -: 2783:
        -: 2784:          // Pop the first integer
        -: 2785:          yr_parser_emit_with_arg(
        -: 2786:              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        -: 2787:        }
        -: 2788:        else // INTEGER_SET_RANGE
        -: 2789:        {
        -: 2790:          // Pop higher bound of set range
        -: 2791:          yr_parser_emit_with_arg(
        -: 2792:              yyscanner, OP_POP_M, mem_offset + 3, NULL, NULL);
        -: 2793:
        -: 2794:          // Pop lower bound of set range
        -: 2795:          yr_parser_emit_with_arg(
        -: 2796:              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        -: 2797:
        -: 2798:          // Increment iterations counter
        -: 2799:          yr_parser_emit_with_arg(
        -: 2800:              yyscanner, OP_INCR_M, mem_offset + 2, &addr, NULL);
        -: 2801:        }
        -: 2802:
        -: 2803:        compiler->loop_address[compiler->loop_depth] = addr;
        -: 2804:        compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
        -: 2805:        compiler->loop_depth++;
        -: 2806:      }
        -: 2807:#line 2808 "grammar.c" /* yacc.c:1646  */
    #####: 2808:    break;
        -: 2809:
    #####: 2810:  case 67:
        -: 2811:#line 1228 "grammar.y" /* yacc.c:1646  */
        -: 2812:    {
        -: 2813:        int mem_offset;
        -: 2814:        YR_FIXUP* fixup;
        -: 2815:        void* jmp_destination_addr;
        -: 2816:        uint8_t* pop_addr;
        -: 2817:
        -: 2818:        compiler->loop_depth--;
        -: 2819:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2820:
        -: 2821:        // The value at the top of the stack is the result of
        -: 2822:        // evaluating the boolean expression, so it could be
        -: 2823:        // 0, 1 or UNDEFINED. Add this value to a counter
        -: 2824:        // keeping the number of expressions evaluating to true.
        -: 2825:        // If the value is UNDEFINED instruction OP_ADD_M
        -: 2826:        // does nothing.
        -: 2827:
        -: 2828:        if ((yyvsp[-9].integer) == FOR_EXPRESSION_ALL)
        -: 2829:        {
        -: 2830:          // Store the last result for checking after we have incremented the
        -: 2831:          // counters. We want to keep the value on the stack though.
        -: 2832:          yr_parser_emit_with_arg(
        -: 2833:              yyscanner, OP_SET_M, mem_offset + 4, NULL, NULL);
        -: 2834:        }
        -: 2835:
        -: 2836:        yr_parser_emit_with_arg(
        -: 2837:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 2838:
        -: 2839:        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        -: 2840:        {
        -: 2841:          yr_parser_emit_with_arg_reloc(
        -: 2842:              yyscanner,
        -: 2843:              OP_JNUNDEF,
        -: 2844:              compiler->loop_address[compiler->loop_depth],
        -: 2845:              NULL,
        -: 2846:              NULL);
        -: 2847:
        -: 2848:          // Pop end-of-list marker.
        -: 2849:          yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 2850:        }
        -: 2851:        else // INTEGER_SET_RANGE
        -: 2852:        {
        -: 2853:          // Increment lower bound of integer set
        -: 2854:          yr_parser_emit_with_arg(
        -: 2855:              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);
        -: 2856:
        -: 2857:          // Push loop quantifier
        -: 2858:          yr_parser_emit_with_arg(
        -: 2859:              yyscanner, OP_PUSH_M, mem_offset + 4, NULL, NULL);
        -: 2860:
        -: 2861:          if ((yyvsp[-9].integer) == FOR_EXPRESSION_ALL)
        -: 2862:          {
        -: 2863:            fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 2864:                yyscanner,
        -: 2865:                OP_JFALSE_P,
        -: 2866:                0, // Don't know the jump destination yet
        -: 2867:                NULL,
        -: 2868:                &jmp_destination_addr));
        -: 2869:
        -: 2870:            // create a fixup entry for the jump and push it in the stack
        -: 2871:            fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 2872:
        -: 2873:            if (fixup == NULL)
        -: 2874:              fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 2875:
        -: 2876:            fixup->address = jmp_destination_addr;
        -: 2877:            fixup->next = compiler->fixup_stack_head;
        -: 2878:            compiler->fixup_stack_head = fixup;
        -: 2879:          }
        -: 2880:          else if ((yyvsp[-9].integer) == FOR_EXPRESSION_ANY)
        -: 2881:          {
        -: 2882:            // Push the number of expressions evaluating to true
        -: 2883:            yr_parser_emit_with_arg(
        -: 2884:                yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 2885:
        -: 2886:            // Compare the loop quantifier to number of expressions that evaluate
        -: 2887:            // to true, in order to eliminate extraneous loop iterations.
        -: 2888:            fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 2889:                yyscanner,
        -: 2890:                OP_JLE_P,
        -: 2891:                0, // Don't know the jump destination yet
        -: 2892:                NULL,
        -: 2893:                &jmp_destination_addr));
        -: 2894:
        -: 2895:            fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 2896:
        -: 2897:            if (fixup == NULL)
        -: 2898:              fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 2899:
        -: 2900:            fixup->address = jmp_destination_addr;
        -: 2901:            fixup->next = compiler->fixup_stack_head;
        -: 2902:            compiler->fixup_stack_head = fixup;
        -: 2903:          }
        -: 2904:
        -: 2905:          // Push lower bound of integer set
        -: 2906:          yr_parser_emit_with_arg(
        -: 2907:              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);
        -: 2908:
        -: 2909:          // Push higher bound of integer set
        -: 2910:          yr_parser_emit_with_arg(
        -: 2911:              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);
        -: 2912:
        -: 2913:          // Compare higher bound with lower bound, do loop again
        -: 2914:          // if lower bound is still lower or equal than higher bound
        -: 2915:          yr_parser_emit_with_arg_reloc(
        -: 2916:              yyscanner,
        -: 2917:              OP_JLE_P,
        -: 2918:              compiler->loop_address[compiler->loop_depth],
        -: 2919:              NULL,
        -: 2920:              NULL);
        -: 2921:
        -: 2922:          // Pop end-of-list marker.
        -: 2923:          yr_parser_emit(yyscanner, OP_POP, &pop_addr);
        -: 2924:
        -: 2925:          fixup = compiler->fixup_stack_head;
        -: 2926:          *(void**)(fixup->address) = (void*)(pop_addr);
        -: 2927:          compiler->fixup_stack_head = fixup->next;
        -: 2928:          yr_free(fixup);
        -: 2929:        }
        -: 2930:
        -: 2931:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 2932:        // is at the top of the stack. Check if the quantifier
        -: 2933:        // is undefined (meaning "all") and replace it with the
        -: 2934:        // iterations counter in that case.
        -: 2935:        yr_parser_emit_with_arg(
        -: 2936:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 2937:
        -: 2938:        // Compare the loop quantifier with the number of
        -: 2939:        // expressions evaluating to true.
        -: 2940:        yr_parser_emit_with_arg(
        -: 2941:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 2942:
        -: 2943:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 2944:
        -: 2945:        compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 2946:        yr_free((yyvsp[-8].c_string));
        -: 2947:
        -: 2948:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2949:      }
        -: 2950:#line 2951 "grammar.c" /* yacc.c:1646  */
    #####: 2951:    break;
        -: 2952:
    #####: 2953:  case 68:
        -: 2954:#line 1367 "grammar.y" /* yacc.c:1646  */
        -: 2955:    {
        -: 2956:        int result = ERROR_SUCCESS;
        -: 2957:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2958:        uint8_t* addr;
        -: 2959:
        -: 2960:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
        -: 2961:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 2962:
        -: 2963:        if (compiler->loop_for_of_mem_offset != -1)
        -: 2964:          result = ERROR_NESTED_FOR_OF_LOOP;
        -: 2965:
        -: 2966:        fail_if_error(result);
        -: 2967:
        -: 2968:        yr_parser_emit_with_arg(
        -: 2969:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 2970:
        -: 2971:        yr_parser_emit_with_arg(
        -: 2972:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 2973:
        -: 2974:        // Pop the first string.
        -: 2975:        yr_parser_emit_with_arg(
        -: 2976:            yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        -: 2977:
        -: 2978:        compiler->loop_for_of_mem_offset = mem_offset;
        -: 2979:        compiler->loop_address[compiler->loop_depth] = addr;
        -: 2980:        compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 2981:        compiler->loop_depth++;
        -: 2982:      }
        -: 2983:#line 2984 "grammar.c" /* yacc.c:1646  */
    #####: 2984:    break;
        -: 2985:
    #####: 2986:  case 69:
        -: 2987:#line 1396 "grammar.y" /* yacc.c:1646  */
        -: 2988:    {
        -: 2989:        int mem_offset;
        -: 2990:
        -: 2991:        compiler->loop_depth--;
        -: 2992:        compiler->loop_for_of_mem_offset = -1;
        -: 2993:
        -: 2994:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2995:
        -: 2996:        // Increment counter by the value returned by the
        -: 2997:        // boolean expression (0 or 1). If the boolean expression
        -: 2998:        // returned UNDEFINED the OP_ADD_M won't do anything.
        -: 2999:
        -: 3000:        yr_parser_emit_with_arg(
        -: 3001:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 3002:
        -: 3003:        // Increment iterations counter.
        -: 3004:        yr_parser_emit_with_arg(
        -: 3005:            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
        -: 3006:
        -: 3007:        // If next string is not undefined, go back to the
        -: 3008:        // beginning of the loop.
        -: 3009:        yr_parser_emit_with_arg_reloc(
        -: 3010:            yyscanner,
        -: 3011:            OP_JNUNDEF,
        -: 3012:            compiler->loop_address[compiler->loop_depth],
        -: 3013:            NULL,
        -: 3014:            NULL);
        -: 3015:
        -: 3016:        // Pop end-of-list marker.
        -: 3017:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 3018:
        -: 3019:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 3020:        // is at top of the stack. Check if the quantifier is
        -: 3021:        // undefined (meaning "all") and replace it with the
        -: 3022:        // iterations counter in that case.
        -: 3023:        yr_parser_emit_with_arg(
        -: 3024:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 3025:
        -: 3026:        // Compare the loop quantifier with the number of
        -: 3027:        // expressions evaluating to true.
        -: 3028:        yr_parser_emit_with_arg(
        -: 3029:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 3030:
        -: 3031:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 3032:
        -: 3033:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3034:
        -: 3035:      }
        -: 3036:#line 3037 "grammar.c" /* yacc.c:1646  */
    #####: 3037:    break;
        -: 3038:
    #####: 3039:  case 70:
        -: 3040:#line 1445 "grammar.y" /* yacc.c:1646  */
        -: 3041:    {
        -: 3042:        yr_parser_emit(yyscanner, OP_OF, NULL);
        -: 3043:
        -: 3044:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3045:      }
        -: 3046:#line 3047 "grammar.c" /* yacc.c:1646  */
    #####: 3047:    break;
        -: 3048:
    #####: 3049:  case 71:
        -: 3050:#line 1451 "grammar.y" /* yacc.c:1646  */
        -: 3051:    {
        -: 3052:        yr_parser_emit(yyscanner, OP_NOT, NULL);
        -: 3053:
        -: 3054:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3055:      }
        -: 3056:#line 3057 "grammar.c" /* yacc.c:1646  */
    #####: 3057:    break;
        -: 3058:
    #####: 3059:  case 72:
        -: 3060:#line 1457 "grammar.y" /* yacc.c:1646  */
        -: 3061:    {
        -: 3062:        YR_FIXUP* fixup;
        -: 3063:        void* jmp_destination_addr;
        -: 3064:
        -: 3065:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 3066:            yyscanner,
        -: 3067:            OP_JFALSE,
        -: 3068:            0,          // still don't know the jump destination
        -: 3069:            NULL,
        -: 3070:            &jmp_destination_addr));
        -: 3071:
        -: 3072:        // create a fixup entry for the jump and push it in the stack
        -: 3073:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 3074:
        -: 3075:        if (fixup == NULL)
        -: 3076:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 3077:
        -: 3078:        fixup->address = jmp_destination_addr;
        -: 3079:        fixup->next = compiler->fixup_stack_head;
        -: 3080:        compiler->fixup_stack_head = fixup;
        -: 3081:      }
        -: 3082:#line 3083 "grammar.c" /* yacc.c:1646  */
    #####: 3083:    break;
        -: 3084:
    #####: 3085:  case 73:
        -: 3086:#line 1479 "grammar.y" /* yacc.c:1646  */
        -: 3087:    {
        -: 3088:        YR_FIXUP* fixup;
        -: 3089:        uint8_t* nop_addr;
        -: 3090:
        -: 3091:        fail_if_error(yr_parser_emit(yyscanner, OP_AND, NULL));
        -: 3092:
        -: 3093:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 3094:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 3095:        // use the address of the OP_AND instruction +1 because we can't be
        -: 3096:        // sure that the instruction following the OP_AND is going to be in
        -: 3097:        // the same arena page. As we don't have a reliable way of getting the
        -: 3098:        // address of the next instruction we generate the OP_NOP.
        -: 3099:
        -: 3100:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 3101:
        -: 3102:        fixup = compiler->fixup_stack_head;
        -: 3103:        *(void**)(fixup->address) = (void*) nop_addr;
        -: 3104:        compiler->fixup_stack_head = fixup->next;
        -: 3105:        yr_free(fixup);
        -: 3106:
        -: 3107:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3108:      }
        -: 3109:#line 3110 "grammar.c" /* yacc.c:1646  */
    #####: 3110:    break;
        -: 3111:
    #####: 3112:  case 74:
        -: 3113:#line 1502 "grammar.y" /* yacc.c:1646  */
        -: 3114:    {
        -: 3115:        YR_FIXUP* fixup;
        -: 3116:        void* jmp_destination_addr;
        -: 3117:
        -: 3118:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 3119:            yyscanner,
        -: 3120:            OP_JTRUE,
        -: 3121:            0,         // still don't know the jump destination
        -: 3122:            NULL,
        -: 3123:            &jmp_destination_addr));
        -: 3124:
        -: 3125:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 3126:
        -: 3127:        if (fixup == NULL)
        -: 3128:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 3129:
        -: 3130:        fixup->address = jmp_destination_addr;
        -: 3131:        fixup->next = compiler->fixup_stack_head;
        -: 3132:        compiler->fixup_stack_head = fixup;
        -: 3133:      }
        -: 3134:#line 3135 "grammar.c" /* yacc.c:1646  */
    #####: 3135:    break;
        -: 3136:
    #####: 3137:  case 75:
        -: 3138:#line 1523 "grammar.y" /* yacc.c:1646  */
        -: 3139:    {
        -: 3140:        YR_FIXUP* fixup;
        -: 3141:        uint8_t* nop_addr;
        -: 3142:
        -: 3143:        fail_if_error(yr_parser_emit(yyscanner, OP_OR, NULL));
        -: 3144:
        -: 3145:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 3146:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 3147:        // use the address of the OP_OR instruction +1 because we can't be
        -: 3148:        // sure that the instruction following the OP_AND is going to be in
        -: 3149:        // the same arena page. As we don't have a reliable way of getting the
        -: 3150:        // address of the next instruction we generate the OP_NOP.
        -: 3151:
        -: 3152:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 3153:
        -: 3154:        fixup = compiler->fixup_stack_head;
        -: 3155:        *(void**)(fixup->address) = (void*)(nop_addr);
        -: 3156:        compiler->fixup_stack_head = fixup->next;
        -: 3157:        yr_free(fixup);
        -: 3158:
        -: 3159:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3160:      }
        -: 3161:#line 3162 "grammar.c" /* yacc.c:1646  */
    #####: 3162:    break;
        -: 3163:
    #####: 3164:  case 76:
        -: 3165:#line 1546 "grammar.y" /* yacc.c:1646  */
        -: 3166:    {
        -: 3167:        fail_if_error(yr_parser_reduce_operation(
        -: 3168:            yyscanner, "<", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3169:
        -: 3170:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3171:      }
        -: 3172:#line 3173 "grammar.c" /* yacc.c:1646  */
    #####: 3173:    break;
        -: 3174:
    #####: 3175:  case 77:
        -: 3176:#line 1553 "grammar.y" /* yacc.c:1646  */
        -: 3177:    {
        -: 3178:        fail_if_error(yr_parser_reduce_operation(
        -: 3179:            yyscanner, ">", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3180:
        -: 3181:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3182:      }
        -: 3183:#line 3184 "grammar.c" /* yacc.c:1646  */
    #####: 3184:    break;
        -: 3185:
    #####: 3186:  case 78:
        -: 3187:#line 1560 "grammar.y" /* yacc.c:1646  */
        -: 3188:    {
        -: 3189:        fail_if_error(yr_parser_reduce_operation(
        -: 3190:            yyscanner, "<=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3191:
        -: 3192:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3193:      }
        -: 3194:#line 3195 "grammar.c" /* yacc.c:1646  */
    #####: 3195:    break;
        -: 3196:
    #####: 3197:  case 79:
        -: 3198:#line 1567 "grammar.y" /* yacc.c:1646  */
        -: 3199:    {
        -: 3200:        fail_if_error(yr_parser_reduce_operation(
        -: 3201:            yyscanner, ">=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3202:
        -: 3203:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3204:      }
        -: 3205:#line 3206 "grammar.c" /* yacc.c:1646  */
    #####: 3206:    break;
        -: 3207:
    #####: 3208:  case 80:
        -: 3209:#line 1574 "grammar.y" /* yacc.c:1646  */
        -: 3210:    {
        -: 3211:        fail_if_error(yr_parser_reduce_operation(
        -: 3212:            yyscanner, "==", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3213:
        -: 3214:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3215:      }
        -: 3216:#line 3217 "grammar.c" /* yacc.c:1646  */
    #####: 3217:    break;
        -: 3218:
    #####: 3219:  case 81:
        -: 3220:#line 1581 "grammar.y" /* yacc.c:1646  */
        -: 3221:    {
        -: 3222:        fail_if_error(yr_parser_reduce_operation(
        -: 3223:            yyscanner, "!=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3224:
        -: 3225:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3226:      }
        -: 3227:#line 3228 "grammar.c" /* yacc.c:1646  */
    #####: 3228:    break;
        -: 3229:
    #####: 3230:  case 82:
        -: 3231:#line 1588 "grammar.y" /* yacc.c:1646  */
        -: 3232:    {
        -: 3233:        (yyval.expression) = (yyvsp[0].expression);
        -: 3234:      }
        -: 3235:#line 3236 "grammar.c" /* yacc.c:1646  */
    #####: 3236:    break;
        -: 3237:
    #####: 3238:  case 83:
        -: 3239:#line 1592 "grammar.y" /* yacc.c:1646  */
        -: 3240:    {
        -: 3241:        (yyval.expression) = (yyvsp[-1].expression);
        -: 3242:      }
        -: 3243:#line 3244 "grammar.c" /* yacc.c:1646  */
    #####: 3244:    break;
        -: 3245:
    #####: 3246:  case 84:
        -: 3247:#line 1599 "grammar.y" /* yacc.c:1646  */
        -: 3248:    { (yyval.integer) = INTEGER_SET_ENUMERATION; }
        -: 3249:#line 3250 "grammar.c" /* yacc.c:1646  */
    #####: 3250:    break;
        -: 3251:
    #####: 3252:  case 85:
        -: 3253:#line 1600 "grammar.y" /* yacc.c:1646  */
        -: 3254:    { (yyval.integer) = INTEGER_SET_RANGE; }
        -: 3255:#line 3256 "grammar.c" /* yacc.c:1646  */
    #####: 3256:    break;
        -: 3257:
    #####: 3258:  case 86:
        -: 3259:#line 1606 "grammar.y" /* yacc.c:1646  */
        -: 3260:    {
        -: 3261:        int result = ERROR_SUCCESS;
        -: 3262:
        -: 3263:        if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3264:        {
        -: 3265:          yr_compiler_set_error_extra_info(
        -: 3266:              compiler, "wrong type for range's lower bound");
        -: 3267:          result = ERROR_WRONG_TYPE;
        -: 3268:        }
        -: 3269:
        -: 3270:        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3271:        {
        -: 3272:          yr_compiler_set_error_extra_info(
        -: 3273:              compiler, "wrong type for range's upper bound");
        -: 3274:          result = ERROR_WRONG_TYPE;
        -: 3275:        }
        -: 3276:
        -: 3277:        fail_if_error(result);
        -: 3278:      }
        -: 3279:#line 3280 "grammar.c" /* yacc.c:1646  */
    #####: 3280:    break;
        -: 3281:
    #####: 3282:  case 87:
        -: 3283:#line 1630 "grammar.y" /* yacc.c:1646  */
        -: 3284:    {
        -: 3285:        int result = ERROR_SUCCESS;
        -: 3286:
        -: 3287:        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3288:        {
        -: 3289:          yr_compiler_set_error_extra_info(
        -: 3290:              compiler, "wrong type for enumeration item");
        -: 3291:          result = ERROR_WRONG_TYPE;
        -: 3292:        }
        -: 3293:
        -: 3294:        fail_if_error(result);
        -: 3295:      }
        -: 3296:#line 3297 "grammar.c" /* yacc.c:1646  */
    #####: 3297:    break;
        -: 3298:
    #####: 3299:  case 88:
        -: 3300:#line 1643 "grammar.y" /* yacc.c:1646  */
        -: 3301:    {
        -: 3302:        int result = ERROR_SUCCESS;
        -: 3303:
        -: 3304:        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3305:        {
        -: 3306:          yr_compiler_set_error_extra_info(
        -: 3307:              compiler, "wrong type for enumeration item");
        -: 3308:          result = ERROR_WRONG_TYPE;
        -: 3309:        }
        -: 3310:
        -: 3311:        fail_if_error(result);
        -: 3312:      }
        -: 3313:#line 3314 "grammar.c" /* yacc.c:1646  */
    #####: 3314:    break;
        -: 3315:
    #####: 3316:  case 89:
        -: 3317:#line 1660 "grammar.y" /* yacc.c:1646  */
        -: 3318:    {
        -: 3319:        // Push end-of-list marker
        -: 3320:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 3321:      }
        -: 3322:#line 3323 "grammar.c" /* yacc.c:1646  */
    #####: 3323:    break;
        -: 3324:
    #####: 3325:  case 91:
        -: 3326:#line 1666 "grammar.y" /* yacc.c:1646  */
        -: 3327:    {
        -: 3328:        fail_if_error(yr_parser_emit_with_arg(
        -: 3329:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL));
        -: 3330:
        -: 3331:        fail_if_error(yr_parser_emit_pushes_for_strings(
        -: 3332:            yyscanner, "$*"));
        -: 3333:      }
        -: 3334:#line 3335 "grammar.c" /* yacc.c:1646  */
    #####: 3335:    break;
        -: 3336:
    #####: 3337:  case 94:
        -: 3338:#line 1684 "grammar.y" /* yacc.c:1646  */
        -: 3339:    {
        -: 3340:        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        -: 3341:        yr_free((yyvsp[0].c_string));
        -: 3342:
        -: 3343:        fail_if_error(result);
        -: 3344:      }
        -: 3345:#line 3346 "grammar.c" /* yacc.c:1646  */
    #####: 3346:    break;
        -: 3347:
    #####: 3348:  case 95:
        -: 3349:#line 1691 "grammar.y" /* yacc.c:1646  */
        -: 3350:    {
        -: 3351:        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        -: 3352:        yr_free((yyvsp[0].c_string));
        -: 3353:
        -: 3354:        fail_if_error(result);
        -: 3355:      }
        -: 3356:#line 3357 "grammar.c" /* yacc.c:1646  */
    #####: 3357:    break;
        -: 3358:
    #####: 3359:  case 96:
        -: 3360:#line 1702 "grammar.y" /* yacc.c:1646  */
        -: 3361:    {
        -: 3362:        (yyval.integer) = FOR_EXPRESSION_ANY;
        -: 3363:      }
        -: 3364:#line 3365 "grammar.c" /* yacc.c:1646  */
    #####: 3365:    break;
        -: 3366:
    #####: 3367:  case 97:
        -: 3368:#line 1706 "grammar.y" /* yacc.c:1646  */
        -: 3369:    {
        -: 3370:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 3371:        (yyval.integer) = FOR_EXPRESSION_ALL;
        -: 3372:      }
        -: 3373:#line 3374 "grammar.c" /* yacc.c:1646  */
    #####: 3374:    break;
        -: 3375:
    #####: 3376:  case 98:
        -: 3377:#line 1711 "grammar.y" /* yacc.c:1646  */
        -: 3378:    {
        -: 3379:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3380:        (yyval.integer) = FOR_EXPRESSION_ANY;
        -: 3381:      }
        -: 3382:#line 3383 "grammar.c" /* yacc.c:1646  */
    #####: 3383:    break;
        -: 3384:
    #####: 3385:  case 99:
        -: 3386:#line 1720 "grammar.y" /* yacc.c:1646  */
        -: 3387:    {
        -: 3388:        (yyval.expression) = (yyvsp[-1].expression);
        -: 3389:      }
        -: 3390:#line 3391 "grammar.c" /* yacc.c:1646  */
    #####: 3391:    break;
        -: 3392:
    #####: 3393:  case 100:
        -: 3394:#line 1724 "grammar.y" /* yacc.c:1646  */
        -: 3395:    {
        -: 3396:        fail_if_error(yr_parser_emit(
        -: 3397:            yyscanner, OP_FILESIZE, NULL));
        -: 3398:
        -: 3399:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3400:        (yyval.expression).value.integer = UNDEFINED;
        -: 3401:      }
        -: 3402:#line 3403 "grammar.c" /* yacc.c:1646  */
    #####: 3403:    break;
        -: 3404:
    #####: 3405:  case 101:
        -: 3406:#line 1732 "grammar.y" /* yacc.c:1646  */
        -: 3407:    {
        -: 3408:        yywarning(yyscanner,
        -: 3409:            "Using deprecated \"entrypoint\" keyword. Use the \"entry_point\" "
        -: 3410:            "function from PE module instead.");
        -: 3411:
        -: 3412:        fail_if_error(yr_parser_emit(
        -: 3413:            yyscanner, OP_ENTRYPOINT, NULL));
        -: 3414:
        -: 3415:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3416:        (yyval.expression).value.integer = UNDEFINED;
        -: 3417:      }
        -: 3418:#line 3419 "grammar.c" /* yacc.c:1646  */
    #####: 3419:    break;
        -: 3420:
    #####: 3421:  case 102:
        -: 3422:#line 1744 "grammar.y" /* yacc.c:1646  */
        -: 3423:    {
        -: 3424:        check_type((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, "intXXXX or uintXXXX");
        -: 3425:
        -: 3426:        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        -: 3427:        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        -: 3428:        // in the proper OP_INTXX opcode.
        -: 3429:
        -: 3430:        fail_if_error(yr_parser_emit(
        -: 3431:            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL));
        -: 3432:
        -: 3433:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3434:        (yyval.expression).value.integer = UNDEFINED;
        -: 3435:      }
        -: 3436:#line 3437 "grammar.c" /* yacc.c:1646  */
    #####: 3437:    break;
        -: 3438:
    #####: 3439:  case 103:
        -: 3440:#line 1758 "grammar.y" /* yacc.c:1646  */
        -: 3441:    {
        -: 3442:        fail_if_error(yr_parser_emit_with_arg(
        -: 3443:            yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL));
        -: 3444:
        -: 3445:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3446:        (yyval.expression).value.integer = (yyvsp[0].integer);
        -: 3447:      }
        -: 3448:#line 3449 "grammar.c" /* yacc.c:1646  */
    #####: 3449:    break;
        -: 3450:
    #####: 3451:  case 104:
        -: 3452:#line 1766 "grammar.y" /* yacc.c:1646  */
        -: 3453:    {
        -: 3454:        fail_if_error(yr_parser_emit_with_arg_double(
        -: 3455:            yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL));
        -: 3456:
        -: 3457:        (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3458:      }
        -: 3459:#line 3460 "grammar.c" /* yacc.c:1646  */
    #####: 3460:    break;
        -: 3461:
    #####: 3462:  case 105:
        -: 3463:#line 1773 "grammar.y" /* yacc.c:1646  */
        -: 3464:    {
        -: 3465:        SIZED_STRING* sized_string;
        -: 3466:
        -: 3467:        int result = yr_arena_write_data(
        -: 3468:            compiler->sz_arena,
        -: 3469:            (yyvsp[0].sized_string),
        -: 3470:            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
        -: 3471:            (void**) &sized_string);
        -: 3472:
        -: 3473:        yr_free((yyvsp[0].sized_string));
        -: 3474:
        -: 3475:        if (result == ERROR_SUCCESS)
        -: 3476:          result = yr_parser_emit_with_arg_reloc(
        -: 3477:              yyscanner,
        -: 3478:              OP_PUSH,
        -: 3479:              sized_string,
        -: 3480:              NULL,
        -: 3481:              NULL);
        -: 3482:
        -: 3483:        fail_if_error(result);
        -: 3484:
        -: 3485:        (yyval.expression).type = EXPRESSION_TYPE_STRING;
        -: 3486:        (yyval.expression).value.sized_string = sized_string;
        -: 3487:      }
        -: 3488:#line 3489 "grammar.c" /* yacc.c:1646  */
    #####: 3489:    break;
        -: 3490:
    #####: 3491:  case 106:
        -: 3492:#line 1798 "grammar.y" /* yacc.c:1646  */
        -: 3493:    {
        -: 3494:        int result = yr_parser_reduce_string_identifier(
        -: 3495:            yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);
        -: 3496:
        -: 3497:        yr_free((yyvsp[0].c_string));
        -: 3498:
        -: 3499:        fail_if_error(result);
        -: 3500:
        -: 3501:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3502:        (yyval.expression).value.integer = UNDEFINED;
        -: 3503:      }
        -: 3504:#line 3505 "grammar.c" /* yacc.c:1646  */
    #####: 3505:    break;
        -: 3506:
    #####: 3507:  case 107:
        -: 3508:#line 1810 "grammar.y" /* yacc.c:1646  */
        -: 3509:    {
        -: 3510:        int result = yr_parser_reduce_string_identifier(
        -: 3511:            yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);
        -: 3512:
        -: 3513:        yr_free((yyvsp[-3].c_string));
        -: 3514:
        -: 3515:        fail_if_error(result);
        -: 3516:
        -: 3517:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3518:        (yyval.expression).value.integer = UNDEFINED;
        -: 3519:      }
        -: 3520:#line 3521 "grammar.c" /* yacc.c:1646  */
    #####: 3521:    break;
        -: 3522:
    #####: 3523:  case 108:
        -: 3524:#line 1822 "grammar.y" /* yacc.c:1646  */
        -: 3525:    {
        -: 3526:        int result = yr_parser_emit_with_arg(
        -: 3527:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3528:
        -: 3529:        if (result == ERROR_SUCCESS)
        -: 3530:          result = yr_parser_reduce_string_identifier(
        -: 3531:              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);
        -: 3532:
        -: 3533:        yr_free((yyvsp[0].c_string));
        -: 3534:
        -: 3535:        fail_if_error(result);
        -: 3536:
        -: 3537:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3538:        (yyval.expression).value.integer = UNDEFINED;
        -: 3539:      }
        -: 3540:#line 3541 "grammar.c" /* yacc.c:1646  */
    #####: 3541:    break;
        -: 3542:
    #####: 3543:  case 109:
        -: 3544:#line 1838 "grammar.y" /* yacc.c:1646  */
        -: 3545:    {
        -: 3546:        int result = yr_parser_reduce_string_identifier(
        -: 3547:            yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);
        -: 3548:
        -: 3549:        yr_free((yyvsp[-3].c_string));
        -: 3550:
        -: 3551:        fail_if_error(result);
        -: 3552:
        -: 3553:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3554:        (yyval.expression).value.integer = UNDEFINED;
        -: 3555:      }
        -: 3556:#line 3557 "grammar.c" /* yacc.c:1646  */
    #####: 3557:    break;
        -: 3558:
    #####: 3559:  case 110:
        -: 3560:#line 1850 "grammar.y" /* yacc.c:1646  */
        -: 3561:    {
        -: 3562:        int result = yr_parser_emit_with_arg(
        -: 3563:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3564:
        -: 3565:        if (result == ERROR_SUCCESS)
        -: 3566:          result = yr_parser_reduce_string_identifier(
        -: 3567:              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);
        -: 3568:
        -: 3569:        yr_free((yyvsp[0].c_string));
        -: 3570:
        -: 3571:        fail_if_error(result);
        -: 3572:
        -: 3573:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3574:        (yyval.expression).value.integer = UNDEFINED;
        -: 3575:      }
        -: 3576:#line 3577 "grammar.c" /* yacc.c:1646  */
    #####: 3577:    break;
        -: 3578:
    #####: 3579:  case 111:
        -: 3580:#line 1866 "grammar.y" /* yacc.c:1646  */
        -: 3581:    {
        -: 3582:        int result = ERROR_SUCCESS;
        -: 3583:
        -: 3584:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
        -: 3585:        {
        -: 3586:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3587:          (yyval.expression).value.integer = UNDEFINED;
        -: 3588:        }
        -: 3589:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        -: 3590:        {
        -: 3591:          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3592:          (yyval.expression).value.integer = UNDEFINED;
        -: 3593:        }
        -: 3594:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        -: 3595:        {
        -: 3596:          result = yr_parser_emit(
        -: 3597:              yyscanner, OP_OBJ_VALUE, NULL);
        -: 3598:
        -: 3599:          switch((yyvsp[0].expression).value.object->type)
        -: 3600:          {
        -: 3601:            case OBJECT_TYPE_INTEGER:
        -: 3602:              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3603:              (yyval.expression).value.integer = UNDEFINED;
        -: 3604:              break;
        -: 3605:            case OBJECT_TYPE_FLOAT:
        -: 3606:              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3607:              break;
        -: 3608:            case OBJECT_TYPE_STRING:
        -: 3609:              (yyval.expression).type = EXPRESSION_TYPE_STRING;
        -: 3610:              (yyval.expression).value.sized_string = NULL;
        -: 3611:              break;
        -: 3612:            default:
        -: 3613:              yr_compiler_set_error_extra_info_fmt(
        -: 3614:                  compiler,
        -: 3615:                  "wrong usage of identifier \"%s\"",
        -: 3616:                  (yyvsp[0].expression).identifier);
        -: 3617:              result = ERROR_WRONG_TYPE;
        -: 3618:          }
        -: 3619:        }
        -: 3620:        else
        -: 3621:        {
        -: 3622:          assert(false);
        -: 3623:        }
        -: 3624:
        -: 3625:        fail_if_error(result);
        -: 3626:      }
        -: 3627:#line 3628 "grammar.c" /* yacc.c:1646  */
    #####: 3628:    break;
        -: 3629:
    #####: 3630:  case 112:
        -: 3631:#line 1913 "grammar.y" /* yacc.c:1646  */
        -: 3632:    {
        -: 3633:        int result = ERROR_SUCCESS;
        -: 3634:
        -: 3635:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, "-");
        -: 3636:
        -: 3637:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3638:        {
        -: 3639:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3640:          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
        -: 3641:              UNDEFINED : -((yyvsp[0].expression).value.integer);
        -: 3642:          result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        -: 3643:        }
        -: 3644:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        -: 3645:        {
        -: 3646:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3647:          result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        -: 3648:        }
        -: 3649:
        -: 3650:        fail_if_error(result);
        -: 3651:      }
        -: 3652:#line 3653 "grammar.c" /* yacc.c:1646  */
    #####: 3653:    break;
        -: 3654:
    #####: 3655:  case 113:
        -: 3656:#line 1934 "grammar.y" /* yacc.c:1646  */
        -: 3657:    {
        -: 3658:        int result = yr_parser_reduce_operation(
        -: 3659:            yyscanner, "+", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3660:
        -: 3661:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3662:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3663:        {
        -: 3664:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3665:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3666:
        -: 3667:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3668:              (
        -: 3669:                (i2 > 0 && i1 > INT64_MAX - i2) ||
        -: 3670:                (i2 < 0 && i1 < INT64_MIN - i2)
        -: 3671:              ))
        -: 3672:          {
        -: 3673:            yr_compiler_set_error_extra_info_fmt(
        -: 3674:                compiler, "%" PRId64 " + %" PRId64, i1, i2);
        -: 3675:
        -: 3676:            result = ERROR_INTEGER_OVERFLOW;
        -: 3677:          }
        -: 3678:          else
        -: 3679:          {
        -: 3680:            (yyval.expression).value.integer = OPERATION(+, i1, i2);
        -: 3681:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3682:          }
        -: 3683:        }
        -: 3684:        else
        -: 3685:        {
        -: 3686:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3687:        }
        -: 3688:
        -: 3689:        fail_if_error(result);
        -: 3690:      }
        -: 3691:#line 3692 "grammar.c" /* yacc.c:1646  */
    #####: 3692:    break;
        -: 3693:
    #####: 3694:  case 114:
        -: 3695:#line 1969 "grammar.y" /* yacc.c:1646  */
        -: 3696:    {
        -: 3697:        int result = yr_parser_reduce_operation(
        -: 3698:            yyscanner, "-", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3699:
        -: 3700:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3701:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3702:        {
        -: 3703:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3704:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3705:
        -: 3706:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3707:              (
        -: 3708:                (i2 < 0 && i1 > INT64_MAX + i2) ||
        -: 3709:                (i2 > 0 && i1 < INT64_MIN + i2)
        -: 3710:              ))
        -: 3711:          {
        -: 3712:            yr_compiler_set_error_extra_info_fmt(
        -: 3713:                compiler, "%" PRId64 " - %" PRId64, i1, i2);
        -: 3714:
        -: 3715:            result = ERROR_INTEGER_OVERFLOW;
        -: 3716:          }
        -: 3717:          else
        -: 3718:          {
        -: 3719:            (yyval.expression).value.integer = OPERATION(-, i1, i2);
        -: 3720:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3721:          }
        -: 3722:        }
        -: 3723:        else
        -: 3724:        {
        -: 3725:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3726:        }
        -: 3727:
        -: 3728:        fail_if_error(result);
        -: 3729:      }
        -: 3730:#line 3731 "grammar.c" /* yacc.c:1646  */
    #####: 3731:    break;
        -: 3732:
    #####: 3733:  case 115:
        -: 3734:#line 2004 "grammar.y" /* yacc.c:1646  */
        -: 3735:    {
        -: 3736:        int result = yr_parser_reduce_operation(
        -: 3737:            yyscanner, "*", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3738:
        -: 3739:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3740:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3741:        {
        -: 3742:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3743:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3744:
        -: 3745:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3746:              (
        -: 3747:                i2 != 0 && llabs(i1) > INT64_MAX / llabs(i2)
        -: 3748:              ))
        -: 3749:          {
        -: 3750:            yr_compiler_set_error_extra_info_fmt(
        -: 3751:                compiler, "%" PRId64 " * %" PRId64, i1, i2);
        -: 3752:
        -: 3753:            result = ERROR_INTEGER_OVERFLOW;
        -: 3754:          }
        -: 3755:          else
        -: 3756:          {
        -: 3757:            (yyval.expression).value.integer = OPERATION(*, i1, i2);
        -: 3758:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3759:          }
        -: 3760:        }
        -: 3761:        else
        -: 3762:        {
        -: 3763:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3764:        }
        -: 3765:
        -: 3766:        fail_if_error(result);
        -: 3767:      }
        -: 3768:#line 3769 "grammar.c" /* yacc.c:1646  */
    #####: 3769:    break;
        -: 3770:
    #####: 3771:  case 116:
        -: 3772:#line 2038 "grammar.y" /* yacc.c:1646  */
        -: 3773:    {
        -: 3774:        int result = yr_parser_reduce_operation(
        -: 3775:            yyscanner, "\\", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3776:
        -: 3777:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3778:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3779:        {
        -: 3780:          if ((yyvsp[0].expression).value.integer != 0)
        -: 3781:          {
        -: 3782:            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3783:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3784:          }
        -: 3785:          else
        -: 3786:          {
        -: 3787:            result = ERROR_DIVISION_BY_ZERO;
        -: 3788:          }
        -: 3789:        }
        -: 3790:        else
        -: 3791:        {
        -: 3792:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3793:        }
        -: 3794:
        -: 3795:        fail_if_error(result);
        -: 3796:      }
        -: 3797:#line 3798 "grammar.c" /* yacc.c:1646  */
    #####: 3798:    break;
        -: 3799:
    #####: 3800:  case 117:
        -: 3801:#line 2063 "grammar.y" /* yacc.c:1646  */
        -: 3802:    {
        -: 3803:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "%");
        -: 3804:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "%");
        -: 3805:
        -: 3806:        fail_if_error(yr_parser_emit(yyscanner, OP_MOD, NULL));
        -: 3807:
        -: 3808:        if ((yyvsp[0].expression).value.integer != 0)
        -: 3809:        {
        -: 3810:          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3811:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3812:        }
        -: 3813:        else
        -: 3814:        {
        -: 3815:          fail_if_error(ERROR_DIVISION_BY_ZERO);
        -: 3816:        }
        -: 3817:      }
        -: 3818:#line 3819 "grammar.c" /* yacc.c:1646  */
    #####: 3819:    break;
        -: 3820:
    #####: 3821:  case 118:
        -: 3822:#line 2080 "grammar.y" /* yacc.c:1646  */
        -: 3823:    {
        -: 3824:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3825:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3826:
        -: 3827:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL));
        -: 3828:
        -: 3829:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3830:        (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3831:      }
        -: 3832:#line 3833 "grammar.c" /* yacc.c:1646  */
    #####: 3833:    break;
        -: 3834:
    #####: 3835:  case 119:
        -: 3836:#line 2090 "grammar.y" /* yacc.c:1646  */
        -: 3837:    {
        -: 3838:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3839:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3840:
        -: 3841:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL));
        -: 3842:
        -: 3843:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3844:        (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3845:      }
        -: 3846:#line 3847 "grammar.c" /* yacc.c:1646  */
    #####: 3847:    break;
        -: 3848:
    #####: 3849:  case 120:
        -: 3850:#line 2100 "grammar.y" /* yacc.c:1646  */
        -: 3851:    {
        -: 3852:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "|");
        -: 3853:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "|");
        -: 3854:
        -: 3855:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL));
        -: 3856:
        -: 3857:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3858:        (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3859:      }
        -: 3860:#line 3861 "grammar.c" /* yacc.c:1646  */
    #####: 3861:    break;
        -: 3862:
    #####: 3863:  case 121:
        -: 3864:#line 2110 "grammar.y" /* yacc.c:1646  */
        -: 3865:    {
        -: 3866:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "~");
        -: 3867:
        -: 3868:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL));
        -: 3869:
        -: 3870:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3871:        (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
        -: 3872:            UNDEFINED : ~((yyvsp[0].expression).value.integer);
        -: 3873:      }
        -: 3874:#line 3875 "grammar.c" /* yacc.c:1646  */
    #####: 3875:    break;
        -: 3876:
    #####: 3877:  case 122:
        -: 3878:#line 2120 "grammar.y" /* yacc.c:1646  */
        -: 3879:    {
        -: 3880:        int result;
        -: 3881:
        -: 3882:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "<<");
        -: 3883:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "<<");
        -: 3884:
        -: 3885:        result = yr_parser_emit(yyscanner, OP_SHL, NULL);
        -: 3886:
        -: 3887:        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)
        -: 3888:          result = ERROR_INVALID_OPERAND;
        -: 3889:        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)
        -: 3890:          (yyval.expression).value.integer = 0;
        -: 3891:        else
        -: 3892:          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3893:
        -: 3894:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3895:
        -: 3896:        fail_if_error(result);
        -: 3897:      }
        -: 3898:#line 3899 "grammar.c" /* yacc.c:1646  */
    #####: 3899:    break;
        -: 3900:
    #####: 3901:  case 123:
        -: 3902:#line 2140 "grammar.y" /* yacc.c:1646  */
        -: 3903:    {
        -: 3904:        int result;
        -: 3905:
        -: 3906:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ">>");
        -: 3907:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ">>");
        -: 3908:
        -: 3909:        result = yr_parser_emit(yyscanner, OP_SHR, NULL);
        -: 3910:
        -: 3911:        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)
        -: 3912:          result = ERROR_INVALID_OPERAND;
        -: 3913:        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)
        -: 3914:          (yyval.expression).value.integer = 0;
        -: 3915:        else
        -: 3916:          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3917:
        -: 3918:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3919:
        -: 3920:        fail_if_error(result);
        -: 3921:      }
        -: 3922:#line 3923 "grammar.c" /* yacc.c:1646  */
    #####: 3923:    break;
        -: 3924:
    #####: 3925:  case 124:
        -: 3926:#line 2160 "grammar.y" /* yacc.c:1646  */
        -: 3927:    {
        -: 3928:        (yyval.expression) = (yyvsp[0].expression);
        -: 3929:      }
        -: 3930:#line 3931 "grammar.c" /* yacc.c:1646  */
    #####: 3931:    break;
        -: 3932:
        -: 3933:
        -: 3934:#line 3935 "grammar.c" /* yacc.c:1646  */
    #####: 3935:      default: break;
        -: 3936:    }
        -: 3937:  /* User semantic actions sometimes alter yychar, and that requires
        -: 3938:     that yytoken be updated with the new translation.  We take the
        -: 3939:     approach of translating immediately before every use of yytoken.
        -: 3940:     One alternative is translating here after every semantic action,
        -: 3941:     but that translation would be missed if the semantic action invokes
        -: 3942:     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
        -: 3943:     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
        -: 3944:     incorrect destructor might then be invoked immediately.  In the
        -: 3945:     case of YYERROR or YYBACKUP, subsequent parser actions might lead
        -: 3946:     to an incorrect destructor call or verbose syntax error message
        -: 3947:     before the lookahead is translated.  */
        -: 3948:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
        -: 3949:
    #####: 3950:  YYPOPSTACK (yylen);
    #####: 3951:  yylen = 0;
        -: 3952:  YY_STACK_PRINT (yyss, yyssp);
        -: 3953:
    #####: 3954:  *++yyvsp = yyval;
        -: 3955:
        -: 3956:  /* Now 'shift' the result of the reduction.  Determine what state
        -: 3957:     that goes to, based on the state we popped back to and the rule
        -: 3958:     number reduced by.  */
        -: 3959:
    #####: 3960:  yyn = yyr1[yyn];
        -: 3961:
    #####: 3962:  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
    #####: 3963:  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    #####: 3964:    yystate = yytable[yystate];
        -: 3965:  else
    #####: 3966:    yystate = yydefgoto[yyn - YYNTOKENS];
        -: 3967:
    #####: 3968:  goto yynewstate;
        -: 3969:
        -: 3970:
        -: 3971:/*--------------------------------------.
        -: 3972:| yyerrlab -- here on detecting error.  |
        -: 3973:`--------------------------------------*/
    #####: 3974:yyerrlab:
        -: 3975:  /* Make sure we have latest lookahead translation.  See comments at
        -: 3976:     user semantic actions for why this is necessary.  */
    #####: 3977:  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
        -: 3978:
        -: 3979:  /* If not already recovering from an error, report this error.  */
    #####: 3980:  if (!yyerrstatus)
        -: 3981:    {
    #####: 3982:      ++yynerrs;
        -: 3983:#if ! YYERROR_VERBOSE
        -: 3984:      yyerror (yyscanner, compiler, YY_("syntax error"));
        -: 3985:#else
        -: 3986:# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
        -: 3987:                                        yyssp, yytoken)
        -: 3988:      {
    #####: 3989:        char const *yymsgp = YY_("syntax error");
        -: 3990:        int yysyntax_error_status;
    #####: 3991:        yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 3992:        if (yysyntax_error_status == 0)
    #####: 3993:          yymsgp = yymsg;
    #####: 3994:        else if (yysyntax_error_status == 1)
        -: 3995:          {
    #####: 3996:            if (yymsg != yymsgbuf)
    #####: 3997:              YYSTACK_FREE (yymsg);
    #####: 3998:            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
    #####: 3999:            if (!yymsg)
        -: 4000:              {
    #####: 4001:                yymsg = yymsgbuf;
    #####: 4002:                yymsg_alloc = sizeof yymsgbuf;
    #####: 4003:                yysyntax_error_status = 2;
        -: 4004:              }
        -: 4005:            else
        -: 4006:              {
    #####: 4007:                yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 4008:                yymsgp = yymsg;
        -: 4009:              }
        -: 4010:          }
    #####: 4011:        yyerror (yyscanner, compiler, yymsgp);
    #####: 4012:        if (yysyntax_error_status == 2)
    #####: 4013:          goto yyexhaustedlab;
        -: 4014:      }
        -: 4015:# undef YYSYNTAX_ERROR
        -: 4016:#endif
        -: 4017:    }
        -: 4018:
        -: 4019:
        -: 4020:
    #####: 4021:  if (yyerrstatus == 3)
        -: 4022:    {
        -: 4023:      /* If just tried and failed to reuse lookahead token after an
        -: 4024:         error, discard it.  */
        -: 4025:
    #####: 4026:      if (yychar <= YYEOF)
        -: 4027:        {
        -: 4028:          /* Return failure if at end of input.  */
    #####: 4029:          if (yychar == YYEOF)
    #####: 4030:            YYABORT;
        -: 4031:        }
        -: 4032:      else
        -: 4033:        {
    #####: 4034:          yydestruct ("Error: discarding",
        -: 4035:                      yytoken, &yylval, yyscanner, compiler);
    #####: 4036:          yychar = YYEMPTY;
        -: 4037:        }
        -: 4038:    }
        -: 4039:
        -: 4040:  /* Else will try to reuse lookahead token after shifting the error
        -: 4041:     token.  */
    #####: 4042:  goto yyerrlab1;
        -: 4043:
        -: 4044:
        -: 4045:/*---------------------------------------------------.
        -: 4046:| yyerrorlab -- error raised explicitly by YYERROR.  |
        -: 4047:`---------------------------------------------------*/
    #####: 4048:yyerrorlab:
        -: 4049:
        -: 4050:  /* Pacify compilers like GCC when the user code never invokes
        -: 4051:     YYERROR and the label yyerrorlab therefore never appears in user
        -: 4052:     code.  */
        -: 4053:  if (/*CONSTCOND*/ 0)
        -: 4054:     goto yyerrorlab;
        -: 4055:
        -: 4056:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 4057:     this YYERROR.  */
    #####: 4058:  YYPOPSTACK (yylen);
    #####: 4059:  yylen = 0;
        -: 4060:  YY_STACK_PRINT (yyss, yyssp);
    #####: 4061:  yystate = *yyssp;
    #####: 4062:  goto yyerrlab1;
        -: 4063:
        -: 4064:
        -: 4065:/*-------------------------------------------------------------.
        -: 4066:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
        -: 4067:`-------------------------------------------------------------*/
    #####: 4068:yyerrlab1:
    #####: 4069:  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
        -: 4070:
        -: 4071:  for (;;)
        -: 4072:    {
    #####: 4073:      yyn = yypact[yystate];
    #####: 4074:      if (!yypact_value_is_default (yyn))
        -: 4075:        {
    #####: 4076:          yyn += YYTERROR;
    #####: 4077:          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
        -: 4078:            {
    #####: 4079:              yyn = yytable[yyn];
    #####: 4080:              if (0 < yyn)
    #####: 4081:                break;
        -: 4082:            }
        -: 4083:        }
        -: 4084:
        -: 4085:      /* Pop the current state because it cannot handle the error token.  */
    #####: 4086:      if (yyssp == yyss)
    #####: 4087:        YYABORT;
        -: 4088:
        -: 4089:
    #####: 4090:      yydestruct ("Error: popping",
    #####: 4091:                  yystos[yystate], yyvsp, yyscanner, compiler);
    #####: 4092:      YYPOPSTACK (1);
    #####: 4093:      yystate = *yyssp;
        -: 4094:      YY_STACK_PRINT (yyss, yyssp);
        -: 4095:    }
        -: 4096:
        -: 4097:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 4098:  *++yyvsp = yylval;
        -: 4099:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 4100:
        -: 4101:
        -: 4102:  /* Shift the error token.  */
        -: 4103:  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
        -: 4104:
    #####: 4105:  yystate = yyn;
    #####: 4106:  goto yynewstate;
        -: 4107:
        -: 4108:
        -: 4109:/*-------------------------------------.
        -: 4110:| yyacceptlab -- YYACCEPT comes here.  |
        -: 4111:`-------------------------------------*/
    #####: 4112:yyacceptlab:
    #####: 4113:  yyresult = 0;
    #####: 4114:  goto yyreturn;
        -: 4115:
        -: 4116:/*-----------------------------------.
        -: 4117:| yyabortlab -- YYABORT comes here.  |
        -: 4118:`-----------------------------------*/
    #####: 4119:yyabortlab:
    #####: 4120:  yyresult = 1;
    #####: 4121:  goto yyreturn;
        -: 4122:
        -: 4123:#if !defined yyoverflow || YYERROR_VERBOSE
        -: 4124:/*-------------------------------------------------.
        -: 4125:| yyexhaustedlab -- memory exhaustion comes here.  |
        -: 4126:`-------------------------------------------------*/
    #####: 4127:yyexhaustedlab:
    #####: 4128:  yyerror (yyscanner, compiler, YY_("memory exhausted"));
    #####: 4129:  yyresult = 2;
        -: 4130:  /* Fall through.  */
        -: 4131:#endif
        -: 4132:
    #####: 4133:yyreturn:
    #####: 4134:  if (yychar != YYEMPTY)
        -: 4135:    {
        -: 4136:      /* Make sure we have latest lookahead translation.  See comments at
        -: 4137:         user semantic actions for why this is necessary.  */
    #####: 4138:      yytoken = YYTRANSLATE (yychar);
    #####: 4139:      yydestruct ("Cleanup: discarding lookahead",
        -: 4140:                  yytoken, &yylval, yyscanner, compiler);
        -: 4141:    }
        -: 4142:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 4143:     this YYABORT or YYACCEPT.  */
    #####: 4144:  YYPOPSTACK (yylen);
        -: 4145:  YY_STACK_PRINT (yyss, yyssp);
    #####: 4146:  while (yyssp != yyss)
        -: 4147:    {
    #####: 4148:      yydestruct ("Cleanup: popping",
    #####: 4149:                  yystos[*yyssp], yyvsp, yyscanner, compiler);
    #####: 4150:      YYPOPSTACK (1);
        -: 4151:    }
        -: 4152:#ifndef yyoverflow
    #####: 4153:  if (yyss != yyssa)
    #####: 4154:    YYSTACK_FREE (yyss);
        -: 4155:#endif
        -: 4156:#if YYERROR_VERBOSE
    #####: 4157:  if (yymsg != yymsgbuf)
    #####: 4158:    YYSTACK_FREE (yymsg);
        -: 4159:#endif
    #####: 4160:  return yyresult;
        -: 4161:}
        -: 4162:#line 2165 "grammar.y" /* yacc.c:1906  */
        -: 4163:
