        -:    0:Source:lexer.c
        -:    0:Graph:/home/workspace/libyara/lexer.gcno
        -:    0:Data:/home/workspace/libyara/lexer.gcda
        -:    0:Runs:7
        -:    0:Programs:7
        -:    1:#line 2 "lexer.c"
        -:    2:
        -:    3:#line 4 "lexer.c"
        -:    4:
        -:    5:#define  YY_INT_ALIGNED short int
        -:    6:
        -:    7:/* A lexical scanner generated by flex */
        -:    8:
        -:    9:#define FLEX_SCANNER
        -:   10:#define YY_FLEX_MAJOR_VERSION 2
        -:   11:#define YY_FLEX_MINOR_VERSION 6
        -:   12:#define YY_FLEX_SUBMINOR_VERSION 4
        -:   13:#if YY_FLEX_SUBMINOR_VERSION > 0
        -:   14:#define FLEX_BETA
        -:   15:#endif
        -:   16:
        -:   17:#ifdef yy_create_buffer
        -:   18:#define yara_yy_create_buffer_ALREADY_DEFINED
        -:   19:#else
        -:   20:#define yy_create_buffer yara_yy_create_buffer
        -:   21:#endif
        -:   22:
        -:   23:#ifdef yy_delete_buffer
        -:   24:#define yara_yy_delete_buffer_ALREADY_DEFINED
        -:   25:#else
        -:   26:#define yy_delete_buffer yara_yy_delete_buffer
        -:   27:#endif
        -:   28:
        -:   29:#ifdef yy_scan_buffer
        -:   30:#define yara_yy_scan_buffer_ALREADY_DEFINED
        -:   31:#else
        -:   32:#define yy_scan_buffer yara_yy_scan_buffer
        -:   33:#endif
        -:   34:
        -:   35:#ifdef yy_scan_string
        -:   36:#define yara_yy_scan_string_ALREADY_DEFINED
        -:   37:#else
        -:   38:#define yy_scan_string yara_yy_scan_string
        -:   39:#endif
        -:   40:
        -:   41:#ifdef yy_scan_bytes
        -:   42:#define yara_yy_scan_bytes_ALREADY_DEFINED
        -:   43:#else
        -:   44:#define yy_scan_bytes yara_yy_scan_bytes
        -:   45:#endif
        -:   46:
        -:   47:#ifdef yy_init_buffer
        -:   48:#define yara_yy_init_buffer_ALREADY_DEFINED
        -:   49:#else
        -:   50:#define yy_init_buffer yara_yy_init_buffer
        -:   51:#endif
        -:   52:
        -:   53:#ifdef yy_flush_buffer
        -:   54:#define yara_yy_flush_buffer_ALREADY_DEFINED
        -:   55:#else
        -:   56:#define yy_flush_buffer yara_yy_flush_buffer
        -:   57:#endif
        -:   58:
        -:   59:#ifdef yy_load_buffer_state
        -:   60:#define yara_yy_load_buffer_state_ALREADY_DEFINED
        -:   61:#else
        -:   62:#define yy_load_buffer_state yara_yy_load_buffer_state
        -:   63:#endif
        -:   64:
        -:   65:#ifdef yy_switch_to_buffer
        -:   66:#define yara_yy_switch_to_buffer_ALREADY_DEFINED
        -:   67:#else
        -:   68:#define yy_switch_to_buffer yara_yy_switch_to_buffer
        -:   69:#endif
        -:   70:
        -:   71:#ifdef yypush_buffer_state
        -:   72:#define yara_yypush_buffer_state_ALREADY_DEFINED
        -:   73:#else
        -:   74:#define yypush_buffer_state yara_yypush_buffer_state
        -:   75:#endif
        -:   76:
        -:   77:#ifdef yypop_buffer_state
        -:   78:#define yara_yypop_buffer_state_ALREADY_DEFINED
        -:   79:#else
        -:   80:#define yypop_buffer_state yara_yypop_buffer_state
        -:   81:#endif
        -:   82:
        -:   83:#ifdef yyensure_buffer_stack
        -:   84:#define yara_yyensure_buffer_stack_ALREADY_DEFINED
        -:   85:#else
        -:   86:#define yyensure_buffer_stack yara_yyensure_buffer_stack
        -:   87:#endif
        -:   88:
        -:   89:#ifdef yylex
        -:   90:#define yara_yylex_ALREADY_DEFINED
        -:   91:#else
        -:   92:#define yylex yara_yylex
        -:   93:#endif
        -:   94:
        -:   95:#ifdef yyrestart
        -:   96:#define yara_yyrestart_ALREADY_DEFINED
        -:   97:#else
        -:   98:#define yyrestart yara_yyrestart
        -:   99:#endif
        -:  100:
        -:  101:#ifdef yylex_init
        -:  102:#define yara_yylex_init_ALREADY_DEFINED
        -:  103:#else
        -:  104:#define yylex_init yara_yylex_init
        -:  105:#endif
        -:  106:
        -:  107:#ifdef yylex_init_extra
        -:  108:#define yara_yylex_init_extra_ALREADY_DEFINED
        -:  109:#else
        -:  110:#define yylex_init_extra yara_yylex_init_extra
        -:  111:#endif
        -:  112:
        -:  113:#ifdef yylex_destroy
        -:  114:#define yara_yylex_destroy_ALREADY_DEFINED
        -:  115:#else
        -:  116:#define yylex_destroy yara_yylex_destroy
        -:  117:#endif
        -:  118:
        -:  119:#ifdef yyget_debug
        -:  120:#define yara_yyget_debug_ALREADY_DEFINED
        -:  121:#else
        -:  122:#define yyget_debug yara_yyget_debug
        -:  123:#endif
        -:  124:
        -:  125:#ifdef yyset_debug
        -:  126:#define yara_yyset_debug_ALREADY_DEFINED
        -:  127:#else
        -:  128:#define yyset_debug yara_yyset_debug
        -:  129:#endif
        -:  130:
        -:  131:#ifdef yyget_extra
        -:  132:#define yara_yyget_extra_ALREADY_DEFINED
        -:  133:#else
        -:  134:#define yyget_extra yara_yyget_extra
        -:  135:#endif
        -:  136:
        -:  137:#ifdef yyset_extra
        -:  138:#define yara_yyset_extra_ALREADY_DEFINED
        -:  139:#else
        -:  140:#define yyset_extra yara_yyset_extra
        -:  141:#endif
        -:  142:
        -:  143:#ifdef yyget_in
        -:  144:#define yara_yyget_in_ALREADY_DEFINED
        -:  145:#else
        -:  146:#define yyget_in yara_yyget_in
        -:  147:#endif
        -:  148:
        -:  149:#ifdef yyset_in
        -:  150:#define yara_yyset_in_ALREADY_DEFINED
        -:  151:#else
        -:  152:#define yyset_in yara_yyset_in
        -:  153:#endif
        -:  154:
        -:  155:#ifdef yyget_out
        -:  156:#define yara_yyget_out_ALREADY_DEFINED
        -:  157:#else
        -:  158:#define yyget_out yara_yyget_out
        -:  159:#endif
        -:  160:
        -:  161:#ifdef yyset_out
        -:  162:#define yara_yyset_out_ALREADY_DEFINED
        -:  163:#else
        -:  164:#define yyset_out yara_yyset_out
        -:  165:#endif
        -:  166:
        -:  167:#ifdef yyget_leng
        -:  168:#define yara_yyget_leng_ALREADY_DEFINED
        -:  169:#else
        -:  170:#define yyget_leng yara_yyget_leng
        -:  171:#endif
        -:  172:
        -:  173:#ifdef yyget_text
        -:  174:#define yara_yyget_text_ALREADY_DEFINED
        -:  175:#else
        -:  176:#define yyget_text yara_yyget_text
        -:  177:#endif
        -:  178:
        -:  179:#ifdef yyget_lineno
        -:  180:#define yara_yyget_lineno_ALREADY_DEFINED
        -:  181:#else
        -:  182:#define yyget_lineno yara_yyget_lineno
        -:  183:#endif
        -:  184:
        -:  185:#ifdef yyset_lineno
        -:  186:#define yara_yyset_lineno_ALREADY_DEFINED
        -:  187:#else
        -:  188:#define yyset_lineno yara_yyset_lineno
        -:  189:#endif
        -:  190:
        -:  191:#ifdef yyget_column
        -:  192:#define yara_yyget_column_ALREADY_DEFINED
        -:  193:#else
        -:  194:#define yyget_column yara_yyget_column
        -:  195:#endif
        -:  196:
        -:  197:#ifdef yyset_column
        -:  198:#define yara_yyset_column_ALREADY_DEFINED
        -:  199:#else
        -:  200:#define yyset_column yara_yyset_column
        -:  201:#endif
        -:  202:
        -:  203:#ifdef yywrap
        -:  204:#define yara_yywrap_ALREADY_DEFINED
        -:  205:#else
        -:  206:#define yywrap yara_yywrap
        -:  207:#endif
        -:  208:
        -:  209:#ifdef yyget_lval
        -:  210:#define yara_yyget_lval_ALREADY_DEFINED
        -:  211:#else
        -:  212:#define yyget_lval yara_yyget_lval
        -:  213:#endif
        -:  214:
        -:  215:#ifdef yyset_lval
        -:  216:#define yara_yyset_lval_ALREADY_DEFINED
        -:  217:#else
        -:  218:#define yyset_lval yara_yyset_lval
        -:  219:#endif
        -:  220:
        -:  221:#ifdef yyalloc
        -:  222:#define yara_yyalloc_ALREADY_DEFINED
        -:  223:#else
        -:  224:#define yyalloc yara_yyalloc
        -:  225:#endif
        -:  226:
        -:  227:#ifdef yyrealloc
        -:  228:#define yara_yyrealloc_ALREADY_DEFINED
        -:  229:#else
        -:  230:#define yyrealloc yara_yyrealloc
        -:  231:#endif
        -:  232:
        -:  233:#ifdef yyfree
        -:  234:#define yara_yyfree_ALREADY_DEFINED
        -:  235:#else
        -:  236:#define yyfree yara_yyfree
        -:  237:#endif
        -:  238:
        -:  239:/* First, we deal with  platform-specific or compiler-specific issues. */
        -:  240:
        -:  241:/* begin standard C headers. */
        -:  242:#include <stdio.h>
        -:  243:#include <string.h>
        -:  244:#include <errno.h>
        -:  245:#include <stdlib.h>
        -:  246:
        -:  247:/* end standard C headers. */
        -:  248:
        -:  249:/* flex integer type definitions */
        -:  250:
        -:  251:#ifndef FLEXINT_H
        -:  252:#define FLEXINT_H
        -:  253:
        -:  254:/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
        -:  255:
        -:  256:#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
        -:  257:
        -:  258:/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
        -:  259: * if you want the limit (max/min) macros for int types. 
        -:  260: */
        -:  261:#ifndef __STDC_LIMIT_MACROS
        -:  262:#define __STDC_LIMIT_MACROS 1
        -:  263:#endif
        -:  264:
        -:  265:#include <inttypes.h>
        -:  266:typedef int8_t flex_int8_t;
        -:  267:typedef uint8_t flex_uint8_t;
        -:  268:typedef int16_t flex_int16_t;
        -:  269:typedef uint16_t flex_uint16_t;
        -:  270:typedef int32_t flex_int32_t;
        -:  271:typedef uint32_t flex_uint32_t;
        -:  272:#else
        -:  273:typedef signed char flex_int8_t;
        -:  274:typedef short int flex_int16_t;
        -:  275:typedef int flex_int32_t;
        -:  276:typedef unsigned char flex_uint8_t; 
        -:  277:typedef unsigned short int flex_uint16_t;
        -:  278:typedef unsigned int flex_uint32_t;
        -:  279:
        -:  280:/* Limits of integral types. */
        -:  281:#ifndef INT8_MIN
        -:  282:#define INT8_MIN               (-128)
        -:  283:#endif
        -:  284:#ifndef INT16_MIN
        -:  285:#define INT16_MIN              (-32767-1)
        -:  286:#endif
        -:  287:#ifndef INT32_MIN
        -:  288:#define INT32_MIN              (-2147483647-1)
        -:  289:#endif
        -:  290:#ifndef INT8_MAX
        -:  291:#define INT8_MAX               (127)
        -:  292:#endif
        -:  293:#ifndef INT16_MAX
        -:  294:#define INT16_MAX              (32767)
        -:  295:#endif
        -:  296:#ifndef INT32_MAX
        -:  297:#define INT32_MAX              (2147483647)
        -:  298:#endif
        -:  299:#ifndef UINT8_MAX
        -:  300:#define UINT8_MAX              (255U)
        -:  301:#endif
        -:  302:#ifndef UINT16_MAX
        -:  303:#define UINT16_MAX             (65535U)
        -:  304:#endif
        -:  305:#ifndef UINT32_MAX
        -:  306:#define UINT32_MAX             (4294967295U)
        -:  307:#endif
        -:  308:
        -:  309:#ifndef SIZE_MAX
        -:  310:#define SIZE_MAX               (~(size_t)0)
        -:  311:#endif
        -:  312:
        -:  313:#endif /* ! C99 */
        -:  314:
        -:  315:#endif /* ! FLEXINT_H */
        -:  316:
        -:  317:/* begin standard C++ headers. */
        -:  318:
        -:  319:/* TODO: this is always defined, so inline it */
        -:  320:#define yyconst const
        -:  321:
        -:  322:#if defined(__GNUC__) && __GNUC__ >= 3
        -:  323:#define yynoreturn __attribute__((__noreturn__))
        -:  324:#else
        -:  325:#define yynoreturn
        -:  326:#endif
        -:  327:
        -:  328:/* Returned upon end-of-file. */
        -:  329:#define YY_NULL 0
        -:  330:
        -:  331:/* Promotes a possibly negative, possibly signed char to an
        -:  332: *   integer in range [0..255] for use as an array index.
        -:  333: */
        -:  334:#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
        -:  335:
        -:  336:/* An opaque pointer. */
        -:  337:#ifndef YY_TYPEDEF_YY_SCANNER_T
        -:  338:#define YY_TYPEDEF_YY_SCANNER_T
        -:  339:typedef void* yyscan_t;
        -:  340:#endif
        -:  341:
        -:  342:/* For convenience, these vars (plus the bison vars far below)
        -:  343:   are macros in the reentrant scanner. */
        -:  344:#define yyin yyg->yyin_r
        -:  345:#define yyout yyg->yyout_r
        -:  346:#define yyextra yyg->yyextra_r
        -:  347:#define yyleng yyg->yyleng_r
        -:  348:#define yytext yyg->yytext_r
        -:  349:#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
        -:  350:#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
        -:  351:#define yy_flex_debug yyg->yy_flex_debug_r
        -:  352:
        -:  353:/* Enter a start condition.  This macro really ought to take a parameter,
        -:  354: * but we do it the disgusting crufty way forced on us by the ()-less
        -:  355: * definition of BEGIN.
        -:  356: */
        -:  357:#define BEGIN yyg->yy_start = 1 + 2 *
        -:  358:/* Translate the current start state into a value that can be later handed
        -:  359: * to BEGIN to return to the state.  The YYSTATE alias is for lex
        -:  360: * compatibility.
        -:  361: */
        -:  362:#define YY_START ((yyg->yy_start - 1) / 2)
        -:  363:#define YYSTATE YY_START
        -:  364:/* Action number for EOF rule of a given start state. */
        -:  365:#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
        -:  366:/* Special action meaning "start processing a new file". */
        -:  367:#define YY_NEW_FILE yyrestart( yyin , yyscanner )
        -:  368:#define YY_END_OF_BUFFER_CHAR 0
        -:  369:
        -:  370:/* Size of default input buffer. */
        -:  371:#ifndef YY_BUF_SIZE
        -:  372:#ifdef __ia64__
        -:  373:/* On IA-64, the buffer size is 16k, not 8k.
        -:  374: * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
        -:  375: * Ditto for the __ia64__ case accordingly.
        -:  376: */
        -:  377:#define YY_BUF_SIZE 32768
        -:  378:#else
        -:  379:#define YY_BUF_SIZE 16384
        -:  380:#endif /* __ia64__ */
        -:  381:#endif
        -:  382:
        -:  383:/* The state buf must be large enough to hold one state per character in the main buffer.
        -:  384: */
        -:  385:#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
        -:  386:
        -:  387:#ifndef YY_TYPEDEF_YY_BUFFER_STATE
        -:  388:#define YY_TYPEDEF_YY_BUFFER_STATE
        -:  389:typedef struct yy_buffer_state *YY_BUFFER_STATE;
        -:  390:#endif
        -:  391:
        -:  392:#ifndef YY_TYPEDEF_YY_SIZE_T
        -:  393:#define YY_TYPEDEF_YY_SIZE_T
        -:  394:typedef size_t yy_size_t;
        -:  395:#endif
        -:  396:
        -:  397:#define EOB_ACT_CONTINUE_SCAN 0
        -:  398:#define EOB_ACT_END_OF_FILE 1
        -:  399:#define EOB_ACT_LAST_MATCH 2
        -:  400:    
        -:  401:    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
        -:  402:     *       access to the local variable yy_act. Since yyless() is a macro, it would break
        -:  403:     *       existing scanners that call yyless() from OUTSIDE yylex.
        -:  404:     *       One obvious solution it to make yy_act a global. I tried that, and saw
        -:  405:     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
        -:  406:     *       normally declared as a register variable-- so it is not worth it.
        -:  407:     */
        -:  408:    #define  YY_LESS_LINENO(n) \
        -:  409:            do { \
        -:  410:                int yyl;\
        -:  411:                for ( yyl = n; yyl < yyleng; ++yyl )\
        -:  412:                    if ( yytext[yyl] == '\n' )\
        -:  413:                        --yylineno;\
        -:  414:            }while(0)
        -:  415:    #define YY_LINENO_REWIND_TO(dst) \
        -:  416:            do {\
        -:  417:                const char *p;\
        -:  418:                for ( p = yy_cp-1; p >= (dst); --p)\
        -:  419:                    if ( *p == '\n' )\
        -:  420:                        --yylineno;\
        -:  421:            }while(0)
        -:  422:    
        -:  423:/* Return all but the first "n" matched characters back to the input stream. */
        -:  424:#define yyless(n) \
        -:  425:	do \
        -:  426:		{ \
        -:  427:		/* Undo effects of setting up yytext. */ \
        -:  428:        int yyless_macro_arg = (n); \
        -:  429:        YY_LESS_LINENO(yyless_macro_arg);\
        -:  430:		*yy_cp = yyg->yy_hold_char; \
        -:  431:		YY_RESTORE_YY_MORE_OFFSET \
        -:  432:		yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
        -:  433:		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        -:  434:		} \
        -:  435:	while ( 0 )
        -:  436:#define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )
        -:  437:
        -:  438:#ifndef YY_STRUCT_YY_BUFFER_STATE
        -:  439:#define YY_STRUCT_YY_BUFFER_STATE
        -:  440:struct yy_buffer_state
        -:  441:	{
        -:  442:	FILE *yy_input_file;
        -:  443:
        -:  444:	char *yy_ch_buf;		/* input buffer */
        -:  445:	char *yy_buf_pos;		/* current position in input buffer */
        -:  446:
        -:  447:	/* Size of input buffer in bytes, not including room for EOB
        -:  448:	 * characters.
        -:  449:	 */
        -:  450:	int yy_buf_size;
        -:  451:
        -:  452:	/* Number of characters read into yy_ch_buf, not including EOB
        -:  453:	 * characters.
        -:  454:	 */
        -:  455:	int yy_n_chars;
        -:  456:
        -:  457:	/* Whether we "own" the buffer - i.e., we know we created it,
        -:  458:	 * and can realloc() it to grow it, and should free() it to
        -:  459:	 * delete it.
        -:  460:	 */
        -:  461:	int yy_is_our_buffer;
        -:  462:
        -:  463:	/* Whether this is an "interactive" input source; if so, and
        -:  464:	 * if we're using stdio for input, then we want to use getc()
        -:  465:	 * instead of fread(), to make sure we stop fetching input after
        -:  466:	 * each newline.
        -:  467:	 */
        -:  468:	int yy_is_interactive;
        -:  469:
        -:  470:	/* Whether we're considered to be at the beginning of a line.
        -:  471:	 * If so, '^' rules will be active on the next match, otherwise
        -:  472:	 * not.
        -:  473:	 */
        -:  474:	int yy_at_bol;
        -:  475:
        -:  476:    int yy_bs_lineno; /**< The line count. */
        -:  477:    int yy_bs_column; /**< The column count. */
        -:  478:
        -:  479:	/* Whether to try to fill the input buffer when we reach the
        -:  480:	 * end of it.
        -:  481:	 */
        -:  482:	int yy_fill_buffer;
        -:  483:
        -:  484:	int yy_buffer_status;
        -:  485:
        -:  486:#define YY_BUFFER_NEW 0
        -:  487:#define YY_BUFFER_NORMAL 1
        -:  488:	/* When an EOF's been seen but there's still some text to process
        -:  489:	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
        -:  490:	 * shouldn't try reading from the input source any more.  We might
        -:  491:	 * still have a bunch of tokens to match, though, because of
        -:  492:	 * possible backing-up.
        -:  493:	 *
        -:  494:	 * When we actually see the EOF, we change the status to "new"
        -:  495:	 * (via yyrestart()), so that the user can continue scanning by
        -:  496:	 * just pointing yyin at a new input file.
        -:  497:	 */
        -:  498:#define YY_BUFFER_EOF_PENDING 2
        -:  499:
        -:  500:	};
        -:  501:#endif /* !YY_STRUCT_YY_BUFFER_STATE */
        -:  502:
        -:  503:/* We provide macros for accessing buffer states in case in the
        -:  504: * future we want to put the buffer states in a more general
        -:  505: * "scanner state".
        -:  506: *
        -:  507: * Returns the top of the stack, or NULL.
        -:  508: */
        -:  509:#define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \
        -:  510:                          ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \
        -:  511:                          : NULL)
        -:  512:/* Same as previous macro, but useful when we know that the buffer stack is not
        -:  513: * NULL or when we need an lvalue. For internal use only.
        -:  514: */
        -:  515:#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]
        -:  516:
        -:  517:void yyrestart ( FILE *input_file , yyscan_t yyscanner );
        -:  518:void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
        -:  519:YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size , yyscan_t yyscanner );
        -:  520:void yy_delete_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
        -:  521:void yy_flush_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
        -:  522:void yypush_buffer_state ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
        -:  523:void yypop_buffer_state ( yyscan_t yyscanner );
        -:  524:
        -:  525:static void yyensure_buffer_stack ( yyscan_t yyscanner );
        -:  526:static void yy_load_buffer_state ( yyscan_t yyscanner );
        -:  527:static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file , yyscan_t yyscanner );
        -:  528:#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER , yyscanner)
        -:  529:
        -:  530:YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size , yyscan_t yyscanner );
        -:  531:YY_BUFFER_STATE yy_scan_string ( const char *yy_str , yyscan_t yyscanner );
        -:  532:YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len , yyscan_t yyscanner );
        -:  533:
        -:  534:void *yyalloc ( yy_size_t , yyscan_t yyscanner );
        -:  535:void *yyrealloc ( void *, yy_size_t , yyscan_t yyscanner );
        -:  536:void yyfree ( void * , yyscan_t yyscanner );
        -:  537:
        -:  538:#define yy_new_buffer yy_create_buffer
        -:  539:#define yy_set_interactive(is_interactive) \
        -:  540:	{ \
        -:  541:	if ( ! YY_CURRENT_BUFFER ){ \
        -:  542:        yyensure_buffer_stack (yyscanner); \
        -:  543:		YY_CURRENT_BUFFER_LVALUE =    \
        -:  544:            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
        -:  545:	} \
        -:  546:	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
        -:  547:	}
        -:  548:#define yy_set_bol(at_bol) \
        -:  549:	{ \
        -:  550:	if ( ! YY_CURRENT_BUFFER ){\
        -:  551:        yyensure_buffer_stack (yyscanner); \
        -:  552:		YY_CURRENT_BUFFER_LVALUE =    \
        -:  553:            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
        -:  554:	} \
        -:  555:	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
        -:  556:	}
        -:  557:#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
        -:  558:
        -:  559:/* Begin user sect3 */
        -:  560:
        -:  561:#define yara_yywrap(yyscanner) (/*CONSTCOND*/1)
        -:  562:#define YY_SKIP_YYWRAP
        -:  563:typedef flex_uint8_t YY_CHAR;
        -:  564:
        -:  565:typedef int yy_state_type;
        -:  566:
        -:  567:#define yytext_ptr yytext_r
        -:  568:
        -:  569:static yy_state_type yy_get_previous_state ( yyscan_t yyscanner );
        -:  570:static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  , yyscan_t yyscanner);
        -:  571:static int yy_get_next_buffer ( yyscan_t yyscanner );
        -:  572:static void yynoreturn yy_fatal_error ( const char* msg , yyscan_t yyscanner );
        -:  573:
        -:  574:/* Done after the current pattern has been matched and before the
        -:  575: * corresponding action - sets up yytext.
        -:  576: */
        -:  577:#define YY_DO_BEFORE_ACTION \
        -:  578:	yyg->yytext_ptr = yy_bp; \
        -:  579:	yyleng = (int) (yy_cp - yy_bp); \
        -:  580:	yyg->yy_hold_char = *yy_cp; \
        -:  581:	*yy_cp = '\0'; \
        -:  582:	yyg->yy_c_buf_p = yy_cp;
        -:  583:#define YY_NUM_RULES 75
        -:  584:#define YY_END_OF_BUFFER 76
        -:  585:/* This struct is not used in this scanner,
        -:  586:   but its presence is necessary. */
        -:  587:struct yy_trans_info
        -:  588:	{
        -:  589:	flex_int32_t yy_verify;
        -:  590:	flex_int32_t yy_nxt;
        -:  591:	};
        -:  592:static const flex_int16_t yy_accept[286] =
        -:  593:    {   0,
        -:  594:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:  595:       76,   74,   73,   73,   49,   70,   47,   46,   74,   71,
        -:  596:       52,   52,    2,   74,    3,   48,   51,   51,   51,   51,
        -:  597:       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
        -:  598:       51,   51,   51,   74,   62,   63,   56,   75,   68,   69,
        -:  599:       65,   75,   43,   44,   40,   40,   49,    7,   47,   45,
        -:  600:       46,    1,   38,   41,    0,   52,    0,    0,    0,    0,
        -:  601:        8,    4,    6,    5,    9,   48,   51,   51,   51,   51,
        -:  602:       26,   51,   51,   51,   51,   51,   51,   51,   51,   27,
        -:  603:       51,   51,   51,   28,   25,   51,   51,   51,   51,   51,
        -:  604:
        -:  605:       51,   51,   51,    0,    0,   62,   64,   59,   60,   58,
        -:  606:       57,   64,   68,   65,   65,   67,   66,   43,   39,   41,
        -:  607:       53,   52,   55,   54,   31,   24,   32,   51,   51,   51,
        -:  608:       51,   51,   30,   51,   51,   51,   51,   51,   51,   51,
        -:  609:       51,   23,   51,   51,   51,   51,   51,   51,   51,   17,
        -:  610:       72,    0,    0,    0,   51,   51,   51,   51,   51,   51,
        -:  611:       51,   51,   51,   51,   51,   51,   50,   51,   13,   51,
        -:  612:       51,   12,   51,   29,   21,   16,    0,    0,    0,    0,
        -:  613:        0,   72,   61,   15,   51,   51,   51,   22,   51,   51,
        -:  614:       51,   51,   51,   51,   51,   51,   51,   51,    0,    0,
        -:  615:
        -:  616:        0,   51,   51,   51,   51,   51,   11,   37,   51,   50,
        -:  617:       51,   19,   51,   51,    0,    0,    0,    0,    0,    0,
        -:  618:        0,   72,   51,   51,   51,   51,   51,   51,   35,   10,
        -:  619:       14,    0,   72,    0,    0,    0,    0,   72,    0,    0,
        -:  620:       51,   36,   51,   34,   18,    0,    0,    0,    0,    0,
        -:  621:        0,    0,    0,   72,    0,   72,    0,    0,    0,    0,
        -:  622:       72,   20,   51,   42,    0,    0,    0,    0,    0,    0,
        -:  623:        0,    0,    0,    0,   72,    0,    0,    0,   72,   33,
        -:  624:        0,    0,    0,    0,    0
        -:  625:    } ;
        -:  626:
        -:  627:static const YY_CHAR yy_ec[256] =
        -:  628:    {   0,
        -:  629:        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        -:  630:        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        -:  631:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  632:        1,    2,    5,    6,    7,    8,    1,    1,    1,    9,
        -:  633:        9,   10,    1,    1,    9,   11,   12,   13,   14,   15,
        -:  634:       16,   17,   17,   18,   17,   19,   20,    1,    1,   21,
        -:  635:       22,   23,    9,   24,   25,   26,   25,   25,   25,   25,
        -:  636:       27,   27,   27,   27,   28,   27,   29,   27,   27,   27,
        -:  637:       27,   27,   27,   27,   27,   27,   27,   27,   27,   27,
        -:  638:        9,   30,    9,    1,   31,    1,   32,   33,   34,   35,
        -:  639:
        -:  640:       36,   37,   38,   39,   40,   27,   27,   41,   42,   43,
        -:  641:       44,   45,   27,   46,   47,   48,   49,   50,   51,   52,
        -:  642:       53,   54,   55,    9,   56,    1,    1,    1,    1,    1,
        -:  643:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  644:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  645:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  646:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  647:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  648:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  649:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  650:
        -:  651:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  652:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  653:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  654:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  655:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  656:        1,    1,    1,    1,    1
        -:  657:    } ;
        -:  658:
        -:  659:static const YY_CHAR yy_meta[57] =
        -:  660:    {   0,
        -:  661:        1,    2,    3,    2,    1,    4,    1,    1,    2,    5,
        -:  662:        6,    7,    8,    8,    8,    8,    8,    8,    8,    8,
        -:  663:        1,    9,    1,    1,   10,   10,   11,   12,   12,   13,
        -:  664:       11,   10,   10,   10,   10,   10,   10,   11,   11,   11,
        -:  665:       11,   11,   11,   12,   11,   11,   11,   11,   11,   11,
        -:  666:       11,   12,   11,   11,    1,    1
        -:  667:    } ;
        -:  668:
        -:  669:static const flex_int16_t yy_base[311] =
        -:  670:    {   0,
        -:  671:        0,    0,   54,   55,   56,   59,  754,  753,  748,  747,
        -:  672:      756, 1020, 1020, 1020,  733, 1020,    0,  738,  736,   53,
        -:  673:       53,   59,   45,  724,   50,    0,    0,   51,  701,  701,
        -:  674:       51,  700,   32,   44,  696,   32,  693,  689,  680,   62,
        -:  675:      687,  685,  680,  711,    0, 1020, 1020,   84,    0, 1020,
        -:  676:       62,  710,    0, 1020, 1020,  537,  526, 1020,    0, 1020,
        -:  677:      537, 1020, 1020,    0,  102,    0,  520,  519,  124,    0,
        -:  678:     1020, 1020, 1020, 1020, 1020,    0,    0,  503,   71,  509,
        -:  679:        0,  499,  493,  499,  498,  492,  496,  492,  490,   45,
        -:  680:      486,  485,   62,    0,    0,  492,  484,  478,  487,  473,
        -:  681:
        -:  682:      478,  483,  471,   92,  113,    0, 1020, 1020, 1020, 1020,
        -:  683:     1020,    0,    0,  469, 1020, 1020, 1020,    0, 1020,    0,
        -:  684:      136, 1020,  144,    0,    0,    0,    0,  475,   78,  459,
        -:  685:      455,  465,    0,  459,  466,  338,  340,  114,  346,  347,
        -:  686:      346,    0,  327,  340,  335,  332,  337,  324,  335,    0,
        -:  687:     1020,  360,  161,    0,  329,  328,  335,  313,  329,  311,
        -:  688:      306,  324,  309,  305,  333,  335,  316,  309,    0,  291,
        -:  689:      303,    0,  291,    0,    0,    0,  323,  119,  216,    0,
        -:  690:      133,    0, 1020,    0,  284,  231,  225,    0,  229,  224,
        -:  691:      226,  218,  230,  228,  227,  226,  213,  222,  249,  272,
        -:  692:
        -:  693:      134,  218,  214,  212,  201,  208,    0,    0,  211,    0,
        -:  694:      199,    0,  209,  197,  233,  156,    0,    0,  327,  383,
        -:  695:      157,    0,  196,  191,  187,  190,  181,  199,    0,    0,
        -:  696:        0,  172,  182,  439,    0,  494,  173,    0,  550,  178,
        -:  697:      129,    0,  128,    0,    0,  197,  179,    0,    0,    0,
        -:  698:        0,  137,  190,    0,  194,  125,  606,    0,  662,  195,
        -:  699:        0,    0,   86, 1020,  717,  102,  198,  199,    0,    0,
        -:  700:        0,    0,   97,  202,    0,    0,  203,  211,    0,    0,
        -:  701:       67,  212,  227,    0, 1020,  773,  786,  799,  812,  818,
        -:  702:      823,  831,  838,  843,  848,  859,  869,  881,  894,  906,
        -:  703:
        -:  704:      919,  932,  938,  941,  951,  964,  970,  980,  993, 1006
        -:  705:    } ;
        -:  706:
        -:  707:static const flex_int16_t yy_def[311] =
        -:  708:    {   0,
        -:  709:      285,    1,  286,  286,  287,  287,  288,  288,  289,  289,
        -:  710:      285,  285,  285,  285,  290,  285,  291,  292,  285,  285,
        -:  711:      293,  293,  285,  285,  285,  294,  295,  295,  295,  295,
        -:  712:      295,  295,  295,  295,  295,  295,  295,  295,  295,  295,
        -:  713:      295,  295,  295,  296,  297,  285,  285,  298,  299,  285,
        -:  714:      285,  300,  301,  285,  285,  285,  290,  285,  291,  285,
        -:  715:      292,  285,  285,  302,  285,   22,  285,  285,  285,  303,
        -:  716:      285,  285,  285,  285,  285,  294,  295,  295,  295,  295,
        -:  717:      295,  295,  295,  295,  295,  295,  295,  295,  295,  295,
        -:  718:      295,  295,  295,  295,  295,  295,  295,  295,  295,  295,
        -:  719:
        -:  720:      295,  295,  295,  296,  285,  297,  285,  285,  285,  285,
        -:  721:      285,  304,  299,  285,  285,  285,  285,  301,  285,  302,
        -:  722:      285,  285,  285,  303,  295,  295,  295,  295,  295,  295,
        -:  723:      295,  295,  295,  295,  295,  295,  295,  295,  295,  295,
        -:  724:      295,  295,  295,  295,  295,  295,  295,  295,  295,  295,
        -:  725:      285,  305,  306,  307,  295,  295,  295,  295,  295,  295,
        -:  726:      295,  295,  295,  295,  295,  295,  295,  295,  295,  295,
        -:  727:      295,  295,  295,  295,  295,  295,  305,  308,  306,  179,
        -:  728:      179,  179,  285,  295,  295,  295,  295,  295,  295,  295,
        -:  729:      295,  295,  295,  295,  295,  295,  295,  295,  309,  285,
        -:  730:
        -:  731:      179,  295,  295,  295,  295,  295,  295,  295,  295,  295,
        -:  732:      295,  295,  295,  295,  309,  308,  200,  200,  305,  285,
        -:  733:      200,  200,  295,  295,  295,  295,  295,  295,  295,  295,
        -:  734:      295,  305,  305,  285,  234,  309,  179,  234,  285,  200,
        -:  735:      295,  295,  295,  295,  295,  285,  310,  200,  234,  234,
        -:  736:      236,  220,  234,  234,  309,  309,  285,  257,  285,  200,
        -:  737:      257,  295,  295,  285,  259,  239,  234,  310,  234,  257,
        -:  738:      257,  259,  220,  257,  257,  265,  308,  265,  265,  295,
        -:  739:      239,  257,  310,  257,    0,  285,  285,  285,  285,  285,
        -:  740:      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
        -:  741:
        -:  742:      285,  285,  285,  285,  285,  285,  285,  285,  285,  285
        -:  743:    } ;
        -:  744:
        -:  745:static const flex_int16_t yy_nxt[1077] =
        -:  746:    {   0,
        -:  747:       12,   13,   14,   13,   15,   16,   17,   18,   12,   12,
        -:  748:       19,   20,   21,   22,   22,   22,   22,   22,   22,   22,
        -:  749:       23,   24,   25,   26,   27,   27,   27,   27,   27,   12,
        -:  750:       27,   28,   27,   29,   27,   30,   31,   32,   27,   33,
        -:  751:       27,   34,   35,   36,   37,   38,   39,   40,   41,   27,
        -:  752:       42,   43,   27,   27,   44,   12,   46,   46,   50,   47,
        -:  753:       47,   50,   63,   65,   64,   71,   72,   51,   94,   65,
        -:  754:       51,   74,   75,   89,   90,   91,  273,   95,  137,   92,
        -:  755:       67,   68,   84,   48,   48,   52,   67,   68,   52,  108,
        -:  756:       85,   78,  138,   79,   86,  141,   69,   80,   81,   87,
        -:  757:
        -:  758:       99,  114,  285,  105,   70,  126,  273,  100,  115,  142,
        -:  759:      285,  273,  156,  109,  121,  121,  121,  121,  121,  121,
        -:  760:      121,  121,  152,  127,  153,  157,  110,  165,  178,  166,
        -:  761:      104,  111,  167,  280,  216,  112,  123,  123,  123,  123,
        -:  762:      123,  123,  200,  200,  201,  201,  252,  151,  121,  121,
        -:  763:      121,  121,  121,  121,  121,  121,  123,  123,  123,  123,
        -:  764:      123,  123,  180,  104,  180,  216,  239,  104,  240,  180,
        -:  765:      263,  262,  181,  180,  180,  180,  180,  180,  180,  180,
        -:  766:      180,  247,  200,  248,  201,  180,  180,  239,  178,  240,
        -:  767:      219,  178,  180,  180,  180,  180,  180,  180,  246,  266,
        -:  768:
        -:  769:      246,  267,  264,  268,  239,  269,  240,  266,  277,  267,
        -:  770:      219,  281,  277,  282,  104,  245,  182,  180,  104,  180,
        -:  771:      283,  281,  284,  282,  180,  244,  243,  181,  180,  180,
        -:  772:      180,  180,  180,  180,  180,  180,  277,  242,  219,  241,
        -:  773:      180,  180,  216,  231,  230,  229,  228,  180,  180,  180,
        -:  774:      180,  180,  180,  227,  226,  225,  224,  223,  216,  214,
        -:  775:      213,  212,  211,  210,  209,  208,  207,  206,  205,  204,
        -:  776:      203,  182,  217,  218,  219,  218,  217,  217,  217,  217,
        -:  777:      218,  220,  217,  221,  218,  218,  218,  218,  218,  218,
        -:  778:      218,  218,  217,  217,  217,  217,  218,  218,  217,  217,
        -:  779:
        -:  780:      217,  217,  217,  218,  218,  218,  218,  218,  218,  217,
        -:  781:      217,  217,  217,  217,  217,  217,  217,  217,  217,  217,
        -:  782:      217,  217,  217,  217,  217,  217,  217,  222,  219,  219,
        -:  783:      219,  202,  178,  198,  197,  219,  178,  196,  232,  219,
        -:  784:      219,  219,  219,  219,  219,  219,  219,  195,  194,  167,
        -:  785:      167,  219,  219,  193,  192,  191,  190,  189,  219,  219,
        -:  786:      219,  219,  219,  219,  188,  187,  186,  185,  184,  178,
        -:  787:      176,  138,  175,  174,  173,  172,  171,  170,  169,  168,
        -:  788:      164,  163,  233,  234,  235,  236,  235,  234,  234,  234,
        -:  789:      234,  235,  220,  234,  237,  235,  235,  235,  235,  235,
        -:  790:
        -:  791:      235,  235,  235,  234,  234,  234,  234,  235,  235,  234,
        -:  792:      234,  234,  234,  234,  235,  235,  235,  235,  235,  235,
        -:  793:      234,  234,  234,  234,  234,  234,  234,  234,  234,  234,
        -:  794:      234,  234,  234,  234,  234,  234,  234,  234,  238,  249,
        -:  795:      250,  251,  250,  249,  249,  249,  249,  250,  252,  249,
        -:  796:      253,  250,  250,  250,  250,  250,  250,  250,  250,  249,
        -:  797:      249,  249,  249,  250,  250,  249,  249,  249,  249,  249,
        -:  798:      250,  250,  250,  250,  250,  250,  249,  249,  249,  249,
        -:  799:      249,  249,  249,  249,  249,  249,  249,  249,  249,  249,
        -:  800:      249,  249,  249,  249,  254,  251,  251,  251,  162,  161,
        -:  801:
        -:  802:      160,  159,  251,  216,  158,  255,  251,  251,  251,  251,
        -:  803:      251,  251,  251,  251,  155,  115,  150,  149,  251,  251,
        -:  804:      148,  147,  146,  145,  144,  251,  251,  251,  251,  251,
        -:  805:      251,  143,  140,  139,  136,  135,  134,  133,  132,  131,
        -:  806:      130,  129,  128,  125,  122,  122,   60,  285,  119,  256,
        -:  807:      257,  258,  259,  258,  257,  257,  257,  257,  258,  220,
        -:  808:      257,  260,  258,  258,  258,  258,  258,  258,  258,  258,
        -:  809:      257,  257,  257,  257,  258,  258,  257,  257,  257,  257,
        -:  810:      257,  258,  258,  258,  258,  258,  258,  257,  257,  257,
        -:  811:      257,  257,  257,  257,  257,  257,  257,  257,  257,  257,
        -:  812:
        -:  813:      257,  257,  257,  257,  257,  261,  270,  271,  272,  271,
        -:  814:      270,  270,  270,  270,  271,  273,  270,  274,  271,  271,
        -:  815:      271,  271,  271,  271,  271,  271,  270,  270,  270,  270,
        -:  816:      271,  271,  270,  270,  270,  270,  270,  271,  271,  271,
        -:  817:      271,  271,  271,  270,  270,  270,  270,  270,  270,  270,
        -:  818:      270,  270,  270,  270,  270,  270,  270,  270,  270,  270,
        -:  819:      270,  275,  276,  272,  272,  272,  276,  276,  276,  276,
        -:  820:      272,  277,  276,  278,  272,  272,  272,  272,  272,  272,
        -:  821:      272,  272,  276,  276,  276,  276,  272,  272,  276,  276,
        -:  822:      276,  276,  276,  272,  272,  272,  272,  272,  272,  276,
        -:  823:
        -:  824:      276,  276,  276,  276,  276,  276,  276,  276,  276,  276,
        -:  825:      276,  276,  276,  276,  276,  276,  276,  279,  276,  276,
        -:  826:      276,  117,  105,  103,  102,  276,  101,   98,  276,  276,
        -:  827:      276,  276,  276,  276,  276,  276,  276,   97,   96,   93,
        -:  828:       88,  276,  276,   83,   82,   73,   62,   60,  276,  276,
        -:  829:      276,  276,  276,  276,   58,  285,   56,   56,   54,   54,
        -:  830:      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
        -:  831:      285,  285,  276,   45,   45,   45,   45,   45,   45,   45,
        -:  832:       45,   45,   45,   45,   45,   45,   49,   49,   49,   49,
        -:  833:       49,   49,   49,   49,   49,   49,   49,   49,   49,   53,
        -:  834:
        -:  835:       53,   53,   53,   53,   53,   53,   53,   53,   53,   53,
        -:  836:       53,   53,   55,   55,   55,   55,   55,   55,   55,   55,
        -:  837:       55,   55,   55,   55,   55,   57,   57,   57,   57,   57,
        -:  838:       59,  285,   59,   59,   59,   61,  285,  285,   61,  285,
        -:  839:       61,   61,   61,   66,  285,   66,  285,  285,  285,   66,
        -:  840:       76,  285,   76,   76,   76,   77,  285,   77,   77,   77,
        -:  841:      104,  104,  285,  285,  285,  104,  104,  285,  104,  106,
        -:  842:      106,  285,  285,  106,  106,  106,  106,  106,  106,  106,
        -:  843:      106,  107,  107,  107,  107,  107,  107,  107,  107,  107,
        -:  844:      107,  107,  107,  107,  113,  113,  285,  113,  113,  113,
        -:  845:
        -:  846:      285,  113,  113,  113,  113,  113,  116,  116,  285,  116,
        -:  847:      116,  116,  116,  116,  116,  116,  116,  116,  116,  118,
        -:  848:      118,  118,  285,  118,  118,  118,  118,  118,  118,  118,
        -:  849:      118,  118,  120,  120,  285,  120,  120,  120,  120,  120,
        -:  850:      120,  120,  120,  120,  120,  124,  285,  124,  154,  285,
        -:  851:      154,  177,  177,  177,  177,  177,  177,  177,  177,  177,
        -:  852:      177,  177,  177,  177,  179,  179,  179,  179,  179,  179,
        -:  853:      179,  179,  179,  179,  179,  179,  179,  183,  285,  183,
        -:  854:      199,  199,  199,  199,  199,  199,  199,  199,  199,  199,
        -:  855:      199,  199,  199,  215,  215,  215,  215,  215,  215,  215,
        -:  856:
        -:  857:      215,  215,  215,  215,  215,  215,  265,  265,  265,  265,
        -:  858:      265,  265,  265,  265,  265,  265,  265,  265,  265,   11,
        -:  859:      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
        -:  860:      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
        -:  861:      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
        -:  862:      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
        -:  863:      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
        -:  864:      285,  285,  285,  285,  285,  285
        -:  865:    } ;
        -:  866:
        -:  867:static const flex_int16_t yy_chk[1077] =
        -:  868:    {   0,
        -:  869:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  870:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  871:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  872:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  873:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  874:        1,    1,    1,    1,    1,    1,    3,    4,    5,    3,
        -:  875:        4,    6,   20,   21,   20,   23,   23,    5,   36,   22,
        -:  876:        6,   25,   25,   33,   33,   34,  281,   36,   90,   34,
        -:  877:       21,   21,   31,    3,    4,    5,   22,   22,    6,   48,
        -:  878:       31,   28,   90,   28,   31,   93,   21,   28,   28,   31,
        -:  879:
        -:  880:       40,   51,   22,  104,   21,   79,  273,   40,   51,   93,
        -:  881:       22,  266,  129,   48,   65,   65,   65,   65,   65,   65,
        -:  882:       65,   65,  105,   79,  105,  129,   48,  138,  178,  138,
        -:  883:      178,   48,  138,  263,  256,   48,   69,   69,   69,   69,
        -:  884:       69,   69,  181,  201,  181,  201,  252,  104,  121,  121,
        -:  885:      121,  121,  121,  121,  121,  121,  123,  123,  123,  123,
        -:  886:      123,  123,  153,  153,  153,  216,  221,  216,  221,  153,
        -:  887:      243,  241,  153,  153,  153,  153,  153,  153,  153,  153,
        -:  888:      153,  232,  237,  232,  237,  153,  153,  240,  247,  240,
        -:  889:      247,  233,  153,  153,  153,  153,  153,  153,  246,  253,
        -:  890:
        -:  891:      228,  253,  246,  255,  260,  255,  260,  267,  268,  267,
        -:  892:      268,  274,  277,  274,  277,  227,  153,  179,  179,  179,
        -:  893:      278,  282,  278,  282,  179,  226,  225,  179,  179,  179,
        -:  894:      179,  179,  179,  179,  179,  179,  283,  224,  283,  223,
        -:  895:      179,  179,  215,  214,  213,  211,  209,  179,  179,  179,
        -:  896:      179,  179,  179,  206,  205,  204,  203,  202,  199,  198,
        -:  897:      197,  196,  195,  194,  193,  192,  191,  190,  189,  187,
        -:  898:      186,  179,  200,  200,  200,  200,  200,  200,  200,  200,
        -:  899:      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
        -:  900:      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
        -:  901:
        -:  902:      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
        -:  903:      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
        -:  904:      200,  200,  200,  200,  200,  200,  200,  200,  219,  219,
        -:  905:      219,  185,  177,  173,  171,  219,  219,  170,  219,  219,
        -:  906:      219,  219,  219,  219,  219,  219,  219,  168,  167,  166,
        -:  907:      165,  219,  219,  164,  163,  162,  161,  160,  219,  219,
        -:  908:      219,  219,  219,  219,  159,  158,  157,  156,  155,  152,
        -:  909:      149,  148,  147,  146,  145,  144,  143,  141,  140,  139,
        -:  910:      137,  136,  219,  220,  220,  220,  220,  220,  220,  220,
        -:  911:      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
        -:  912:
        -:  913:      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
        -:  914:      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
        -:  915:      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
        -:  916:      220,  220,  220,  220,  220,  220,  220,  220,  220,  234,
        -:  917:      234,  234,  234,  234,  234,  234,  234,  234,  234,  234,
        -:  918:      234,  234,  234,  234,  234,  234,  234,  234,  234,  234,
        -:  919:      234,  234,  234,  234,  234,  234,  234,  234,  234,  234,
        -:  920:      234,  234,  234,  234,  234,  234,  234,  234,  234,  234,
        -:  921:      234,  234,  234,  234,  234,  234,  234,  234,  234,  234,
        -:  922:      234,  234,  234,  234,  234,  236,  236,  236,  135,  134,
        -:  923:
        -:  924:      132,  131,  236,  236,  130,  236,  236,  236,  236,  236,
        -:  925:      236,  236,  236,  236,  128,  114,  103,  102,  236,  236,
        -:  926:      101,  100,   99,   98,   97,  236,  236,  236,  236,  236,
        -:  927:      236,   96,   92,   91,   89,   88,   87,   86,   85,   84,
        -:  928:       83,   82,   80,   78,   68,   67,   61,   57,   56,  236,
        -:  929:      239,  239,  239,  239,  239,  239,  239,  239,  239,  239,
        -:  930:      239,  239,  239,  239,  239,  239,  239,  239,  239,  239,
        -:  931:      239,  239,  239,  239,  239,  239,  239,  239,  239,  239,
        -:  932:      239,  239,  239,  239,  239,  239,  239,  239,  239,  239,
        -:  933:      239,  239,  239,  239,  239,  239,  239,  239,  239,  239,
        -:  934:
        -:  935:      239,  239,  239,  239,  239,  239,  257,  257,  257,  257,
        -:  936:      257,  257,  257,  257,  257,  257,  257,  257,  257,  257,
        -:  937:      257,  257,  257,  257,  257,  257,  257,  257,  257,  257,
        -:  938:      257,  257,  257,  257,  257,  257,  257,  257,  257,  257,
        -:  939:      257,  257,  257,  257,  257,  257,  257,  257,  257,  257,
        -:  940:      257,  257,  257,  257,  257,  257,  257,  257,  257,  257,
        -:  941:      257,  257,  259,  259,  259,  259,  259,  259,  259,  259,
        -:  942:      259,  259,  259,  259,  259,  259,  259,  259,  259,  259,
        -:  943:      259,  259,  259,  259,  259,  259,  259,  259,  259,  259,
        -:  944:      259,  259,  259,  259,  259,  259,  259,  259,  259,  259,
        -:  945:
        -:  946:      259,  259,  259,  259,  259,  259,  259,  259,  259,  259,
        -:  947:      259,  259,  259,  259,  259,  259,  259,  259,  265,  265,
        -:  948:      265,   52,   44,   43,   42,  265,   41,   39,  265,  265,
        -:  949:      265,  265,  265,  265,  265,  265,  265,   38,   37,   35,
        -:  950:       32,  265,  265,   30,   29,   24,   19,   18,  265,  265,
        -:  951:      265,  265,  265,  265,   15,   11,   10,    9,    8,    7,
        -:  952:        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        -:  953:        0,    0,  265,  286,  286,  286,  286,  286,  286,  286,
        -:  954:      286,  286,  286,  286,  286,  286,  287,  287,  287,  287,
        -:  955:      287,  287,  287,  287,  287,  287,  287,  287,  287,  288,
        -:  956:
        -:  957:      288,  288,  288,  288,  288,  288,  288,  288,  288,  288,
        -:  958:      288,  288,  289,  289,  289,  289,  289,  289,  289,  289,
        -:  959:      289,  289,  289,  289,  289,  290,  290,  290,  290,  290,
        -:  960:      291,    0,  291,  291,  291,  292,    0,    0,  292,    0,
        -:  961:      292,  292,  292,  293,    0,  293,    0,    0,    0,  293,
        -:  962:      294,    0,  294,  294,  294,  295,    0,  295,  295,  295,
        -:  963:      296,  296,    0,    0,    0,  296,  296,    0,  296,  297,
        -:  964:      297,    0,    0,  297,  297,  297,  297,  297,  297,  297,
        -:  965:      297,  298,  298,  298,  298,  298,  298,  298,  298,  298,
        -:  966:      298,  298,  298,  298,  299,  299,    0,  299,  299,  299,
        -:  967:
        -:  968:        0,  299,  299,  299,  299,  299,  300,  300,    0,  300,
        -:  969:      300,  300,  300,  300,  300,  300,  300,  300,  300,  301,
        -:  970:      301,  301,    0,  301,  301,  301,  301,  301,  301,  301,
        -:  971:      301,  301,  302,  302,    0,  302,  302,  302,  302,  302,
        -:  972:      302,  302,  302,  302,  302,  303,    0,  303,  304,    0,
        -:  973:      304,  305,  305,  305,  305,  305,  305,  305,  305,  305,
        -:  974:      305,  305,  305,  305,  306,  306,  306,  306,  306,  306,
        -:  975:      306,  306,  306,  306,  306,  306,  306,  307,    0,  307,
        -:  976:      308,  308,  308,  308,  308,  308,  308,  308,  308,  308,
        -:  977:      308,  308,  308,  309,  309,  309,  309,  309,  309,  309,
        -:  978:
        -:  979:      309,  309,  309,  309,  309,  309,  310,  310,  310,  310,
        -:  980:      310,  310,  310,  310,  310,  310,  310,  310,  310,  285,
        -:  981:      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
        -:  982:      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
        -:  983:      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
        -:  984:      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
        -:  985:      285,  285,  285,  285,  285,  285,  285,  285,  285,  285,
        -:  986:      285,  285,  285,  285,  285,  285
        -:  987:    } ;
        -:  988:
        -:  989:/* Table of booleans, true if rule could match eol. */
        -:  990:static const flex_int32_t yy_rule_can_match_eol[76] =
        -:  991:    {   0,
        -:  992:0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
        -:  993:    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
        -:  994:    1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
        -:  995:    0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,     };
        -:  996:
        -:  997:/* The intent behind this definition is that it'll catch
        -:  998: * any uses of REJECT which flex missed.
        -:  999: */
        -: 1000:#define REJECT reject_used_but_not_detected
        -: 1001:#define yymore() yymore_used_but_not_detected
        -: 1002:#define YY_MORE_ADJ 0
        -: 1003:#define YY_RESTORE_YY_MORE_OFFSET
        -: 1004:#line 1 "lexer.l"
        -: 1005:/*
        -: 1006:Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.
        -: 1007:
        -: 1008:Redistribution and use in source and binary forms, with or without modification,
        -: 1009:are permitted provided that the following conditions are met:
        -: 1010:
        -: 1011:1. Redistributions of source code must retain the above copyright notice, this
        -: 1012:list of conditions and the following disclaimer.
        -: 1013:
        -: 1014:2. Redistributions in binary form must reproduce the above copyright notice,
        -: 1015:this list of conditions and the following disclaimer in the documentation and/or
        -: 1016:other materials provided with the distribution.
        -: 1017:
        -: 1018:3. Neither the name of the copyright holder nor the names of its contributors
        -: 1019:may be used to endorse or promote products derived from this software without
        -: 1020:specific prior written permission.
        -: 1021:
        -: 1022:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -: 1023:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -: 1024:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -: 1025:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -: 1026:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -: 1027:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -: 1028:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -: 1029:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -: 1030:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -: 1031:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -: 1032:*/
        -: 1033:/* Lexical analyzer for YARA */
        -: 1034:#line 33 "lexer.l"
        -: 1035:
        -: 1036:/* Disable warnings for unused functions in this file.
        -: 1037:
        -: 1038:As we redefine YY_FATAL_ERROR macro to use our own function yara_yyfatal, the
        -: 1039:yy_fatal_error function generated by Flex is not actually used, causing a
        -: 1040:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -: 1041:function. When they include something like %option noyy_fatal_error as they do
        -: 1042:with noyywrap then we can remove this pragma.
        -: 1043:*/
        -: 1044:
        -: 1045:#ifdef __GNUC__
        -: 1046:#pragma GCC diagnostic ignored "-Wunused-function"
        -: 1047:#endif
        -: 1048:
        -: 1049:#include <math.h>
        -: 1050:#include <stdarg.h>
        -: 1051:#include <stdio.h>
        -: 1052:#include <stdlib.h>
        -: 1053:#include <string.h>
        -: 1054:#include <setjmp.h>
        -: 1055:
        -: 1056:#if defined(_WIN32) || defined(__CYGWIN__)
        -: 1057:#include <windows.h>
        -: 1058:#else
        -: 1059:#include <sys/stat.h>
        -: 1060:#include <unistd.h>
        -: 1061:#endif
        -: 1062:
        -: 1063:#if defined(_WIN32)
        -: 1064:#define strtoll _strtoi64
        -: 1065:#endif
        -: 1066:
        -: 1067:#include <yara/integers.h>
        -: 1068:#include <yara/lexer.h>
        -: 1069:#include <yara/sizedstr.h>
        -: 1070:#include <yara/error.h>
        -: 1071:#include <yara/mem.h>
        -: 1072:#include <yara/utils.h>
        -: 1073:#include <yara/strutils.h>
        -: 1074:
        -: 1075:#include "grammar.h"
        -: 1076:
        -: 1077:#define error(error_code) \
        -: 1078:    { \
        -: 1079:      compiler->last_error = error_code; \
        -: 1080:      yyerror(yyscanner, compiler, NULL); \
        -: 1081:      yyterminate(); \
        -: 1082:    }
        -: 1083:
        -: 1084:#define syntax_error(error_msg) \
        -: 1085:    { \
        -: 1086:      yr_compiler_set_error_extra_info(compiler, error_msg); \
        -: 1087:      error(ERROR_SYNTAX_ERROR); \
        -: 1088:    }
        -: 1089:
        -: 1090:#define lex_check_space_ok(data, current_size, max_length) \
        -: 1091:    if (strlen(data) + current_size >= max_length - 1) \
        -: 1092:    { \
        -: 1093:      yyerror(yyscanner, compiler, "out of space in lex_buf"); \
        -: 1094:      yyterminate(); \
        -: 1095:    }
        -: 1096:
        -: 1097:#define yytext_to_buffer \
        -: 1098:    { \
        -: 1099:      char *yptr = yytext; \
        -: 1100:      lex_check_space_ok(yptr, yyextra->lex_buf_len, YR_LEX_BUF_SIZE); \
        -: 1101:      while(*yptr) \
        -: 1102:      { \
        -: 1103:        *yyextra->lex_buf_ptr++ = *yptr++; \
        -: 1104:        yyextra->lex_buf_len++; \
        -: 1105:      } \
        -: 1106:    }
        -: 1107:
        -: 1108:#define alloc_sized_string(str, str_len) \
        -: 1109:  SIZED_STRING* str = (SIZED_STRING*) yr_malloc( \
        -: 1110:      str_len + sizeof(SIZED_STRING)); \
        -: 1111:  if (str == NULL) \
        -: 1112:  { \
        -: 1113:    yyerror(yyscanner, compiler, "not enough memory"); \
        -: 1114:    yyterminate(); \
        -: 1115:  } \
        -: 1116:  else \
        -: 1117:  { \
        -: 1118:    str->length = (uint32_t) (str_len); \
        -: 1119:    str->flags = 0; \
        -: 1120:  } \
        -: 1121:
        -: 1122:#ifdef _WIN32
        -: 1123:#define snprintf _snprintf
        -: 1124:#endif
        -: 1125:
        -: 1126:static bool is_absolute_path(
        -: 1127:    char* path)
        -: 1128:{
        -: 1129:  if (path == NULL)
        -: 1130:    return false;
        -: 1131:
        -: 1132:  #if defined(_WIN32) || defined(__CYGWIN__)
        -: 1133:  return strlen(path) > 2 &&
        -: 1134:      path[1] == ':' && (path[2] == '/' || path[2] == '\\');
        -: 1135:  #else
        -: 1136:  return strlen(path) > 0 && path[0] == '/';
        -: 1137:  #endif
        -: 1138:}
        -: 1139:
        -: 1140:#line 1141 "lexer.c"
        -: 1141:#define YY_NO_UNISTD_H 1
        -: 1142:#define YY_NO_INPUT 1
        -: 1143:
        -: 1144:#line 1145 "lexer.c"
        -: 1145:
        -: 1146:#define INITIAL 0
        -: 1147:#define str 1
        -: 1148:#define regexp 2
        -: 1149:#define include 3
        -: 1150:#define comment 4
        -: 1151:
        -: 1152:#ifndef YY_NO_UNISTD_H
        -: 1153:/* Special case for "unistd.h", since it is non-ANSI. We include it way
        -: 1154: * down here because we want the user's section 1 to have been scanned first.
        -: 1155: * The user has a chance to override it with an option.
        -: 1156: */
        -: 1157:#include <unistd.h>
        -: 1158:#endif
        -: 1159:
        -: 1160:#ifndef YY_EXTRA_TYPE
        -: 1161:#define YY_EXTRA_TYPE void *
        -: 1162:#endif
        -: 1163:
        -: 1164:/* Holds the entire state of the reentrant scanner. */
        -: 1165:struct yyguts_t
        -: 1166:    {
        -: 1167:
        -: 1168:    /* User-defined. Not touched by flex. */
        -: 1169:    YY_EXTRA_TYPE yyextra_r;
        -: 1170:
        -: 1171:    /* The rest are the same as the globals declared in the non-reentrant scanner. */
        -: 1172:    FILE *yyin_r, *yyout_r;
        -: 1173:    size_t yy_buffer_stack_top; /**< index of top of stack. */
        -: 1174:    size_t yy_buffer_stack_max; /**< capacity of stack. */
        -: 1175:    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
        -: 1176:    char yy_hold_char;
        -: 1177:    int yy_n_chars;
        -: 1178:    int yyleng_r;
        -: 1179:    char *yy_c_buf_p;
        -: 1180:    int yy_init;
        -: 1181:    int yy_start;
        -: 1182:    int yy_did_buffer_switch_on_eof;
        -: 1183:    int yy_start_stack_ptr;
        -: 1184:    int yy_start_stack_depth;
        -: 1185:    int *yy_start_stack;
        -: 1186:    yy_state_type yy_last_accepting_state;
        -: 1187:    char* yy_last_accepting_cpos;
        -: 1188:
        -: 1189:    int yylineno_r;
        -: 1190:    int yy_flex_debug_r;
        -: 1191:
        -: 1192:    char *yytext_r;
        -: 1193:    int yy_more_flag;
        -: 1194:    int yy_more_len;
        -: 1195:
        -: 1196:    YYSTYPE * yylval_r;
        -: 1197:
        -: 1198:    }; /* end struct yyguts_t */
        -: 1199:
        -: 1200:static int yy_init_globals ( yyscan_t yyscanner );
        -: 1201:
        -: 1202:    /* This must go here because YYSTYPE and YYLTYPE are included
        -: 1203:     * from bison output in section 1.*/
        -: 1204:    #    define yylval yyg->yylval_r
        -: 1205:    
        -: 1206:int yylex_init (yyscan_t* scanner);
        -: 1207:
        -: 1208:int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);
        -: 1209:
        -: 1210:/* Accessor methods to globals.
        -: 1211:   These are made visible to non-reentrant scanners for convenience. */
        -: 1212:
        -: 1213:int yylex_destroy ( yyscan_t yyscanner );
        -: 1214:
        -: 1215:int yyget_debug ( yyscan_t yyscanner );
        -: 1216:
        -: 1217:void yyset_debug ( int debug_flag , yyscan_t yyscanner );
        -: 1218:
        -: 1219:YY_EXTRA_TYPE yyget_extra ( yyscan_t yyscanner );
        -: 1220:
        -: 1221:void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t yyscanner );
        -: 1222:
        -: 1223:FILE *yyget_in ( yyscan_t yyscanner );
        -: 1224:
        -: 1225:void yyset_in  ( FILE * _in_str , yyscan_t yyscanner );
        -: 1226:
        -: 1227:FILE *yyget_out ( yyscan_t yyscanner );
        -: 1228:
        -: 1229:void yyset_out  ( FILE * _out_str , yyscan_t yyscanner );
        -: 1230:
        -: 1231:			int yyget_leng ( yyscan_t yyscanner );
        -: 1232:
        -: 1233:char *yyget_text ( yyscan_t yyscanner );
        -: 1234:
        -: 1235:int yyget_lineno ( yyscan_t yyscanner );
        -: 1236:
        -: 1237:void yyset_lineno ( int _line_number , yyscan_t yyscanner );
        -: 1238:
        -: 1239:int yyget_column  ( yyscan_t yyscanner );
        -: 1240:
        -: 1241:void yyset_column ( int _column_no , yyscan_t yyscanner );
        -: 1242:
        -: 1243:YYSTYPE * yyget_lval ( yyscan_t yyscanner );
        -: 1244:
        -: 1245:void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );
        -: 1246:
        -: 1247:/* Macros after this point can all be overridden by user definitions in
        -: 1248: * section 1.
        -: 1249: */
        -: 1250:
        -: 1251:#ifndef YY_SKIP_YYWRAP
        -: 1252:#ifdef __cplusplus
        -: 1253:extern "C" int yywrap ( yyscan_t yyscanner );
        -: 1254:#else
        -: 1255:extern int yywrap ( yyscan_t yyscanner );
        -: 1256:#endif
        -: 1257:#endif
        -: 1258:
        -: 1259:#ifndef YY_NO_UNPUT
        -: 1260:    
        -: 1261:#endif
        -: 1262:
        -: 1263:#ifndef yytext_ptr
        -: 1264:static void yy_flex_strncpy ( char *, const char *, int , yyscan_t yyscanner);
        -: 1265:#endif
        -: 1266:
        -: 1267:#ifdef YY_NEED_STRLEN
        -: 1268:static int yy_flex_strlen ( const char * , yyscan_t yyscanner);
        -: 1269:#endif
        -: 1270:
        -: 1271:#ifndef YY_NO_INPUT
        -: 1272:#ifdef __cplusplus
        -: 1273:static int yyinput ( yyscan_t yyscanner );
        -: 1274:#else
        -: 1275:static int input ( yyscan_t yyscanner );
        -: 1276:#endif
        -: 1277:
        -: 1278:#endif
        -: 1279:
        -: 1280:/* Amount of stuff to slurp up with each read. */
        -: 1281:#ifndef YY_READ_BUF_SIZE
        -: 1282:#ifdef __ia64__
        -: 1283:/* On IA-64, the buffer size is 16k, not 8k */
        -: 1284:#define YY_READ_BUF_SIZE 16384
        -: 1285:#else
        -: 1286:#define YY_READ_BUF_SIZE 8192
        -: 1287:#endif /* __ia64__ */
        -: 1288:#endif
        -: 1289:
        -: 1290:/* Copy whatever the last rule matched to the standard output. */
        -: 1291:#ifndef ECHO
        -: 1292:/* This used to be an fputs(), but since the string might contain NUL's,
        -: 1293: * we now use fwrite().
        -: 1294: */
        -: 1295:#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
        -: 1296:#endif
        -: 1297:
        -: 1298:/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
        -: 1299: * is returned in "result".
        -: 1300: */
        -: 1301:#ifndef YY_INPUT
        -: 1302:#define YY_INPUT(buf,result,max_size) \
        -: 1303:	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
        -: 1304:		{ \
        -: 1305:		int c = '*'; \
        -: 1306:		int n; \
        -: 1307:		for ( n = 0; n < max_size && \
        -: 1308:			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
        -: 1309:			buf[n] = (char) c; \
        -: 1310:		if ( c == '\n' ) \
        -: 1311:			buf[n++] = (char) c; \
        -: 1312:		if ( c == EOF && ferror( yyin ) ) \
        -: 1313:			YY_FATAL_ERROR( "input in flex scanner failed" ); \
        -: 1314:		result = n; \
        -: 1315:		} \
        -: 1316:	else \
        -: 1317:		{ \
        -: 1318:		errno=0; \
        -: 1319:		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
        -: 1320:			{ \
        -: 1321:			if( errno != EINTR) \
        -: 1322:				{ \
        -: 1323:				YY_FATAL_ERROR( "input in flex scanner failed" ); \
        -: 1324:				break; \
        -: 1325:				} \
        -: 1326:			errno=0; \
        -: 1327:			clearerr(yyin); \
        -: 1328:			} \
        -: 1329:		}\
        -: 1330:\
        -: 1331:
        -: 1332:#endif
        -: 1333:
        -: 1334:/* No semi-colon after return; correct usage is to write "yyterminate();" -
        -: 1335: * we don't want an extra ';' after the "return" because that will cause
        -: 1336: * some compilers to complain about unreachable statements.
        -: 1337: */
        -: 1338:#ifndef yyterminate
        -: 1339:#define yyterminate() return YY_NULL
        -: 1340:#endif
        -: 1341:
        -: 1342:/* Number of entries by which start-condition stack grows. */
        -: 1343:#ifndef YY_START_STACK_INCR
        -: 1344:#define YY_START_STACK_INCR 25
        -: 1345:#endif
        -: 1346:
        -: 1347:/* Report a fatal error. */
        -: 1348:#ifndef YY_FATAL_ERROR
        -: 1349:#define YY_FATAL_ERROR(msg) yy_fatal_error( msg , yyscanner)
        -: 1350:#endif
        -: 1351:
        -: 1352:/* end tables serialization structures and prototypes */
        -: 1353:
        -: 1354:/* Default declaration of generated scanner - a define so the user can
        -: 1355: * easily add parameters.
        -: 1356: */
        -: 1357:#ifndef YY_DECL
        -: 1358:#define YY_DECL_IS_OURS 1
        -: 1359:
        -: 1360:extern int yylex \
        -: 1361:               (YYSTYPE * yylval_param , yyscan_t yyscanner);
        -: 1362:
        -: 1363:#define YY_DECL int yylex \
        -: 1364:               (YYSTYPE * yylval_param , yyscan_t yyscanner)
        -: 1365:#endif /* !YY_DECL */
        -: 1366:
        -: 1367:/* Code executed at the beginning of each rule, after yytext and yyleng
        -: 1368: * have been set up.
        -: 1369: */
        -: 1370:#ifndef YY_USER_ACTION
        -: 1371:#define YY_USER_ACTION
        -: 1372:#endif
        -: 1373:
        -: 1374:/* Code executed at the end of each rule. */
        -: 1375:#ifndef YY_BREAK
        -: 1376:#define YY_BREAK /*LINTED*/break;
        -: 1377:#endif
        -: 1378:
        -: 1379:#define YY_RULE_SETUP \
        -: 1380:	YY_USER_ACTION
        -: 1381:
        -: 1382:/** The main scanner function which does all the work.
        -: 1383: */
    #####: 1384:YY_DECL
        -: 1385:{
        -: 1386:	yy_state_type yy_current_state;
        -: 1387:	char *yy_cp, *yy_bp;
        -: 1388:	int yy_act;
    #####: 1389:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 1390:
    #####: 1391:    yylval = yylval_param;
        -: 1392:
    #####: 1393:	if ( !yyg->yy_init )
        -: 1394:		{
    #####: 1395:		yyg->yy_init = 1;
        -: 1396:
        -: 1397:#ifdef YY_USER_INIT
        -: 1398:		YY_USER_INIT;
        -: 1399:#endif
        -: 1400:
    #####: 1401:		if ( ! yyg->yy_start )
    #####: 1402:			yyg->yy_start = 1;	/* first start state */
        -: 1403:
    #####: 1404:		if ( ! yyin )
    #####: 1405:			yyin = stdin;
        -: 1406:
    #####: 1407:		if ( ! yyout )
    #####: 1408:			yyout = stdout;
        -: 1409:
    #####: 1410:		if ( ! YY_CURRENT_BUFFER ) {
    #####: 1411:			yyensure_buffer_stack (yyscanner);
    #####: 1412:			YY_CURRENT_BUFFER_LVALUE =
    #####: 1413:				yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
        -: 1414:		}
        -: 1415:
    #####: 1416:		yy_load_buffer_state( yyscanner );
        -: 1417:		}
        -: 1418:
        -: 1419:	{
        -: 1420:#line 163 "lexer.l"
        -: 1421:
        -: 1422:
        -: 1423:#line 1424 "lexer.c"
        -: 1424:
        -: 1425:	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
        -: 1426:		{
    #####: 1427:		yy_cp = yyg->yy_c_buf_p;
        -: 1428:
        -: 1429:		/* Support of yytext. */
    #####: 1430:		*yy_cp = yyg->yy_hold_char;
        -: 1431:
        -: 1432:		/* yy_bp points to the position in yy_ch_buf of the start of
        -: 1433:		 * the current run.
        -: 1434:		 */
    #####: 1435:		yy_bp = yy_cp;
        -: 1436:
    #####: 1437:		yy_current_state = yyg->yy_start;
    #####: 1438:yy_match:
        -: 1439:		do
        -: 1440:			{
    #####: 1441:			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
    #####: 1442:			if ( yy_accept[yy_current_state] )
        -: 1443:				{
    #####: 1444:				yyg->yy_last_accepting_state = yy_current_state;
    #####: 1445:				yyg->yy_last_accepting_cpos = yy_cp;
        -: 1446:				}
    #####: 1447:			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        -: 1448:				{
    #####: 1449:				yy_current_state = (int) yy_def[yy_current_state];
    #####: 1450:				if ( yy_current_state >= 286 )
    #####: 1451:					yy_c = yy_meta[yy_c];
        -: 1452:				}
    #####: 1453:			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    #####: 1454:			++yy_cp;
        -: 1455:			}
    #####: 1456:		while ( yy_current_state != 285 );
    #####: 1457:		yy_cp = yyg->yy_last_accepting_cpos;
    #####: 1458:		yy_current_state = yyg->yy_last_accepting_state;
        -: 1459:
    #####: 1460:yy_find_action:
    #####: 1461:		yy_act = yy_accept[yy_current_state];
        -: 1462:
    #####: 1463:		YY_DO_BEFORE_ACTION;
        -: 1464:
    #####: 1465:		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
        -: 1466:			{
        -: 1467:			int yyl;
    #####: 1468:			for ( yyl = 0; yyl < yyleng; ++yyl )
    #####: 1469:				if ( yytext[yyl] == '\n' )
        -: 1470:					
    #####: 1471:    do{ yylineno++;
    #####: 1472:        yycolumn=0;
        -: 1473:    }while(0)
        -: 1474:;
        -: 1475:			}
        -: 1476:
    #####: 1477:do_action:	/* This label is used only to access EOF actions. */
        -: 1478:
    #####: 1479:		switch ( yy_act )
        -: 1480:	{ /* beginning of action switch */
    #####: 1481:			case 0: /* must back up */
        -: 1482:			/* undo the effects of YY_DO_BEFORE_ACTION */
    #####: 1483:			*yy_cp = yyg->yy_hold_char;
    #####: 1484:			yy_cp = yyg->yy_last_accepting_cpos;
    #####: 1485:			yy_current_state = yyg->yy_last_accepting_state;
    #####: 1486:			goto yy_find_action;
        -: 1487:
    #####: 1488:case 1:
        -: 1489:YY_RULE_SETUP
        -: 1490:#line 165 "lexer.l"
        -: 1491:{ return _DOT_DOT_;     }
        -: 1492:	YY_BREAK
        -: 1493:case 2:
        -: 1494:YY_RULE_SETUP
        -: 1495:#line 166 "lexer.l"
        -: 1496:{ return _LT_;          }
        -: 1497:	YY_BREAK
        -: 1498:case 3:
        -: 1499:YY_RULE_SETUP
        -: 1500:#line 167 "lexer.l"
        -: 1501:{ return _GT_;          }
        -: 1502:	YY_BREAK
        -: 1503:case 4:
        -: 1504:YY_RULE_SETUP
        -: 1505:#line 168 "lexer.l"
        -: 1506:{ return _LE_;          }
        -: 1507:	YY_BREAK
        -: 1508:case 5:
        -: 1509:YY_RULE_SETUP
        -: 1510:#line 169 "lexer.l"
        -: 1511:{ return _GE_;          }
        -: 1512:	YY_BREAK
        -: 1513:case 6:
        -: 1514:YY_RULE_SETUP
        -: 1515:#line 170 "lexer.l"
        -: 1516:{ return _EQ_;          }
        -: 1517:	YY_BREAK
        -: 1518:case 7:
        -: 1519:YY_RULE_SETUP
        -: 1520:#line 171 "lexer.l"
        -: 1521:{ return _NEQ_;         }
        -: 1522:	YY_BREAK
        -: 1523:case 8:
        -: 1524:YY_RULE_SETUP
        -: 1525:#line 172 "lexer.l"
        -: 1526:{ return _SHIFT_LEFT_;  }
        -: 1527:	YY_BREAK
        -: 1528:case 9:
        -: 1529:YY_RULE_SETUP
        -: 1530:#line 173 "lexer.l"
        -: 1531:{ return _SHIFT_RIGHT_; }
        -: 1532:	YY_BREAK
        -: 1533:case 10:
        -: 1534:YY_RULE_SETUP
        -: 1535:#line 174 "lexer.l"
        -: 1536:{ return _PRIVATE_;     }
        -: 1537:	YY_BREAK
        -: 1538:case 11:
        -: 1539:YY_RULE_SETUP
        -: 1540:#line 175 "lexer.l"
        -: 1541:{ return _GLOBAL_;      }
        -: 1542:	YY_BREAK
        -: 1543:case 12:
        -: 1544:YY_RULE_SETUP
        -: 1545:#line 176 "lexer.l"
        -: 1546:{ return _RULE_;        }
        -: 1547:	YY_BREAK
        -: 1548:case 13:
        -: 1549:YY_RULE_SETUP
        -: 1550:#line 177 "lexer.l"
        -: 1551:{ return _META_;        }
        -: 1552:	YY_BREAK
        -: 1553:case 14:
        -: 1554:YY_RULE_SETUP
        -: 1555:#line 178 "lexer.l"
        -: 1556:{ return _STRINGS_;     }
        -: 1557:	YY_BREAK
        -: 1558:case 15:
        -: 1559:YY_RULE_SETUP
        -: 1560:#line 179 "lexer.l"
        -: 1561:{ return _ASCII_;       }
        -: 1562:	YY_BREAK
        -: 1563:case 16:
        -: 1564:YY_RULE_SETUP
        -: 1565:#line 180 "lexer.l"
        -: 1566:{ return _WIDE_;        }
        -: 1567:	YY_BREAK
        -: 1568:case 17:
        -: 1569:YY_RULE_SETUP
        -: 1570:#line 181 "lexer.l"
        -: 1571:{ return _XOR_;         }
        -: 1572:	YY_BREAK
        -: 1573:case 18:
        -: 1574:YY_RULE_SETUP
        -: 1575:#line 182 "lexer.l"
        -: 1576:{ return _FULLWORD_;    }
        -: 1577:	YY_BREAK
        -: 1578:case 19:
        -: 1579:YY_RULE_SETUP
        -: 1580:#line 183 "lexer.l"
        -: 1581:{ return _NOCASE_;      }
        -: 1582:	YY_BREAK
        -: 1583:case 20:
        -: 1584:YY_RULE_SETUP
        -: 1585:#line 184 "lexer.l"
        -: 1586:{ return _CONDITION_;   }
        -: 1587:	YY_BREAK
        -: 1588:case 21:
        -: 1589:YY_RULE_SETUP
        -: 1590:#line 185 "lexer.l"
        -: 1591:{ return _TRUE_;        }
        -: 1592:	YY_BREAK
        -: 1593:case 22:
        -: 1594:YY_RULE_SETUP
        -: 1595:#line 186 "lexer.l"
        -: 1596:{ return _FALSE_;       }
        -: 1597:	YY_BREAK
        -: 1598:case 23:
        -: 1599:YY_RULE_SETUP
        -: 1600:#line 187 "lexer.l"
        -: 1601:{ return _NOT_;         }
        -: 1602:	YY_BREAK
        -: 1603:case 24:
        -: 1604:YY_RULE_SETUP
        -: 1605:#line 188 "lexer.l"
        -: 1606:{ return _AND_;         }
        -: 1607:	YY_BREAK
        -: 1608:case 25:
        -: 1609:YY_RULE_SETUP
        -: 1610:#line 189 "lexer.l"
        -: 1611:{ return _OR_;          }
        -: 1612:	YY_BREAK
        -: 1613:case 26:
        -: 1614:YY_RULE_SETUP
        -: 1615:#line 190 "lexer.l"
        -: 1616:{ return _AT_;          }
        -: 1617:	YY_BREAK
        -: 1618:case 27:
        -: 1619:YY_RULE_SETUP
        -: 1620:#line 191 "lexer.l"
        -: 1621:{ return _IN_;          }
        -: 1622:	YY_BREAK
        -: 1623:case 28:
        -: 1624:YY_RULE_SETUP
        -: 1625:#line 192 "lexer.l"
        -: 1626:{ return _OF_;          }
        -: 1627:	YY_BREAK
        -: 1628:case 29:
        -: 1629:YY_RULE_SETUP
        -: 1630:#line 193 "lexer.l"
        -: 1631:{ return _THEM_;        }
        -: 1632:	YY_BREAK
        -: 1633:case 30:
        -: 1634:YY_RULE_SETUP
        -: 1635:#line 194 "lexer.l"
        -: 1636:{ return _FOR_;         }
        -: 1637:	YY_BREAK
        -: 1638:case 31:
        -: 1639:YY_RULE_SETUP
        -: 1640:#line 195 "lexer.l"
        -: 1641:{ return _ALL_;         }
        -: 1642:	YY_BREAK
        -: 1643:case 32:
        -: 1644:YY_RULE_SETUP
        -: 1645:#line 196 "lexer.l"
        -: 1646:{ return _ANY_;         }
        -: 1647:	YY_BREAK
        -: 1648:case 33:
        -: 1649:YY_RULE_SETUP
        -: 1650:#line 197 "lexer.l"
        -: 1651:{ return _ENTRYPOINT_;  }
        -: 1652:	YY_BREAK
        -: 1653:case 34:
        -: 1654:YY_RULE_SETUP
        -: 1655:#line 198 "lexer.l"
        -: 1656:{ return _FILESIZE_;    }
        -: 1657:	YY_BREAK
        -: 1658:case 35:
        -: 1659:YY_RULE_SETUP
        -: 1660:#line 199 "lexer.l"
        -: 1661:{ return _MATCHES_;     }
        -: 1662:	YY_BREAK
        -: 1663:case 36:
        -: 1664:YY_RULE_SETUP
        -: 1665:#line 200 "lexer.l"
        -: 1666:{ return _CONTAINS_;    }
        -: 1667:	YY_BREAK
        -: 1668:case 37:
        -: 1669:YY_RULE_SETUP
        -: 1670:#line 201 "lexer.l"
        -: 1671:{ return _IMPORT_;      }
        -: 1672:	YY_BREAK
        -: 1673:case 38:
        -: 1674:YY_RULE_SETUP
        -: 1675:#line 204 "lexer.l"
        -: 1676:{ BEGIN(comment);       }
        -: 1677:	YY_BREAK
        -: 1678:case 39:
        -: 1679:YY_RULE_SETUP
        -: 1680:#line 205 "lexer.l"
        -: 1681:{ BEGIN(INITIAL);       }
        -: 1682:	YY_BREAK
        -: 1683:case 40:
        -: 1684:/* rule 40 can match eol */
        -: 1685:YY_RULE_SETUP
        -: 1686:#line 206 "lexer.l"
        -: 1687:{ /* skip comments */   }
        -: 1688:	YY_BREAK
        -: 1689:case 41:
        -: 1690:YY_RULE_SETUP
        -: 1691:#line 209 "lexer.l"
        -: 1692:{ /* skip single-line comments */ }
        -: 1693:	YY_BREAK
        -: 1694:case 42:
        -: 1695:YY_RULE_SETUP
        -: 1696:#line 212 "lexer.l"
        -: 1697:{
        -: 1698:                          yyextra->lex_buf_ptr = yyextra->lex_buf;
        -: 1699:                          yyextra->lex_buf_len = 0;
        -: 1700:                          BEGIN(include);
        -: 1701:                        }
        -: 1702:	YY_BREAK
        -: 1703:case 43:
        -: 1704:/* rule 43 can match eol */
        -: 1705:YY_RULE_SETUP
        -: 1706:#line 219 "lexer.l"
        -: 1707:{ yytext_to_buffer; }
        -: 1708:	YY_BREAK
        -: 1709:case 44:
        -: 1710:YY_RULE_SETUP
        -: 1711:#line 222 "lexer.l"
        -: 1712:{
        -: 1713:
        -: 1714:  if (compiler->include_callback != NULL)
        -: 1715:  {
        -: 1716:    #ifdef _MSC_VER
        -: 1717:    char* b = NULL;
        -: 1718:    #endif
        -: 1719:    char* s = NULL;
        -: 1720:    char* f;
        -: 1721:
        -: 1722:    char buffer[1024];
        -: 1723:    const char* included_rules;
        -: 1724:    char* current_file_name;
        -: 1725:    char* include_path;
        -: 1726:
        -: 1727:    *yyextra->lex_buf_ptr = '\0'; // null-terminate included file path
        -: 1728:
        -: 1729:    current_file_name = yr_compiler_get_current_file_name(compiler);
        -: 1730:
        -: 1731:    if (current_file_name == NULL ||
        -: 1732:        compiler->include_callback != _yr_compiler_default_include_callback ||
        -: 1733:        is_absolute_path(yyextra->lex_buf))
        -: 1734:    {
        -: 1735:      include_path = yyextra->lex_buf;
        -: 1736:    }
        -: 1737:    else
        -: 1738:    {
        -: 1739:      strlcpy(buffer, current_file_name, sizeof(buffer));
        -: 1740:      s = strrchr(buffer, '/');
        -: 1741:
        -: 1742:      #ifdef _MSC_VER
        -: 1743:      b = strrchr(buffer, '\\'); // in Windows both path delimiters are accepted
        -: 1744:      #endif
        -: 1745:
        -: 1746:      #ifdef _MSC_VER
        -: 1747:      if (s != NULL || b != NULL)
        -: 1748:      #else
        -: 1749:      if (s != NULL)
        -: 1750:      #endif
        -: 1751:      {
        -: 1752:        #ifdef _MSC_VER
        -: 1753:        f = (b > s) ? (b + 1) : (s + 1);
        -: 1754:        #else
        -: 1755:        f = s + 1;
        -: 1756:        #endif
        -: 1757:
        -: 1758:        strlcpy(f, yyextra->lex_buf, sizeof(buffer) - (f - buffer));
        -: 1759:        include_path = buffer;
        -: 1760:      }
        -: 1761:      else
        -: 1762:      {
        -: 1763:        include_path = yyextra->lex_buf;
        -: 1764:      }
        -: 1765:    }
        -: 1766:
        -: 1767:    included_rules = compiler->include_callback(
        -: 1768:        include_path,
        -: 1769:        current_file_name,
        -: 1770:        compiler->current_namespace->name,
        -: 1771:        compiler->incl_clbk_user_data);
        -: 1772:
        -: 1773:    if (included_rules != NULL)
        -: 1774:    {
        -: 1775:      int error_code = _yr_compiler_push_file_name(compiler, include_path);
        -: 1776:
        -: 1777:      if (error_code != ERROR_SUCCESS)
        -: 1778:      {
        -: 1779:        if (error_code == ERROR_INCLUDES_CIRCULAR_REFERENCE)
        -: 1780:        {
        -: 1781:          yyerror(yyscanner, compiler, "includes circular reference");
        -: 1782:        }
        -: 1783:        else if (error_code == ERROR_INCLUDE_DEPTH_EXCEEDED)
        -: 1784:        {
        -: 1785:          yyerror(yyscanner, compiler, "includes depth exceeded");
        -: 1786:        }
        -: 1787:
        -: 1788:        if (compiler->include_free != NULL)
        -: 1789:        {
        -: 1790:          compiler->include_free(included_rules, compiler->incl_clbk_user_data);
        -: 1791:        }
        -: 1792:
        -: 1793:        yyterminate();
        -: 1794:      }
        -: 1795:
        -: 1796:      // Workaround for flex issue: https://github.com/westes/flex/issues/58
        -: 1797:      yypush_buffer_state(YY_CURRENT_BUFFER, yyscanner);
        -: 1798:      yy_scan_string(included_rules, yyscanner);
        -: 1799:      yyset_lineno(1, yyscanner);
        -: 1800:
        -: 1801:      if (compiler->include_free != NULL)
        -: 1802:      {
        -: 1803:        compiler->include_free(included_rules, compiler->incl_clbk_user_data);
        -: 1804:      }
        -: 1805:    }
        -: 1806:    else
        -: 1807:    {
        -: 1808:      char* err_msg_fmt;
        -: 1809:      char err_msg[512];
        -: 1810:
        -: 1811:      if (compiler->include_callback == _yr_compiler_default_include_callback)
        -: 1812:      {
        -: 1813:        err_msg_fmt = "can't open include file: %s";
        -: 1814:      }
        -: 1815:      else
        -: 1816:      {
        -: 1817:        err_msg_fmt = "callback failed to provide include resource: %s";
        -: 1818:      }
        -: 1819:
        -: 1820:      snprintf(
        -: 1821:          err_msg,
        -: 1822:          sizeof(err_msg),
        -: 1823:          err_msg_fmt,
        -: 1824:          yyextra->lex_buf);
        -: 1825:
        -: 1826:      yyerror(yyscanner, compiler, err_msg);
        -: 1827:    }
        -: 1828:
        -: 1829:  }
        -: 1830:  else // not allowing includes
        -: 1831:  {
        -: 1832:    yyerror(yyscanner, compiler, "includes are disabled");
        -: 1833:  }
        -: 1834:
        -: 1835:  BEGIN(INITIAL);
        -: 1836:}
        -: 1837:	YY_BREAK
        -: 1838:case YY_STATE_EOF(INITIAL):
        -: 1839:case YY_STATE_EOF(str):
        -: 1840:case YY_STATE_EOF(regexp):
        -: 1841:case YY_STATE_EOF(include):
        -: 1842:case YY_STATE_EOF(comment):
        -: 1843:#line 349 "lexer.l"
        -: 1844:{
        -: 1845:
        -: 1846:  yypop_buffer_state(yyscanner);
        -: 1847:
        -: 1848:  if (!YY_CURRENT_BUFFER)
        -: 1849:    yyterminate();
        -: 1850:
        -: 1851:  return _END_OF_INCLUDED_FILE_;
        -: 1852:}
        -: 1853:	YY_BREAK
        -: 1854:case 45:
        -: 1855:YY_RULE_SETUP
        -: 1856:#line 360 "lexer.l"
        -: 1857:{
        -: 1858:
        -: 1859:  yylval->c_string = yr_strdup(yytext);
        -: 1860:
        -: 1861:  if (yylval->c_string == NULL)
        -: 1862:    error(ERROR_INSUFFICIENT_MEMORY);
        -: 1863:
        -: 1864:  return _STRING_IDENTIFIER_WITH_WILDCARD_;
        -: 1865:}
        -: 1866:	YY_BREAK
        -: 1867:case 46:
        -: 1868:YY_RULE_SETUP
        -: 1869:#line 371 "lexer.l"
        -: 1870:{
        -: 1871:
        -: 1872:  yylval->c_string = yr_strdup(yytext);
        -: 1873:
        -: 1874:  if (yylval->c_string == NULL)
        -: 1875:    error(ERROR_INSUFFICIENT_MEMORY);
        -: 1876:
        -: 1877:  return _STRING_IDENTIFIER_;
        -: 1878:}
        -: 1879:	YY_BREAK
        -: 1880:case 47:
        -: 1881:YY_RULE_SETUP
        -: 1882:#line 382 "lexer.l"
        -: 1883:{
        -: 1884:
        -: 1885:  yylval->c_string = yr_strdup(yytext);
        -: 1886:
        -: 1887:  if (yylval->c_string == NULL)
        -: 1888:  {
        -: 1889:    error(ERROR_INSUFFICIENT_MEMORY);
        -: 1890:  }
        -: 1891:  else
        -: 1892:  {
        -: 1893:    yylval->c_string[0] = '$'; /* replace # by $*/
        -: 1894:  }
        -: 1895:
        -: 1896:  return _STRING_COUNT_;
        -: 1897:}
        -: 1898:	YY_BREAK
        -: 1899:case 48:
        -: 1900:YY_RULE_SETUP
        -: 1901:#line 399 "lexer.l"
        -: 1902:{
        -: 1903:
        -: 1904:  yylval->c_string = yr_strdup(yytext);
        -: 1905:
        -: 1906:  if (yylval->c_string == NULL)
        -: 1907:  {
        -: 1908:    error(ERROR_INSUFFICIENT_MEMORY);
        -: 1909:  }
        -: 1910:  else
        -: 1911:  {
        -: 1912:    yylval->c_string[0] = '$'; /* replace @ by $*/
        -: 1913:  }
        -: 1914:
        -: 1915:  return _STRING_OFFSET_;
        -: 1916:}
        -: 1917:	YY_BREAK
        -: 1918:case 49:
        -: 1919:YY_RULE_SETUP
        -: 1920:#line 416 "lexer.l"
        -: 1921:{
        -: 1922:
        -: 1923:  yylval->c_string = yr_strdup(yytext);
        -: 1924:
        -: 1925:  if (yylval->c_string == NULL)
        -: 1926:  {
        -: 1927:    error(ERROR_INSUFFICIENT_MEMORY);
        -: 1928:  }
        -: 1929:  else
        -: 1930:  {
        -: 1931:    yylval->c_string[0] = '$'; /* replace ! by $*/
        -: 1932:  }
        -: 1933:
        -: 1934:  return _STRING_LENGTH_;
        -: 1935:}
        -: 1936:	YY_BREAK
        -: 1937:case 50:
        -: 1938:YY_RULE_SETUP
        -: 1939:#line 433 "lexer.l"
        -: 1940:{
        -: 1941:
        -: 1942:  char* text = yytext;
        -: 1943:
        -: 1944:  if (*text == 'u')
        -: 1945:  {
        -: 1946:    yylval->integer = 3;
        -: 1947:    text++;
        -: 1948:  }
        -: 1949:  else
        -: 1950:  {
        -: 1951:    yylval->integer = 0;
        -: 1952:  }
        -: 1953:
        -: 1954:  if (strstr(text, "int8") == text)
        -: 1955:  {
        -: 1956:    yylval->integer += 0;
        -: 1957:    text += 4;
        -: 1958:  }
        -: 1959:  else if (strstr(text, "int16") == text)
        -: 1960:  {
        -: 1961:    yylval->integer += 1;
        -: 1962:    text += 5;
        -: 1963:  }
        -: 1964:  else if (strstr(text, "int32") == text)
        -: 1965:  {
        -: 1966:    yylval->integer += 2;
        -: 1967:    text += 5;
        -: 1968:  }
        -: 1969:
        -: 1970:  if (strcmp(text, "be") == 0)
        -: 1971:  {
        -: 1972:    yylval->integer += 6;
        -: 1973:  }
        -: 1974:
        -: 1975:  return _INTEGER_FUNCTION_;
        -: 1976:}
        -: 1977:	YY_BREAK
        -: 1978:case 51:
        -: 1979:YY_RULE_SETUP
        -: 1980:#line 472 "lexer.l"
        -: 1981:{
        -: 1982:
        -: 1983:  if (strlen(yytext) > 128)
        -: 1984:    syntax_error("identifier too long");
        -: 1985:
        -: 1986:  yylval->c_string = yr_strdup(yytext);
        -: 1987:
        -: 1988:  if (yylval->c_string == NULL)
        -: 1989:    error(ERROR_INSUFFICIENT_MEMORY);
        -: 1990:
        -: 1991:  return _IDENTIFIER_;
        -: 1992:}
        -: 1993:	YY_BREAK
        -: 1994:case 52:
        -: 1995:YY_RULE_SETUP
        -: 1996:#line 486 "lexer.l"
        -: 1997:{
        -: 1998:
        -: 1999:  char *endptr;
        -: 2000:
        -: 2001:  errno = 0;
        -: 2002:  yylval->integer = strtoll(yytext, &endptr, 10);
        -: 2003:
        -: 2004:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -: 2005:  {
        -: 2006:    yr_compiler_set_error_extra_info(compiler, yytext);
        -: 2007:    error(ERROR_INTEGER_OVERFLOW);
        -: 2008:  }
        -: 2009:  else if (strstr(yytext, "KB") != NULL)
        -: 2010:  {
        -: 2011:    if (yylval->integer > LLONG_MAX / 1024)
        -: 2012:    {
        -: 2013:      yr_compiler_set_error_extra_info(compiler, yytext);
        -: 2014:      error(ERROR_INTEGER_OVERFLOW);
        -: 2015:    }
        -: 2016:    else
        -: 2017:    {
        -: 2018:      yylval->integer *= 1024;
        -: 2019:    }
        -: 2020:  }
        -: 2021:  else if (strstr(yytext, "MB") != NULL)
        -: 2022:  {
        -: 2023:    if (yylval->integer > LLONG_MAX / 1048576)
        -: 2024:    {
        -: 2025:      yr_compiler_set_error_extra_info(compiler, yytext);
        -: 2026:      error(ERROR_INTEGER_OVERFLOW);
        -: 2027:    }
        -: 2028:    else
        -: 2029:    {
        -: 2030:      yylval->integer *= 1048576;
        -: 2031:    }
        -: 2032:  }
        -: 2033:
        -: 2034:  return _NUMBER_;
        -: 2035:}
        -: 2036:	YY_BREAK
        -: 2037:case 53:
        -: 2038:YY_RULE_SETUP
        -: 2039:#line 526 "lexer.l"
        -: 2040:{
        -: 2041:  yylval->double_ = atof(yytext);
        -: 2042:  return _DOUBLE_;
        -: 2043:}
        -: 2044:	YY_BREAK
        -: 2045:case 54:
        -: 2046:YY_RULE_SETUP
        -: 2047:#line 531 "lexer.l"
        -: 2048:{
        -: 2049:
        -: 2050:  char *endptr;
        -: 2051:
        -: 2052:  errno = 0;
        -: 2053:  yylval->integer = strtoll(yytext, &endptr, 16);
        -: 2054:
        -: 2055:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -: 2056:  {
        -: 2057:    yr_compiler_set_error_extra_info(compiler, yytext);
        -: 2058:    error(ERROR_INTEGER_OVERFLOW);
        -: 2059:  }
        -: 2060:
        -: 2061:  return _NUMBER_;
        -: 2062:}
        -: 2063:	YY_BREAK
        -: 2064:case 55:
        -: 2065:YY_RULE_SETUP
        -: 2066:#line 547 "lexer.l"
        -: 2067:{
        -: 2068:
        -: 2069:  char *endptr;
        -: 2070:
        -: 2071:  errno = 0;
        -: 2072:  yylval->integer = strtoll(yytext + 2, &endptr, 8);
        -: 2073:
        -: 2074:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -: 2075:  {
        -: 2076:    yr_compiler_set_error_extra_info(compiler, yytext);
        -: 2077:    error(ERROR_INTEGER_OVERFLOW);
        -: 2078:  }
        -: 2079:
        -: 2080:  return _NUMBER_;
        -: 2081:}
        -: 2082:	YY_BREAK
        -: 2083:case 56:
        -: 2084:YY_RULE_SETUP
        -: 2085:#line 564 "lexer.l"
        -: 2086:{     /* saw closing quote - all done */
        -: 2087:
        -: 2088:  alloc_sized_string(s, yyextra->lex_buf_len);
        -: 2089:
        -: 2090:  *yyextra->lex_buf_ptr = '\0';
        -: 2091:  memcpy(s->c_string, yyextra->lex_buf, yyextra->lex_buf_len + 1);
        -: 2092:  yylval->sized_string = s;
        -: 2093:
        -: 2094:  BEGIN(INITIAL);
        -: 2095:
        -: 2096:  return _TEXT_STRING_;
        -: 2097:}
        -: 2098:	YY_BREAK
        -: 2099:case 57:
        -: 2100:YY_RULE_SETUP
        -: 2101:#line 578 "lexer.l"
        -: 2102:{
        -: 2103:
        -: 2104:  lex_check_space_ok("\t", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
        -: 2105:  *yyextra->lex_buf_ptr++ = '\t';
        -: 2106:  yyextra->lex_buf_len++;
        -: 2107:}
        -: 2108:	YY_BREAK
        -: 2109:case 58:
        -: 2110:YY_RULE_SETUP
        -: 2111:#line 586 "lexer.l"
        -: 2112:{
        -: 2113:
        -: 2114:  lex_check_space_ok("\n", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
        -: 2115:  *yyextra->lex_buf_ptr++ = '\n';
        -: 2116:  yyextra->lex_buf_len++;
        -: 2117:}
        -: 2118:	YY_BREAK
        -: 2119:case 59:
        -: 2120:YY_RULE_SETUP
        -: 2121:#line 594 "lexer.l"
        -: 2122:{
        -: 2123:
        -: 2124:  lex_check_space_ok("\"", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
        -: 2125:  *yyextra->lex_buf_ptr++ = '\"';
        -: 2126:  yyextra->lex_buf_len++;
        -: 2127:}
        -: 2128:	YY_BREAK
        -: 2129:case 60:
        -: 2130:YY_RULE_SETUP
        -: 2131:#line 602 "lexer.l"
        -: 2132:{
        -: 2133:
        -: 2134:  lex_check_space_ok("\\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
        -: 2135:  *yyextra->lex_buf_ptr++ = '\\';
        -: 2136:  yyextra->lex_buf_len++;
        -: 2137:}
        -: 2138:	YY_BREAK
        -: 2139:case 61:
        -: 2140:YY_RULE_SETUP
        -: 2141:#line 610 "lexer.l"
        -: 2142:{
        -: 2143:
        -: 2144:   int result;
        -: 2145:
        -: 2146:   sscanf( yytext + 2, "%x", &result );
        -: 2147:   lex_check_space_ok("X", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
        -: 2148:   *yyextra->lex_buf_ptr++ = result;
        -: 2149:   yyextra->lex_buf_len++;
        -: 2150:}
        -: 2151:	YY_BREAK
        -: 2152:case 62:
        -: 2153:YY_RULE_SETUP
        -: 2154:#line 621 "lexer.l"
        -: 2155:{ yytext_to_buffer; }
        -: 2156:	YY_BREAK
        -: 2157:case 63:
        -: 2158:/* rule 63 can match eol */
        -: 2159:YY_RULE_SETUP
        -: 2160:#line 624 "lexer.l"
        -: 2161:{
        -: 2162:  syntax_error("unterminated string");
        -: 2163:}
        -: 2164:	YY_BREAK
        -: 2165:case 64:
        -: 2166:/* rule 64 can match eol */
        -: 2167:YY_RULE_SETUP
        -: 2168:#line 629 "lexer.l"
        -: 2169:{
        -: 2170:  syntax_error("illegal escape sequence");
        -: 2171:}
        -: 2172:	YY_BREAK
        -: 2173:case 65:
        -: 2174:YY_RULE_SETUP
        -: 2175:#line 634 "lexer.l"
        -: 2176:{
        -: 2177:
        -: 2178:  if (yyextra->lex_buf_len > 0)
        -: 2179:  {
        -: 2180:    alloc_sized_string(s, yyextra->lex_buf_len);
        -: 2181:
        -: 2182:    if (yytext[1] == 'i')
        -: 2183:      s->flags |= SIZED_STRING_FLAGS_NO_CASE;
        -: 2184:
        -: 2185:    if (yytext[1] == 's' || yytext[2] == 's')
        -: 2186:      s->flags |= SIZED_STRING_FLAGS_DOT_ALL;
        -: 2187:
        -: 2188:    *yyextra->lex_buf_ptr = '\0';
        -: 2189:    strlcpy(s->c_string, yyextra->lex_buf, s->length + 1);
        -: 2190:    yylval->sized_string = s;
        -: 2191:  }
        -: 2192:  else
        -: 2193:  {
        -: 2194:    syntax_error("empty regular expression");
        -: 2195:  }
        -: 2196:
        -: 2197:  BEGIN(INITIAL);
        -: 2198:  return _REGEXP_;
        -: 2199:}
        -: 2200:	YY_BREAK
        -: 2201:case 66:
        -: 2202:YY_RULE_SETUP
        -: 2203:#line 660 "lexer.l"
        -: 2204:{
        -: 2205:
        -: 2206:  lex_check_space_ok("/", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
        -: 2207:  *yyextra->lex_buf_ptr++ = '/';
        -: 2208:  yyextra->lex_buf_len++ ;
        -: 2209:}
        -: 2210:	YY_BREAK
        -: 2211:case 67:
        -: 2212:YY_RULE_SETUP
        -: 2213:#line 668 "lexer.l"
        -: 2214:{
        -: 2215:
        -: 2216:  lex_check_space_ok("\\.", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
        -: 2217:
        -: 2218:  if (yytext[1] == 0)
        -: 2219:    syntax_error("malformed regular expression");
        -: 2220:
        -: 2221:  *yyextra->lex_buf_ptr++ = yytext[0];
        -: 2222:  *yyextra->lex_buf_ptr++ = yytext[1];
        -: 2223:  yyextra->lex_buf_len += 2;
        -: 2224:}
        -: 2225:	YY_BREAK
        -: 2226:case 68:
        -: 2227:YY_RULE_SETUP
        -: 2228:#line 681 "lexer.l"
        -: 2229:{ yytext_to_buffer; }
        -: 2230:	YY_BREAK
        -: 2231:case 69:
        -: 2232:/* rule 69 can match eol */
        -: 2233:YY_RULE_SETUP
        -: 2234:#line 684 "lexer.l"
        -: 2235:{
        -: 2236:  syntax_error("unterminated regular expression");
        -: 2237:}
        -: 2238:	YY_BREAK
        -: 2239:case 70:
        -: 2240:YY_RULE_SETUP
        -: 2241:#line 689 "lexer.l"
        -: 2242:{
        -: 2243:
        -: 2244:  yylval->sized_string = NULL;
        -: 2245:  yyextra->lex_buf_ptr = yyextra->lex_buf;
        -: 2246:  yyextra->lex_buf_len = 0;
        -: 2247:  BEGIN(str);
        -: 2248:}
        -: 2249:	YY_BREAK
        -: 2250:case 71:
        -: 2251:YY_RULE_SETUP
        -: 2252:#line 698 "lexer.l"
        -: 2253:{
        -: 2254:
        -: 2255:  yylval->sized_string = NULL;
        -: 2256:  yyextra->lex_buf_ptr = yyextra->lex_buf;
        -: 2257:  yyextra->lex_buf_len = 0;
        -: 2258:  BEGIN(regexp);
        -: 2259:}
        -: 2260:	YY_BREAK
        -: 2261:case 72:
        -: 2262:/* rule 72 can match eol */
        -: 2263:YY_RULE_SETUP
        -: 2264:#line 707 "lexer.l"
        -: 2265:{
        -: 2266:  // Match hex-digits with whitespace or comments. The latter are stripped
        -: 2267:  // out by hex_lexer.l
        -: 2268:  // TODO(vmalvarez): Integrate the hex string lexer and parser into this one,
        -: 2269:  // by having a single lexer/parser instead of two different ones we can avoid
        -: 2270:  // complex regular expressions like the one above, which is actually trying to
        -: 2271:  // do some parsing in the lexer.
        -: 2272:
        -: 2273:  alloc_sized_string(s, strlen(yytext));
        -: 2274:
        -: 2275:  strlcpy(s->c_string, yytext, s->length + 1);
        -: 2276:  yylval->sized_string = s;
        -: 2277:
        -: 2278:  return _HEX_STRING_;
        -: 2279:}
        -: 2280:	YY_BREAK
        -: 2281:case 73:
        -: 2282:/* rule 73 can match eol */
        -: 2283:YY_RULE_SETUP
        -: 2284:#line 724 "lexer.l"
        -: 2285:/* skip whitespace */
        -: 2286:	YY_BREAK
        -: 2287:case 74:
        -: 2288:YY_RULE_SETUP
        -: 2289:#line 726 "lexer.l"
        -: 2290:{
        -: 2291:
        -: 2292:  if (yytext[0] >= 32 && yytext[0] < 127)
        -: 2293:  {
        -: 2294:    return yytext[0];
        -: 2295:  }
        -: 2296:  else
        -: 2297:  {
        -: 2298:    syntax_error("non-ascii character");
        -: 2299:  }
        -: 2300:}
        -: 2301:	YY_BREAK
        -: 2302:case 75:
        -: 2303:YY_RULE_SETUP
        -: 2304:#line 738 "lexer.l"
        -: 2305:ECHO;
        -: 2306:	YY_BREAK
        -: 2307:#line 2308 "lexer.c"
        -: 2308:
    #####: 2309:	case YY_END_OF_BUFFER:
        -: 2310:		{
        -: 2311:		/* Amount of text matched not including the EOB char. */
    #####: 2312:		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;
        -: 2313:
        -: 2314:		/* Undo the effects of YY_DO_BEFORE_ACTION. */
    #####: 2315:		*yy_cp = yyg->yy_hold_char;
        -: 2316:		YY_RESTORE_YY_MORE_OFFSET
        -: 2317:
    #####: 2318:		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
        -: 2319:			{
        -: 2320:			/* We're scanning a new file or input source.  It's
        -: 2321:			 * possible that this happened because the user
        -: 2322:			 * just pointed yyin at a new source and called
        -: 2323:			 * yylex().  If so, then we have to assure
        -: 2324:			 * consistency between YY_CURRENT_BUFFER and our
        -: 2325:			 * globals.  Here is the right place to do so, because
        -: 2326:			 * this is the first action (other than possibly a
        -: 2327:			 * back-up) that will match for the new input source.
        -: 2328:			 */
    #####: 2329:			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
    #####: 2330:			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
    #####: 2331:			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
        -: 2332:			}
        -: 2333:
        -: 2334:		/* Note that here we test for yy_c_buf_p "<=" to the position
        -: 2335:		 * of the first EOB in the buffer, since yy_c_buf_p will
        -: 2336:		 * already have been incremented past the NUL character
        -: 2337:		 * (since all states make transitions on EOB to the
        -: 2338:		 * end-of-buffer state).  Contrast this with the test
        -: 2339:		 * in input().
        -: 2340:		 */
    #####: 2341:		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
        -: 2342:			{ /* This was really a NUL. */
        -: 2343:			yy_state_type yy_next_state;
        -: 2344:
    #####: 2345:			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;
        -: 2346:
    #####: 2347:			yy_current_state = yy_get_previous_state( yyscanner );
        -: 2348:
        -: 2349:			/* Okay, we're now positioned to make the NUL
        -: 2350:			 * transition.  We couldn't have
        -: 2351:			 * yy_get_previous_state() go ahead and do it
        -: 2352:			 * for us because it doesn't know how to deal
        -: 2353:			 * with the possibility of jamming (and we don't
        -: 2354:			 * want to build jamming into it because then it
        -: 2355:			 * will run more slowly).
        -: 2356:			 */
        -: 2357:
    #####: 2358:			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);
        -: 2359:
    #####: 2360:			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
        -: 2361:
    #####: 2362:			if ( yy_next_state )
        -: 2363:				{
        -: 2364:				/* Consume the NUL. */
    #####: 2365:				yy_cp = ++yyg->yy_c_buf_p;
    #####: 2366:				yy_current_state = yy_next_state;
    #####: 2367:				goto yy_match;
        -: 2368:				}
        -: 2369:
        -: 2370:			else
        -: 2371:				{
    #####: 2372:				yy_cp = yyg->yy_last_accepting_cpos;
    #####: 2373:				yy_current_state = yyg->yy_last_accepting_state;
    #####: 2374:				goto yy_find_action;
        -: 2375:				}
        -: 2376:			}
        -: 2377:
    #####: 2378:		else switch ( yy_get_next_buffer( yyscanner ) )
        -: 2379:			{
    #####: 2380:			case EOB_ACT_END_OF_FILE:
        -: 2381:				{
    #####: 2382:				yyg->yy_did_buffer_switch_on_eof = 0;
        -: 2383:
        -: 2384:				if ( yywrap( yyscanner ) )
        -: 2385:					{
        -: 2386:					/* Note: because we've taken care in
        -: 2387:					 * yy_get_next_buffer() to have set up
        -: 2388:					 * yytext, we can now set up
        -: 2389:					 * yy_c_buf_p so that if some total
        -: 2390:					 * hoser (like flex itself) wants to
        -: 2391:					 * call the scanner after we return the
        -: 2392:					 * YY_NULL, it'll still work - another
        -: 2393:					 * YY_NULL will get returned.
        -: 2394:					 */
    #####: 2395:					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;
        -: 2396:
    #####: 2397:					yy_act = YY_STATE_EOF(YY_START);
    #####: 2398:					goto do_action;
        -: 2399:					}
        -: 2400:
        -: 2401:				else
        -: 2402:					{
        -: 2403:					if ( ! yyg->yy_did_buffer_switch_on_eof )
        -: 2404:						YY_NEW_FILE;
        -: 2405:					}
        -: 2406:				break;
        -: 2407:				}
        -: 2408:
    #####: 2409:			case EOB_ACT_CONTINUE_SCAN:
    #####: 2410:				yyg->yy_c_buf_p =
    #####: 2411:					yyg->yytext_ptr + yy_amount_of_matched_text;
        -: 2412:
    #####: 2413:				yy_current_state = yy_get_previous_state( yyscanner );
        -: 2414:
    #####: 2415:				yy_cp = yyg->yy_c_buf_p;
    #####: 2416:				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
    #####: 2417:				goto yy_match;
        -: 2418:
    #####: 2419:			case EOB_ACT_LAST_MATCH:
    #####: 2420:				yyg->yy_c_buf_p =
    #####: 2421:				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];
        -: 2422:
    #####: 2423:				yy_current_state = yy_get_previous_state( yyscanner );
        -: 2424:
    #####: 2425:				yy_cp = yyg->yy_c_buf_p;
    #####: 2426:				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
    #####: 2427:				goto yy_find_action;
        -: 2428:			}
    #####: 2429:		break;
        -: 2430:		}
        -: 2431:
    #####: 2432:	default:
    #####: 2433:		YY_FATAL_ERROR(
        -: 2434:			"fatal flex scanner internal error--no action found" );
        -: 2435:	} /* end of action switch */
        -: 2436:		} /* end of scanning one token */
        -: 2437:	} /* end of user's declarations */
        -: 2438:} /* end of yylex */
        -: 2439:
        -: 2440:/* yy_get_next_buffer - try to read in a new buffer
        -: 2441: *
        -: 2442: * Returns a code representing an action:
        -: 2443: *	EOB_ACT_LAST_MATCH -
        -: 2444: *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
        -: 2445: *	EOB_ACT_END_OF_FILE - end of file
        -: 2446: */
    #####: 2447:static int yy_get_next_buffer (yyscan_t yyscanner)
        -: 2448:{
    #####: 2449:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2450:	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
    #####: 2451:	char *source = yyg->yytext_ptr;
        -: 2452:	int number_to_move, i;
        -: 2453:	int ret_val;
        -: 2454:
    #####: 2455:	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
    #####: 2456:		YY_FATAL_ERROR(
        -: 2457:		"fatal flex scanner internal error--end of buffer missed" );
        -: 2458:
    #####: 2459:	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
        -: 2460:		{ /* Don't try to fill the buffer, so this is an EOF. */
    #####: 2461:		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
        -: 2462:			{
        -: 2463:			/* We matched a single character, the EOB, so
        -: 2464:			 * treat this as a final EOF.
        -: 2465:			 */
    #####: 2466:			return EOB_ACT_END_OF_FILE;
        -: 2467:			}
        -: 2468:
        -: 2469:		else
        -: 2470:			{
        -: 2471:			/* We matched some text prior to the EOB, first
        -: 2472:			 * process it.
        -: 2473:			 */
    #####: 2474:			return EOB_ACT_LAST_MATCH;
        -: 2475:			}
        -: 2476:		}
        -: 2477:
        -: 2478:	/* Try to read more data. */
        -: 2479:
        -: 2480:	/* First move last chars to start of buffer. */
    #####: 2481:	number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);
        -: 2482:
    #####: 2483:	for ( i = 0; i < number_to_move; ++i )
    #####: 2484:		*(dest++) = *(source++);
        -: 2485:
    #####: 2486:	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
        -: 2487:		/* don't do the read, it's not guaranteed to return an EOF,
        -: 2488:		 * just force an EOF
        -: 2489:		 */
    #####: 2490:		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;
        -: 2491:
        -: 2492:	else
        -: 2493:		{
    #####: 2494:			int num_to_read =
    #####: 2495:			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
        -: 2496:
    #####: 2497:		while ( num_to_read <= 0 )
        -: 2498:			{ /* Not enough room in the buffer - grow it. */
        -: 2499:
        -: 2500:			/* just a shorter name for the current buffer */
    #####: 2501:			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
        -: 2502:
    #####: 2503:			int yy_c_buf_p_offset =
    #####: 2504:				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);
        -: 2505:
    #####: 2506:			if ( b->yy_is_our_buffer )
        -: 2507:				{
    #####: 2508:				int new_size = b->yy_buf_size * 2;
        -: 2509:
    #####: 2510:				if ( new_size <= 0 )
    #####: 2511:					b->yy_buf_size += b->yy_buf_size / 8;
        -: 2512:				else
    #####: 2513:					b->yy_buf_size *= 2;
        -: 2514:
    #####: 2515:				b->yy_ch_buf = (char *)
        -: 2516:					/* Include room in for 2 EOB chars. */
    #####: 2517:					yyrealloc( (void *) b->yy_ch_buf,
    #####: 2518:							 (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
        -: 2519:				}
        -: 2520:			else
        -: 2521:				/* Can't grow it, we don't own it. */
    #####: 2522:				b->yy_ch_buf = NULL;
        -: 2523:
    #####: 2524:			if ( ! b->yy_ch_buf )
    #####: 2525:				YY_FATAL_ERROR(
        -: 2526:				"fatal error - scanner input buffer overflow" );
        -: 2527:
    #####: 2528:			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
        -: 2529:
    #####: 2530:			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
        -: 2531:						number_to_move - 1;
        -: 2532:
        -: 2533:			}
        -: 2534:
    #####: 2535:		if ( num_to_read > YY_READ_BUF_SIZE )
    #####: 2536:			num_to_read = YY_READ_BUF_SIZE;
        -: 2537:
        -: 2538:		/* Read in more data. */
    #####: 2539:		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
        -: 2540:			yyg->yy_n_chars, num_to_read );
        -: 2541:
    #####: 2542:		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
        -: 2543:		}
        -: 2544:
    #####: 2545:	if ( yyg->yy_n_chars == 0 )
        -: 2546:		{
    #####: 2547:		if ( number_to_move == YY_MORE_ADJ )
        -: 2548:			{
    #####: 2549:			ret_val = EOB_ACT_END_OF_FILE;
    #####: 2550:			yyrestart( yyin  , yyscanner);
        -: 2551:			}
        -: 2552:
        -: 2553:		else
        -: 2554:			{
    #####: 2555:			ret_val = EOB_ACT_LAST_MATCH;
    #####: 2556:			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
        -: 2557:				YY_BUFFER_EOF_PENDING;
        -: 2558:			}
        -: 2559:		}
        -: 2560:
        -: 2561:	else
    #####: 2562:		ret_val = EOB_ACT_CONTINUE_SCAN;
        -: 2563:
    #####: 2564:	if ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
        -: 2565:		/* Extend the array by 50%, plus the number we really need. */
    #####: 2566:		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
    #####: 2567:		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
    #####: 2568:			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );
    #####: 2569:		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
    #####: 2570:			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
        -: 2571:		/* "- 2" to take care of EOB's */
    #####: 2572:		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
        -: 2573:	}
        -: 2574:
    #####: 2575:	yyg->yy_n_chars += number_to_move;
    #####: 2576:	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    #####: 2577:	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
        -: 2578:
    #####: 2579:	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
        -: 2580:
    #####: 2581:	return ret_val;
        -: 2582:}
        -: 2583:
        -: 2584:/* yy_get_previous_state - get the state just before the EOB char was reached */
        -: 2585:
    #####: 2586:    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
        -: 2587:{
        -: 2588:	yy_state_type yy_current_state;
        -: 2589:	char *yy_cp;
    #####: 2590:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2591:
    #####: 2592:	yy_current_state = yyg->yy_start;
        -: 2593:
    #####: 2594:	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
        -: 2595:		{
    #####: 2596:		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    #####: 2597:		if ( yy_accept[yy_current_state] )
        -: 2598:			{
    #####: 2599:			yyg->yy_last_accepting_state = yy_current_state;
    #####: 2600:			yyg->yy_last_accepting_cpos = yy_cp;
        -: 2601:			}
    #####: 2602:		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        -: 2603:			{
    #####: 2604:			yy_current_state = (int) yy_def[yy_current_state];
    #####: 2605:			if ( yy_current_state >= 286 )
    #####: 2606:				yy_c = yy_meta[yy_c];
        -: 2607:			}
    #####: 2608:		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        -: 2609:		}
        -: 2610:
    #####: 2611:	return yy_current_state;
        -: 2612:}
        -: 2613:
        -: 2614:/* yy_try_NUL_trans - try to make a transition on the NUL character
        -: 2615: *
        -: 2616: * synopsis
        -: 2617: *	next_state = yy_try_NUL_trans( current_state );
        -: 2618: */
    #####: 2619:    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
        -: 2620:{
        -: 2621:	int yy_is_jam;
    #####: 2622:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
    #####: 2623:	char *yy_cp = yyg->yy_c_buf_p;
        -: 2624:
    #####: 2625:	YY_CHAR yy_c = 1;
    #####: 2626:	if ( yy_accept[yy_current_state] )
        -: 2627:		{
    #####: 2628:		yyg->yy_last_accepting_state = yy_current_state;
    #####: 2629:		yyg->yy_last_accepting_cpos = yy_cp;
        -: 2630:		}
    #####: 2631:	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        -: 2632:		{
    #####: 2633:		yy_current_state = (int) yy_def[yy_current_state];
    #####: 2634:		if ( yy_current_state >= 286 )
    #####: 2635:			yy_c = yy_meta[yy_c];
        -: 2636:		}
    #####: 2637:	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    #####: 2638:	yy_is_jam = (yy_current_state == 285);
        -: 2639:
        -: 2640:	(void)yyg;
    #####: 2641:	return yy_is_jam ? 0 : yy_current_state;
        -: 2642:}
        -: 2643:
        -: 2644:#ifndef YY_NO_UNPUT
        -: 2645:
        -: 2646:#endif
        -: 2647:
        -: 2648:#ifndef YY_NO_INPUT
        -: 2649:#ifdef __cplusplus
        -: 2650:    static int yyinput (yyscan_t yyscanner)
        -: 2651:#else
        -: 2652:    static int input  (yyscan_t yyscanner)
        -: 2653:#endif
        -: 2654:
        -: 2655:{
        -: 2656:	int c;
        -: 2657:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2658:
        -: 2659:	*yyg->yy_c_buf_p = yyg->yy_hold_char;
        -: 2660:
        -: 2661:	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
        -: 2662:		{
        -: 2663:		/* yy_c_buf_p now points to the character we want to return.
        -: 2664:		 * If this occurs *before* the EOB characters, then it's a
        -: 2665:		 * valid NUL; if not, then we've hit the end of the buffer.
        -: 2666:		 */
        -: 2667:		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
        -: 2668:			/* This was really a NUL. */
        -: 2669:			*yyg->yy_c_buf_p = '\0';
        -: 2670:
        -: 2671:		else
        -: 2672:			{ /* need more input */
        -: 2673:			int offset = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr);
        -: 2674:			++yyg->yy_c_buf_p;
        -: 2675:
        -: 2676:			switch ( yy_get_next_buffer( yyscanner ) )
        -: 2677:				{
        -: 2678:				case EOB_ACT_LAST_MATCH:
        -: 2679:					/* This happens because yy_g_n_b()
        -: 2680:					 * sees that we've accumulated a
        -: 2681:					 * token and flags that we need to
        -: 2682:					 * try matching the token before
        -: 2683:					 * proceeding.  But for input(),
        -: 2684:					 * there's no matching to consider.
        -: 2685:					 * So convert the EOB_ACT_LAST_MATCH
        -: 2686:					 * to EOB_ACT_END_OF_FILE.
        -: 2687:					 */
        -: 2688:
        -: 2689:					/* Reset buffer status. */
        -: 2690:					yyrestart( yyin , yyscanner);
        -: 2691:
        -: 2692:					/*FALLTHROUGH*/
        -: 2693:
        -: 2694:				case EOB_ACT_END_OF_FILE:
        -: 2695:					{
        -: 2696:					if ( yywrap( yyscanner ) )
        -: 2697:						return 0;
        -: 2698:
        -: 2699:					if ( ! yyg->yy_did_buffer_switch_on_eof )
        -: 2700:						YY_NEW_FILE;
        -: 2701:#ifdef __cplusplus
        -: 2702:					return yyinput(yyscanner);
        -: 2703:#else
        -: 2704:					return input(yyscanner);
        -: 2705:#endif
        -: 2706:					}
        -: 2707:
        -: 2708:				case EOB_ACT_CONTINUE_SCAN:
        -: 2709:					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
        -: 2710:					break;
        -: 2711:				}
        -: 2712:			}
        -: 2713:		}
        -: 2714:
        -: 2715:	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
        -: 2716:	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
        -: 2717:	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
        -: 2718:
        -: 2719:	if ( c == '\n' )
        -: 2720:		
        -: 2721:    do{ yylineno++;
        -: 2722:        yycolumn=0;
        -: 2723:    }while(0)
        -: 2724:;
        -: 2725:
        -: 2726:	return c;
        -: 2727:}
        -: 2728:#endif	/* ifndef YY_NO_INPUT */
        -: 2729:
        -: 2730:/** Immediately switch to a different input stream.
        -: 2731: * @param input_file A readable stream.
        -: 2732: * @param yyscanner The scanner object.
        -: 2733: * @note This function does not reset the start condition to @c INITIAL .
        -: 2734: */
    #####: 2735:    void yyrestart  (FILE * input_file , yyscan_t yyscanner)
        -: 2736:{
    #####: 2737:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2738:
    #####: 2739:	if ( ! YY_CURRENT_BUFFER ){
    #####: 2740:        yyensure_buffer_stack (yyscanner);
    #####: 2741:		YY_CURRENT_BUFFER_LVALUE =
    #####: 2742:            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
        -: 2743:	}
        -: 2744:
    #####: 2745:	yy_init_buffer( YY_CURRENT_BUFFER, input_file , yyscanner);
    #####: 2746:	yy_load_buffer_state( yyscanner );
    #####: 2747:}
        -: 2748:
        -: 2749:/** Switch to a different input buffer.
        -: 2750: * @param new_buffer The new input buffer.
        -: 2751: * @param yyscanner The scanner object.
        -: 2752: */
    #####: 2753:    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)
        -: 2754:{
    #####: 2755:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2756:
        -: 2757:	/* TODO. We should be able to replace this entire function body
        -: 2758:	 * with
        -: 2759:	 *		yypop_buffer_state();
        -: 2760:	 *		yypush_buffer_state(new_buffer);
        -: 2761:     */
    #####: 2762:	yyensure_buffer_stack (yyscanner);
    #####: 2763:	if ( YY_CURRENT_BUFFER == new_buffer )
    #####: 2764:		return;
        -: 2765:
    #####: 2766:	if ( YY_CURRENT_BUFFER )
        -: 2767:		{
        -: 2768:		/* Flush out information for old buffer. */
    #####: 2769:		*yyg->yy_c_buf_p = yyg->yy_hold_char;
    #####: 2770:		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
    #####: 2771:		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
        -: 2772:		}
        -: 2773:
    #####: 2774:	YY_CURRENT_BUFFER_LVALUE = new_buffer;
    #####: 2775:	yy_load_buffer_state( yyscanner );
        -: 2776:
        -: 2777:	/* We don't actually know whether we did this switch during
        -: 2778:	 * EOF (yywrap()) processing, but the only time this flag
        -: 2779:	 * is looked at is after yywrap() is called, so it's safe
        -: 2780:	 * to go ahead and always set it.
        -: 2781:	 */
    #####: 2782:	yyg->yy_did_buffer_switch_on_eof = 1;
        -: 2783:}
        -: 2784:
    #####: 2785:static void yy_load_buffer_state  (yyscan_t yyscanner)
        -: 2786:{
    #####: 2787:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2788:	yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
    #####: 2789:	yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
    #####: 2790:	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
    #####: 2791:	yyg->yy_hold_char = *yyg->yy_c_buf_p;
    #####: 2792:}
        -: 2793:
        -: 2794:/** Allocate and initialize an input buffer state.
        -: 2795: * @param file A readable stream.
        -: 2796: * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
        -: 2797: * @param yyscanner The scanner object.
        -: 2798: * @return the allocated buffer state.
        -: 2799: */
    #####: 2800:    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
        -: 2801:{
        -: 2802:	YY_BUFFER_STATE b;
        -: 2803:    
    #####: 2804:	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
    #####: 2805:	if ( ! b )
    #####: 2806:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        -: 2807:
    #####: 2808:	b->yy_buf_size = size;
        -: 2809:
        -: 2810:	/* yy_ch_buf has to be 2 characters longer than the size given because
        -: 2811:	 * we need to put in 2 end-of-buffer characters.
        -: 2812:	 */
    #####: 2813:	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
    #####: 2814:	if ( ! b->yy_ch_buf )
    #####: 2815:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        -: 2816:
    #####: 2817:	b->yy_is_our_buffer = 1;
        -: 2818:
    #####: 2819:	yy_init_buffer( b, file , yyscanner);
        -: 2820:
    #####: 2821:	return b;
        -: 2822:}
        -: 2823:
        -: 2824:/** Destroy the buffer.
        -: 2825: * @param b a buffer created with yy_create_buffer()
        -: 2826: * @param yyscanner The scanner object.
        -: 2827: */
    #####: 2828:    void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
        -: 2829:{
    #####: 2830:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2831:
    #####: 2832:	if ( ! b )
    #####: 2833:		return;
        -: 2834:
    #####: 2835:	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
    #####: 2836:		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
        -: 2837:
    #####: 2838:	if ( b->yy_is_our_buffer )
    #####: 2839:		yyfree( (void *) b->yy_ch_buf , yyscanner );
        -: 2840:
    #####: 2841:	yyfree( (void *) b , yyscanner );
        -: 2842:}
        -: 2843:
        -: 2844:/* Initializes or reinitializes a buffer.
        -: 2845: * This function is sometimes called more than once on the same buffer,
        -: 2846: * such as during a yyrestart() or at EOF.
        -: 2847: */
    #####: 2848:    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)
        -: 2849:
        -: 2850:{
    #####: 2851:	int oerrno = errno;
    #####: 2852:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2853:
    #####: 2854:	yy_flush_buffer( b , yyscanner);
        -: 2855:
    #####: 2856:	b->yy_input_file = file;
    #####: 2857:	b->yy_fill_buffer = 1;
        -: 2858:
        -: 2859:    /* If b is the current buffer, then yy_init_buffer was _probably_
        -: 2860:     * called from yyrestart() or through yy_get_next_buffer.
        -: 2861:     * In that case, we don't want to reset the lineno or column.
        -: 2862:     */
    #####: 2863:    if (b != YY_CURRENT_BUFFER){
    #####: 2864:        b->yy_bs_lineno = 1;
    #####: 2865:        b->yy_bs_column = 0;
        -: 2866:    }
        -: 2867:
    #####: 2868:        b->yy_is_interactive = 0;
        -: 2869:    
    #####: 2870:	errno = oerrno;
    #####: 2871:}
        -: 2872:
        -: 2873:/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
        -: 2874: * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
        -: 2875: * @param yyscanner The scanner object.
        -: 2876: */
    #####: 2877:    void yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
        -: 2878:{
    #####: 2879:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2880:	if ( ! b )
    #####: 2881:		return;
        -: 2882:
    #####: 2883:	b->yy_n_chars = 0;
        -: 2884:
        -: 2885:	/* We always need two end-of-buffer characters.  The first causes
        -: 2886:	 * a transition to the end-of-buffer state.  The second causes
        -: 2887:	 * a jam in that state.
        -: 2888:	 */
    #####: 2889:	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    #####: 2890:	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
        -: 2891:
    #####: 2892:	b->yy_buf_pos = &b->yy_ch_buf[0];
        -: 2893:
    #####: 2894:	b->yy_at_bol = 1;
    #####: 2895:	b->yy_buffer_status = YY_BUFFER_NEW;
        -: 2896:
    #####: 2897:	if ( b == YY_CURRENT_BUFFER )
    #####: 2898:		yy_load_buffer_state( yyscanner );
        -: 2899:}
        -: 2900:
        -: 2901:/** Pushes the new state onto the stack. The new state becomes
        -: 2902: *  the current state. This function will allocate the stack
        -: 2903: *  if necessary.
        -: 2904: *  @param new_buffer The new state.
        -: 2905: *  @param yyscanner The scanner object.
        -: 2906: */
    #####: 2907:void yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)
        -: 2908:{
    #####: 2909:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2910:	if (new_buffer == NULL)
    #####: 2911:		return;
        -: 2912:
    #####: 2913:	yyensure_buffer_stack(yyscanner);
        -: 2914:
        -: 2915:	/* This block is copied from yy_switch_to_buffer. */
    #####: 2916:	if ( YY_CURRENT_BUFFER )
        -: 2917:		{
        -: 2918:		/* Flush out information for old buffer. */
    #####: 2919:		*yyg->yy_c_buf_p = yyg->yy_hold_char;
    #####: 2920:		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
    #####: 2921:		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
        -: 2922:		}
        -: 2923:
        -: 2924:	/* Only push if top exists. Otherwise, replace top. */
    #####: 2925:	if (YY_CURRENT_BUFFER)
    #####: 2926:		yyg->yy_buffer_stack_top++;
    #####: 2927:	YY_CURRENT_BUFFER_LVALUE = new_buffer;
        -: 2928:
        -: 2929:	/* copied from yy_switch_to_buffer. */
    #####: 2930:	yy_load_buffer_state( yyscanner );
    #####: 2931:	yyg->yy_did_buffer_switch_on_eof = 1;
        -: 2932:}
        -: 2933:
        -: 2934:/** Removes and deletes the top of the stack, if present.
        -: 2935: *  The next element becomes the new top.
        -: 2936: *  @param yyscanner The scanner object.
        -: 2937: */
    #####: 2938:void yypop_buffer_state (yyscan_t yyscanner)
        -: 2939:{
    #####: 2940:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2941:	if (!YY_CURRENT_BUFFER)
    #####: 2942:		return;
        -: 2943:
    #####: 2944:	yy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);
    #####: 2945:	YY_CURRENT_BUFFER_LVALUE = NULL;
    #####: 2946:	if (yyg->yy_buffer_stack_top > 0)
    #####: 2947:		--yyg->yy_buffer_stack_top;
        -: 2948:
    #####: 2949:	if (YY_CURRENT_BUFFER) {
    #####: 2950:		yy_load_buffer_state( yyscanner );
    #####: 2951:		yyg->yy_did_buffer_switch_on_eof = 1;
        -: 2952:	}
        -: 2953:}
        -: 2954:
        -: 2955:/* Allocates the stack if it does not exist.
        -: 2956: *  Guarantees space for at least one push.
        -: 2957: */
    #####: 2958:static void yyensure_buffer_stack (yyscan_t yyscanner)
        -: 2959:{
        -: 2960:	yy_size_t num_to_alloc;
    #####: 2961:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2962:
    #####: 2963:	if (!yyg->yy_buffer_stack) {
        -: 2964:
        -: 2965:		/* First allocation is just for 2 elements, since we don't know if this
        -: 2966:		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
        -: 2967:		 * immediate realloc on the next call.
        -: 2968:         */
    #####: 2969:      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
    #####: 2970:		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc
        -: 2971:								(num_to_alloc * sizeof(struct yy_buffer_state*)
        -: 2972:								, yyscanner);
    #####: 2973:		if ( ! yyg->yy_buffer_stack )
    #####: 2974:			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
        -: 2975:
    #####: 2976:		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
        -: 2977:
    #####: 2978:		yyg->yy_buffer_stack_max = num_to_alloc;
    #####: 2979:		yyg->yy_buffer_stack_top = 0;
    #####: 2980:		return;
        -: 2981:	}
        -: 2982:
    #####: 2983:	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){
        -: 2984:
        -: 2985:		/* Increase the buffer to prepare for a possible push. */
    #####: 2986:		yy_size_t grow_size = 8 /* arbitrary grow size */;
        -: 2987:
    #####: 2988:		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
    #####: 2989:		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc
    #####: 2990:								(yyg->yy_buffer_stack,
        -: 2991:								num_to_alloc * sizeof(struct yy_buffer_state*)
        -: 2992:								, yyscanner);
    #####: 2993:		if ( ! yyg->yy_buffer_stack )
    #####: 2994:			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
        -: 2995:
        -: 2996:		/* zero only the new slots.*/
    #####: 2997:		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
    #####: 2998:		yyg->yy_buffer_stack_max = num_to_alloc;
        -: 2999:	}
        -: 3000:}
        -: 3001:
        -: 3002:/** Setup the input buffer state to scan directly from a user-specified character buffer.
        -: 3003: * @param base the character buffer
        -: 3004: * @param size the size in bytes of the character buffer
        -: 3005: * @param yyscanner The scanner object.
        -: 3006: * @return the newly allocated buffer state object.
        -: 3007: */
    #####: 3008:YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
        -: 3009:{
        -: 3010:	YY_BUFFER_STATE b;
        -: 3011:    
    #####: 3012:	if ( size < 2 ||
    #####: 3013:	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
    #####: 3014:	     base[size-1] != YY_END_OF_BUFFER_CHAR )
        -: 3015:		/* They forgot to leave room for the EOB's. */
    #####: 3016:		return NULL;
        -: 3017:
    #####: 3018:	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
    #####: 3019:	if ( ! b )
    #####: 3020:		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
        -: 3021:
    #####: 3022:	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
    #####: 3023:	b->yy_buf_pos = b->yy_ch_buf = base;
    #####: 3024:	b->yy_is_our_buffer = 0;
    #####: 3025:	b->yy_input_file = NULL;
    #####: 3026:	b->yy_n_chars = b->yy_buf_size;
    #####: 3027:	b->yy_is_interactive = 0;
    #####: 3028:	b->yy_at_bol = 1;
    #####: 3029:	b->yy_fill_buffer = 0;
    #####: 3030:	b->yy_buffer_status = YY_BUFFER_NEW;
        -: 3031:
    #####: 3032:	yy_switch_to_buffer( b , yyscanner );
        -: 3033:
    #####: 3034:	return b;
        -: 3035:}
        -: 3036:
        -: 3037:/** Setup the input buffer state to scan a string. The next call to yylex() will
        -: 3038: * scan from a @e copy of @a str.
        -: 3039: * @param yystr a NUL-terminated string to scan
        -: 3040: * @param yyscanner The scanner object.
        -: 3041: * @return the newly allocated buffer state object.
        -: 3042: * @note If you want to scan bytes that may contain NUL values, then use
        -: 3043: *       yy_scan_bytes() instead.
        -: 3044: */
    #####: 3045:YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)
        -: 3046:{
        -: 3047:    
    #####: 3048:	return yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);
        -: 3049:}
        -: 3050:
        -: 3051:/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
        -: 3052: * scan from a @e copy of @a bytes.
        -: 3053: * @param yybytes the byte buffer to scan
        -: 3054: * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
        -: 3055: * @param yyscanner The scanner object.
        -: 3056: * @return the newly allocated buffer state object.
        -: 3057: */
    #####: 3058:YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
        -: 3059:{
        -: 3060:	YY_BUFFER_STATE b;
        -: 3061:	char *buf;
        -: 3062:	yy_size_t n;
        -: 3063:	int i;
        -: 3064:    
        -: 3065:	/* Get memory for full buffer, including space for trailing EOB's. */
    #####: 3066:	n = (yy_size_t) (_yybytes_len + 2);
    #####: 3067:	buf = (char *) yyalloc( n , yyscanner );
    #####: 3068:	if ( ! buf )
    #####: 3069:		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
        -: 3070:
    #####: 3071:	for ( i = 0; i < _yybytes_len; ++i )
    #####: 3072:		buf[i] = yybytes[i];
        -: 3073:
    #####: 3074:	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
        -: 3075:
    #####: 3076:	b = yy_scan_buffer( buf, n , yyscanner);
    #####: 3077:	if ( ! b )
    #####: 3078:		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
        -: 3079:
        -: 3080:	/* It's okay to grow etc. this buffer, and we should throw it
        -: 3081:	 * away when we're done.
        -: 3082:	 */
    #####: 3083:	b->yy_is_our_buffer = 1;
        -: 3084:
    #####: 3085:	return b;
        -: 3086:}
        -: 3087:
        -: 3088:#ifndef YY_EXIT_FAILURE
        -: 3089:#define YY_EXIT_FAILURE 2
        -: 3090:#endif
        -: 3091:
    #####: 3092:static void yynoreturn yy_fatal_error (const char* msg , yyscan_t yyscanner)
        -: 3093:{
    #####: 3094:	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 3095:	(void)yyg;
    #####: 3096:	fprintf( stderr, "%s\n", msg );
    #####: 3097:	exit( YY_EXIT_FAILURE );
        -: 3098:}
        -: 3099:
        -: 3100:/* Redefine yyless() so it works in section 3 code. */
        -: 3101:
        -: 3102:#undef yyless
        -: 3103:#define yyless(n) \
        -: 3104:	do \
        -: 3105:		{ \
        -: 3106:		/* Undo effects of setting up yytext. */ \
        -: 3107:        int yyless_macro_arg = (n); \
        -: 3108:        YY_LESS_LINENO(yyless_macro_arg);\
        -: 3109:		yytext[yyleng] = yyg->yy_hold_char; \
        -: 3110:		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
        -: 3111:		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
        -: 3112:		*yyg->yy_c_buf_p = '\0'; \
        -: 3113:		yyleng = yyless_macro_arg; \
        -: 3114:		} \
        -: 3115:	while ( 0 )
        -: 3116:
        -: 3117:/* Accessor  methods (get/set functions) to struct members. */
        -: 3118:
        -: 3119:/** Get the user-defined data for this scanner.
        -: 3120: * @param yyscanner The scanner object.
        -: 3121: */
    #####: 3122:YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)
        -: 3123:{
    #####: 3124:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 3125:    return yyextra;
        -: 3126:}
        -: 3127:
        -: 3128:/** Get the current line number.
        -: 3129: * @param yyscanner The scanner object.
        -: 3130: */
    #####: 3131:int yyget_lineno  (yyscan_t yyscanner)
        -: 3132:{
    #####: 3133:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 3134:
    #####: 3135:        if (! YY_CURRENT_BUFFER)
    #####: 3136:            return 0;
        -: 3137:    
    #####: 3138:    return yylineno;
        -: 3139:}
        -: 3140:
        -: 3141:/** Get the current column number.
        -: 3142: * @param yyscanner The scanner object.
        -: 3143: */
    #####: 3144:int yyget_column  (yyscan_t yyscanner)
        -: 3145:{
    #####: 3146:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 3147:
    #####: 3148:        if (! YY_CURRENT_BUFFER)
    #####: 3149:            return 0;
        -: 3150:    
    #####: 3151:    return yycolumn;
        -: 3152:}
        -: 3153:
        -: 3154:/** Get the input stream.
        -: 3155: * @param yyscanner The scanner object.
        -: 3156: */
    #####: 3157:FILE *yyget_in  (yyscan_t yyscanner)
        -: 3158:{
    #####: 3159:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 3160:    return yyin;
        -: 3161:}
        -: 3162:
        -: 3163:/** Get the output stream.
        -: 3164: * @param yyscanner The scanner object.
        -: 3165: */
    #####: 3166:FILE *yyget_out  (yyscan_t yyscanner)
        -: 3167:{
    #####: 3168:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 3169:    return yyout;
        -: 3170:}
        -: 3171:
        -: 3172:/** Get the length of the current token.
        -: 3173: * @param yyscanner The scanner object.
        -: 3174: */
    #####: 3175:int yyget_leng  (yyscan_t yyscanner)
        -: 3176:{
    #####: 3177:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 3178:    return yyleng;
        -: 3179:}
        -: 3180:
        -: 3181:/** Get the current token.
        -: 3182: * @param yyscanner The scanner object.
        -: 3183: */
        -: 3184:
    #####: 3185:char *yyget_text  (yyscan_t yyscanner)
        -: 3186:{
    #####: 3187:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 3188:    return yytext;
        -: 3189:}
        -: 3190:
        -: 3191:/** Set the user-defined data. This data is never touched by the scanner.
        -: 3192: * @param user_defined The data to be associated with this scanner.
        -: 3193: * @param yyscanner The scanner object.
        -: 3194: */
    #####: 3195:void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)
        -: 3196:{
    #####: 3197:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 3198:    yyextra = user_defined ;
    #####: 3199:}
        -: 3200:
        -: 3201:/** Set the current line number.
        -: 3202: * @param _line_number line number
        -: 3203: * @param yyscanner The scanner object.
        -: 3204: */
    #####: 3205:void yyset_lineno (int  _line_number , yyscan_t yyscanner)
        -: 3206:{
    #####: 3207:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 3208:
        -: 3209:        /* lineno is only valid if an input buffer exists. */
    #####: 3210:        if (! YY_CURRENT_BUFFER )
    #####: 3211:           YY_FATAL_ERROR( "yyset_lineno called with no buffer" );
        -: 3212:    
    #####: 3213:    yylineno = _line_number;
    #####: 3214:}
        -: 3215:
        -: 3216:/** Set the current column.
        -: 3217: * @param _column_no column number
        -: 3218: * @param yyscanner The scanner object.
        -: 3219: */
    #####: 3220:void yyset_column (int  _column_no , yyscan_t yyscanner)
        -: 3221:{
    #####: 3222:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 3223:
        -: 3224:        /* column is only valid if an input buffer exists. */
    #####: 3225:        if (! YY_CURRENT_BUFFER )
    #####: 3226:           YY_FATAL_ERROR( "yyset_column called with no buffer" );
        -: 3227:    
    #####: 3228:    yycolumn = _column_no;
    #####: 3229:}
        -: 3230:
        -: 3231:/** Set the input stream. This does not discard the current
        -: 3232: * input buffer.
        -: 3233: * @param _in_str A readable stream.
        -: 3234: * @param yyscanner The scanner object.
        -: 3235: * @see yy_switch_to_buffer
        -: 3236: */
    #####: 3237:void yyset_in (FILE *  _in_str , yyscan_t yyscanner)
        -: 3238:{
    #####: 3239:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 3240:    yyin = _in_str ;
    #####: 3241:}
        -: 3242:
    #####: 3243:void yyset_out (FILE *  _out_str , yyscan_t yyscanner)
        -: 3244:{
    #####: 3245:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 3246:    yyout = _out_str ;
    #####: 3247:}
        -: 3248:
    #####: 3249:int yyget_debug  (yyscan_t yyscanner)
        -: 3250:{
    #####: 3251:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 3252:    return yy_flex_debug;
        -: 3253:}
        -: 3254:
    #####: 3255:void yyset_debug (int  _bdebug , yyscan_t yyscanner)
        -: 3256:{
    #####: 3257:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 3258:    yy_flex_debug = _bdebug ;
    #####: 3259:}
        -: 3260:
        -: 3261:/* Accessor methods for yylval and yylloc */
        -: 3262:
    #####: 3263:YYSTYPE * yyget_lval  (yyscan_t yyscanner)
        -: 3264:{
    #####: 3265:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 3266:    return yylval;
        -: 3267:}
        -: 3268:
    #####: 3269:void yyset_lval (YYSTYPE *  yylval_param , yyscan_t yyscanner)
        -: 3270:{
    #####: 3271:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 3272:    yylval = yylval_param;
    #####: 3273:}
        -: 3274:
        -: 3275:/* User-visible API */
        -: 3276:
        -: 3277:/* yylex_init is special because it creates the scanner itself, so it is
        -: 3278: * the ONLY reentrant function that doesn't take the scanner as the last argument.
        -: 3279: * That's why we explicitly handle the declaration, instead of using our macros.
        -: 3280: */
    #####: 3281:int yylex_init(yyscan_t* ptr_yy_globals)
        -: 3282:{
    #####: 3283:    if (ptr_yy_globals == NULL){
    #####: 3284:        errno = EINVAL;
    #####: 3285:        return 1;
        -: 3286:    }
        -: 3287:
    #####: 3288:    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );
        -: 3289:
    #####: 3290:    if (*ptr_yy_globals == NULL){
    #####: 3291:        errno = ENOMEM;
    #####: 3292:        return 1;
        -: 3293:    }
        -: 3294:
        -: 3295:    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
    #####: 3296:    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
        -: 3297:
    #####: 3298:    return yy_init_globals ( *ptr_yy_globals );
        -: 3299:}
        -: 3300:
        -: 3301:/* yylex_init_extra has the same functionality as yylex_init, but follows the
        -: 3302: * convention of taking the scanner as the last argument. Note however, that
        -: 3303: * this is a *pointer* to a scanner, as it will be allocated by this call (and
        -: 3304: * is the reason, too, why this function also must handle its own declaration).
        -: 3305: * The user defined value in the first argument will be available to yyalloc in
        -: 3306: * the yyextra field.
        -: 3307: */
    #####: 3308:int yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals )
        -: 3309:{
        -: 3310:    struct yyguts_t dummy_yyguts;
        -: 3311:
    #####: 3312:    yyset_extra (yy_user_defined, &dummy_yyguts);
        -: 3313:
    #####: 3314:    if (ptr_yy_globals == NULL){
    #####: 3315:        errno = EINVAL;
    #####: 3316:        return 1;
        -: 3317:    }
        -: 3318:
    #####: 3319:    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
        -: 3320:
    #####: 3321:    if (*ptr_yy_globals == NULL){
    #####: 3322:        errno = ENOMEM;
    #####: 3323:        return 1;
        -: 3324:    }
        -: 3325:
        -: 3326:    /* By setting to 0xAA, we expose bugs in
        -: 3327:    yy_init_globals. Leave at 0x00 for releases. */
    #####: 3328:    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
        -: 3329:
    #####: 3330:    yyset_extra (yy_user_defined, *ptr_yy_globals);
        -: 3331:
    #####: 3332:    return yy_init_globals ( *ptr_yy_globals );
        -: 3333:}
        -: 3334:
    #####: 3335:static int yy_init_globals (yyscan_t yyscanner)
        -: 3336:{
    #####: 3337:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 3338:    /* Initialization is the same as for the non-reentrant scanner.
        -: 3339:     * This function is called from yylex_destroy(), so don't allocate here.
        -: 3340:     */
        -: 3341:
    #####: 3342:    yyg->yy_buffer_stack = NULL;
    #####: 3343:    yyg->yy_buffer_stack_top = 0;
    #####: 3344:    yyg->yy_buffer_stack_max = 0;
    #####: 3345:    yyg->yy_c_buf_p = NULL;
    #####: 3346:    yyg->yy_init = 0;
    #####: 3347:    yyg->yy_start = 0;
        -: 3348:
    #####: 3349:    yyg->yy_start_stack_ptr = 0;
    #####: 3350:    yyg->yy_start_stack_depth = 0;
    #####: 3351:    yyg->yy_start_stack =  NULL;
        -: 3352:
        -: 3353:/* Defined in main.c */
        -: 3354:#ifdef YY_STDINIT
        -: 3355:    yyin = stdin;
        -: 3356:    yyout = stdout;
        -: 3357:#else
    #####: 3358:    yyin = NULL;
    #####: 3359:    yyout = NULL;
        -: 3360:#endif
        -: 3361:
        -: 3362:    /* For future reference: Set errno on error, since we are called by
        -: 3363:     * yylex_init()
        -: 3364:     */
    #####: 3365:    return 0;
        -: 3366:}
        -: 3367:
        -: 3368:/* yylex_destroy is for both reentrant and non-reentrant scanners. */
    #####: 3369:int yylex_destroy  (yyscan_t yyscanner)
        -: 3370:{
    #####: 3371:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 3372:
        -: 3373:    /* Pop the buffer stack, destroying each element. */
    #####: 3374:	while(YY_CURRENT_BUFFER){
    #####: 3375:		yy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );
    #####: 3376:		YY_CURRENT_BUFFER_LVALUE = NULL;
    #####: 3377:		yypop_buffer_state(yyscanner);
        -: 3378:	}
        -: 3379:
        -: 3380:	/* Destroy the stack itself. */
    #####: 3381:	yyfree(yyg->yy_buffer_stack , yyscanner);
    #####: 3382:	yyg->yy_buffer_stack = NULL;
        -: 3383:
        -: 3384:    /* Destroy the start condition stack. */
    #####: 3385:        yyfree( yyg->yy_start_stack , yyscanner );
    #####: 3386:        yyg->yy_start_stack = NULL;
        -: 3387:
        -: 3388:    /* Reset the globals. This is important in a non-reentrant scanner so the next time
        -: 3389:     * yylex() is called, initialization will occur. */
    #####: 3390:    yy_init_globals( yyscanner);
        -: 3391:
        -: 3392:    /* Destroy the main struct (reentrant only). */
    #####: 3393:    yyfree ( yyscanner , yyscanner );
    #####: 3394:    yyscanner = NULL;
    #####: 3395:    return 0;
        -: 3396:}
        -: 3397:
        -: 3398:/*
        -: 3399: * Internal utility routines.
        -: 3400: */
        -: 3401:
        -: 3402:#ifndef yytext_ptr
        -: 3403:static void yy_flex_strncpy (char* s1, const char * s2, int n , yyscan_t yyscanner)
        -: 3404:{
        -: 3405:	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 3406:	(void)yyg;
        -: 3407:
        -: 3408:	int i;
        -: 3409:	for ( i = 0; i < n; ++i )
        -: 3410:		s1[i] = s2[i];
        -: 3411:}
        -: 3412:#endif
        -: 3413:
        -: 3414:#ifdef YY_NEED_STRLEN
        -: 3415:static int yy_flex_strlen (const char * s , yyscan_t yyscanner)
        -: 3416:{
        -: 3417:	int n;
        -: 3418:	for ( n = 0; s[n]; ++n )
        -: 3419:		;
        -: 3420:
        -: 3421:	return n;
        -: 3422:}
        -: 3423:#endif
        -: 3424:
    #####: 3425:void *yyalloc (yy_size_t  size , yyscan_t yyscanner)
        -: 3426:{
    #####: 3427:	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 3428:	(void)yyg;
    #####: 3429:	return malloc(size);
        -: 3430:}
        -: 3431:
    #####: 3432:void *yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)
        -: 3433:{
    #####: 3434:	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 3435:	(void)yyg;
        -: 3436:
        -: 3437:	/* The cast to (char *) in the following accommodates both
        -: 3438:	 * implementations that use char* generic pointers, and those
        -: 3439:	 * that use void* generic pointers.  It works with the latter
        -: 3440:	 * because both ANSI C and C++ allow castless assignment from
        -: 3441:	 * any pointer type to void*, and deal with argument conversions
        -: 3442:	 * as though doing an assignment.
        -: 3443:	 */
    #####: 3444:	return realloc(ptr, size);
        -: 3445:}
        -: 3446:
    #####: 3447:void yyfree (void * ptr , yyscan_t yyscanner)
        -: 3448:{
    #####: 3449:	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 3450:	(void)yyg;
    #####: 3451:	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
    #####: 3452:}
        -: 3453:
        -: 3454:#define YYTABLES_NAME "yytables"
        -: 3455:
        -: 3456:#line 738 "lexer.l"
        -: 3457:
        -: 3458:
        -: 3459:
        -: 3460:void yywarning(
        -: 3461:    yyscan_t yyscanner,
        -: 3462:    const char *message_fmt,
        -: 3463:    ...)
        -: 3464:{
        -: 3465:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -: 3466:
        -: 3467:  char* file_name;
        -: 3468:  char message[512];
        -: 3469:  va_list message_args;
        -: 3470:
        -: 3471:  if (compiler->callback == NULL)
        -: 3472:    return;
        -: 3473:
        -: 3474:  va_start(message_args, message_fmt);
        -: 3475:
        -: 3476:  if (compiler->file_name_stack_ptr > 0)
        -: 3477:    file_name = compiler->file_name_stack[compiler->file_name_stack_ptr - 1];
        -: 3478:  else
        -: 3479:    file_name = NULL;
        -: 3480:
        -: 3481:  vsnprintf(message, sizeof(message), message_fmt, message_args);
        -: 3482:
        -: 3483:  compiler->callback(
        -: 3484:      YARA_ERROR_LEVEL_WARNING,
        -: 3485:      file_name,
        -: 3486:      compiler->current_line ? compiler->current_line : yyget_lineno(yyscanner),
        -: 3487:      message,
        -: 3488:      compiler->user_data);
        -: 3489:
        -: 3490:  va_end(message_args);
        -: 3491:}
        -: 3492:
        -: 3493:
        -: 3494:void yyfatal(
        -: 3495:    yyscan_t yyscanner,
        -: 3496:    const char *error_message)
        -: 3497:{
        -: 3498:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -: 3499:
        -: 3500:  yyerror(yyscanner, compiler, error_message);
        -: 3501:  longjmp(compiler->error_recovery, 1);
        -: 3502:}
        -: 3503:
        -: 3504:
        -: 3505:void yyerror(
        -: 3506:    yyscan_t yyscanner,
        -: 3507:    YR_COMPILER* compiler,
        -: 3508:    const char *error_message)
        -: 3509:{
        -: 3510:  char message[512] = {'\0'};
        -: 3511:  char* file_name = NULL;
        -: 3512:
        -: 3513:  /*
        -: 3514:    if error_message != NULL the error comes from yyparse internal code
        -: 3515:    else the error comes from my code and the error code is set in
        -: 3516:    compiler->last_error
        -: 3517:  */
        -: 3518:
        -: 3519:  compiler->errors++;
        -: 3520:
        -: 3521:  if (compiler->current_line != 0)
        -: 3522:    compiler->last_error_line = compiler->current_line;
        -: 3523:  else
        -: 3524:    compiler->last_error_line = yyget_lineno(yyscanner);
        -: 3525:
        -: 3526:  compiler->current_line = 0;
        -: 3527:
        -: 3528:  if (compiler->file_name_stack_ptr > 0)
        -: 3529:  {
        -: 3530:    file_name = compiler->file_name_stack[compiler->file_name_stack_ptr - 1];
        -: 3531:  }
        -: 3532:  else
        -: 3533:  {
        -: 3534:    file_name = NULL;
        -: 3535:  }
        -: 3536:
        -: 3537:  if (error_message != NULL)
        -: 3538:  {
        -: 3539:    yr_compiler_set_error_extra_info(compiler, error_message);
        -: 3540:    compiler->last_error = ERROR_SYNTAX_ERROR;
        -: 3541:
        -: 3542:    if (compiler->callback != NULL)
        -: 3543:    {
        -: 3544:      compiler->callback(
        -: 3545:          YARA_ERROR_LEVEL_ERROR,
        -: 3546:          file_name,
        -: 3547:          compiler->last_error_line,
        -: 3548:          error_message,
        -: 3549:          compiler->user_data);
        -: 3550:    }
        -: 3551:  }
        -: 3552:  else if (compiler->callback != NULL)
        -: 3553:  {
        -: 3554:    yr_compiler_get_error_message(compiler, message, sizeof(message));
        -: 3555:
        -: 3556:    compiler->callback(
        -: 3557:      YARA_ERROR_LEVEL_ERROR,
        -: 3558:      file_name,
        -: 3559:      compiler->last_error_line,
        -: 3560:      message,
        -: 3561:      compiler->user_data);
        -: 3562:  }
        -: 3563:}
        -: 3564:
        -: 3565:
        -: 3566:int yr_lex_parse_rules_string(
        -: 3567:    const char* rules_string,
        -: 3568:    YR_COMPILER* compiler)
        -: 3569:{
        -: 3570:  yyscan_t yyscanner;
        -: 3571:
        -: 3572:  compiler->errors = 0;
        -: 3573:
        -: 3574:  if (setjmp(compiler->error_recovery) != 0)
        -: 3575:    return compiler->errors;
        -: 3576:
        -: 3577:  yylex_init(&yyscanner);
        -: 3578:
        -: 3579:  #if YYDEBUG
        -: 3580:  yydebug = 1;
        -: 3581:  #endif
        -: 3582:
        -: 3583:  yyset_extra(compiler, yyscanner);
        -: 3584:  yy_scan_string(rules_string, yyscanner);
        -: 3585:  yyset_lineno(1, yyscanner);
        -: 3586:  yyparse(yyscanner, compiler);
        -: 3587:  yylex_destroy(yyscanner);
        -: 3588:
        -: 3589:  return compiler->errors;
        -: 3590:}
        -: 3591:
        -: 3592:
        -: 3593:int yr_lex_parse_rules_file(
        -: 3594:    FILE* rules_file,
        -: 3595:    YR_COMPILER* compiler)
        -: 3596:{
        -: 3597:  yyscan_t yyscanner;
        -: 3598:
        -: 3599:  compiler->errors = 0;
        -: 3600:
        -: 3601:  if (setjmp(compiler->error_recovery) != 0)
        -: 3602:    return compiler->errors;
        -: 3603:
        -: 3604:  yylex_init(&yyscanner);
        -: 3605:
        -: 3606:  #if YYDEBUG
        -: 3607:  yydebug = 1;
        -: 3608:  #endif
        -: 3609:
        -: 3610:  yyset_in(rules_file, yyscanner);
        -: 3611:  yyset_extra(compiler, yyscanner);
        -: 3612:  yyparse(yyscanner, compiler);
        -: 3613:  yylex_destroy(yyscanner);
        -: 3614:
        -: 3615:  return compiler->errors;
        -: 3616:}
        -: 3617:
        -: 3618:
        -: 3619:int yr_lex_parse_rules_fd(
        -: 3620:    YR_FILE_DESCRIPTOR rules_fd,
        -: 3621:    YR_COMPILER* compiler)
        -: 3622:{
        -: 3623:  yyscan_t yyscanner;
        -: 3624:  size_t file_size;
        -: 3625:  void* buffer;
        -: 3626:
        -: 3627:  compiler->errors = 0;
        -: 3628:
        -: 3629:  if (setjmp(compiler->error_recovery) != 0)
        -: 3630:    return compiler->errors;
        -: 3631:
        -: 3632:  #if defined(_WIN32) || defined(__CYGWIN__)
        -: 3633:  file_size = (size_t) GetFileSize(rules_fd, NULL);
        -: 3634:  #else
        -: 3635:  struct stat fs;
        -: 3636:  if (fstat(rules_fd, &fs) != 0)
        -: 3637:  {
        -: 3638:    compiler->errors = 1;
        -: 3639:    compiler->last_error = ERROR_COULD_NOT_READ_FILE;
        -: 3640:    return compiler->errors;
        -: 3641:  }
        -: 3642:  file_size = (size_t) fs.st_size;
        -: 3643:  #endif
        -: 3644:
        -: 3645:  buffer = yr_malloc(file_size);
        -: 3646:
        -: 3647:  if (buffer == NULL)
        -: 3648:  {
        -: 3649:    compiler->errors = 1;
        -: 3650:    compiler->last_error = ERROR_INSUFFICIENT_MEMORY;
        -: 3651:    return compiler->errors;
        -: 3652:  }
        -: 3653:
        -: 3654:  #if defined(_WIN32) || defined(__CYGWIN__)
        -: 3655:  if (!ReadFile(rules_fd, buffer, file_size, NULL, NULL))
        -: 3656:  #else
        -: 3657:  if (read(rules_fd, buffer, file_size) != file_size)
        -: 3658:  #endif
        -: 3659:  {
        -: 3660:    yr_free(buffer);
        -: 3661:    compiler->errors = 1;
        -: 3662:    compiler->last_error = ERROR_COULD_NOT_READ_FILE;
        -: 3663:    return compiler->errors;
        -: 3664:  }
        -: 3665:
        -: 3666:  yylex_init(&yyscanner);
        -: 3667:
        -: 3668:  #if YYDEBUG
        -: 3669:  yydebug = 1;
        -: 3670:  #endif
        -: 3671:
        -: 3672:  yyset_extra(compiler, yyscanner);
        -: 3673:  yy_scan_bytes((const char*) buffer, file_size, yyscanner);
        -: 3674:  yyparse(yyscanner, compiler);
        -: 3675:  yylex_destroy(yyscanner);
        -: 3676:
        -: 3677:  yr_free(buffer);
        -: 3678:
        -: 3679:  return compiler->errors;
        -: 3680:}
        -: 3681:
