        -:    0:Source:lexer.l
        -:    0:Graph:/home/workspace/libyara/lexer.gcno
        -:    0:Data:/home/workspace/libyara/lexer.gcda
        -:    0:Runs:7
        -:    0:Programs:7
        -:    1:/*
        -:    2:Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/* Lexical analyzer for YARA */
        -:   31:
        -:   32:%{
        -:   33:
        -:   34:/* Disable warnings for unused functions in this file.
        -:   35:
        -:   36:As we redefine YY_FATAL_ERROR macro to use our own function yara_yyfatal, the
        -:   37:yy_fatal_error function generated by Flex is not actually used, causing a
        -:   38:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -:   39:function. When they include something like %option noyy_fatal_error as they do
        -:   40:with noyywrap then we can remove this pragma.
        -:   41:*/
        -:   42:
        -:   43:#ifdef __GNUC__
        -:   44:#pragma GCC diagnostic ignored "-Wunused-function"
        -:   45:#endif
        -:   46:
        -:   47:#include <math.h>
        -:   48:#include <stdarg.h>
        -:   49:#include <stdio.h>
        -:   50:#include <stdlib.h>
        -:   51:#include <string.h>
        -:   52:#include <setjmp.h>
        -:   53:
        -:   54:#if defined(_WIN32) || defined(__CYGWIN__)
        -:   55:#include <windows.h>
        -:   56:#else
        -:   57:#include <sys/stat.h>
        -:   58:#include <unistd.h>
        -:   59:#endif
        -:   60:
        -:   61:#if defined(_WIN32)
        -:   62:#define strtoll _strtoi64
        -:   63:#endif
        -:   64:
        -:   65:#include <yara/integers.h>
        -:   66:#include <yara/lexer.h>
        -:   67:#include <yara/sizedstr.h>
        -:   68:#include <yara/error.h>
        -:   69:#include <yara/mem.h>
        -:   70:#include <yara/utils.h>
        -:   71:#include <yara/strutils.h>
        -:   72:
        -:   73:#include "grammar.h"
        -:   74:
        -:   75:#define error(error_code) \
        -:   76:    { \
        -:   77:      compiler->last_error = error_code; \
        -:   78:      yyerror(yyscanner, compiler, NULL); \
        -:   79:      yyterminate(); \
        -:   80:    }
        -:   81:
        -:   82:#define syntax_error(error_msg) \
        -:   83:    { \
        -:   84:      yr_compiler_set_error_extra_info(compiler, error_msg); \
        -:   85:      error(ERROR_SYNTAX_ERROR); \
        -:   86:    }
        -:   87:
        -:   88:#define lex_check_space_ok(data, current_size, max_length) \
        -:   89:    if (strlen(data) + current_size >= max_length - 1) \
        -:   90:    { \
        -:   91:      yyerror(yyscanner, compiler, "out of space in lex_buf"); \
        -:   92:      yyterminate(); \
        -:   93:    }
        -:   94:
        -:   95:#define yytext_to_buffer \
        -:   96:    { \
        -:   97:      char *yptr = yytext; \
        -:   98:      lex_check_space_ok(yptr, yyextra->lex_buf_len, YR_LEX_BUF_SIZE); \
        -:   99:      while(*yptr) \
        -:  100:      { \
        -:  101:        *yyextra->lex_buf_ptr++ = *yptr++; \
        -:  102:        yyextra->lex_buf_len++; \
        -:  103:      } \
        -:  104:    }
        -:  105:
        -:  106:#define alloc_sized_string(str, str_len) \
        -:  107:  SIZED_STRING* str = (SIZED_STRING*) yr_malloc( \
        -:  108:      str_len + sizeof(SIZED_STRING)); \
        -:  109:  if (str == NULL) \
        -:  110:  { \
        -:  111:    yyerror(yyscanner, compiler, "not enough memory"); \
        -:  112:    yyterminate(); \
        -:  113:  } \
        -:  114:  else \
        -:  115:  { \
        -:  116:    str->length = (uint32_t) (str_len); \
        -:  117:    str->flags = 0; \
        -:  118:  } \
        -:  119:
        -:  120:#ifdef _WIN32
        -:  121:#define snprintf _snprintf
        -:  122:#endif
        -:  123:
    #####:  124:static bool is_absolute_path(
        -:  125:    char* path)
        -:  126:{
    #####:  127:  if (path == NULL)
    #####:  128:    return false;
        -:  129:
        -:  130:  #if defined(_WIN32) || defined(__CYGWIN__)
        -:  131:  return strlen(path) > 2 &&
        -:  132:      path[1] == ':' && (path[2] == '/' || path[2] == '\\');
        -:  133:  #else
    #####:  134:  return strlen(path) > 0 && path[0] == '/';
        -:  135:  #endif
        -:  136:}
        -:  137:
        -:  138:%}
        -:  139:
        -:  140:%option reentrant bison-bridge
        -:  141:%option noyywrap
        -:  142:%option nounistd
        -:  143:%option noinput
        -:  144:%option nounput
        -:  145:%option never-interactive
        -:  146:%option yylineno
        -:  147:%option prefix="yara_yy"
        -:  148:%option outfile="lex.yy.c"
        -:  149:
        -:  150:%option verbose
        -:  151:%option warn
        -:  152:
        -:  153:%x str
        -:  154:%x regexp
        -:  155:%x include
        -:  156:%x comment
        -:  157:
        -:  158:digit         [0-9]
        -:  159:letter        [a-zA-Z]
        -:  160:hexdigit      [a-fA-F0-9]
        -:  161:octdigit      [0-7]
        -:  162:
        -:  163:%%
        -:  164:
    #####:  165:".."                    { return _DOT_DOT_;     }
    #####:  166:"<"                     { return _LT_;          }
    #####:  167:">"                     { return _GT_;          }
    #####:  168:"<="                    { return _LE_;          }
    #####:  169:">="                    { return _GE_;          }
    #####:  170:"=="                    { return _EQ_;          }
    #####:  171:"!="                    { return _NEQ_;         }
    #####:  172:"<<"                    { return _SHIFT_LEFT_;  }
    #####:  173:">>"                    { return _SHIFT_RIGHT_; }
    #####:  174:"private"               { return _PRIVATE_;     }
    #####:  175:"global"                { return _GLOBAL_;      }
    #####:  176:"rule"                  { return _RULE_;        }
    #####:  177:"meta"                  { return _META_;        }
    #####:  178:"strings"               { return _STRINGS_;     }
    #####:  179:"ascii"                 { return _ASCII_;       }
    #####:  180:"wide"                  { return _WIDE_;        }
    #####:  181:"xor"                   { return _XOR_;         }
    #####:  182:"fullword"              { return _FULLWORD_;    }
    #####:  183:"nocase"                { return _NOCASE_;      }
    #####:  184:"condition"             { return _CONDITION_;   }
    #####:  185:"true"                  { return _TRUE_;        }
    #####:  186:"false"                 { return _FALSE_;       }
    #####:  187:"not"                   { return _NOT_;         }
    #####:  188:"and"                   { return _AND_;         }
    #####:  189:"or"                    { return _OR_;          }
    #####:  190:"at"                    { return _AT_;          }
    #####:  191:"in"                    { return _IN_;          }
    #####:  192:"of"                    { return _OF_;          }
    #####:  193:"them"                  { return _THEM_;        }
    #####:  194:"for"                   { return _FOR_;         }
    #####:  195:"all"                   { return _ALL_;         }
    #####:  196:"any"                   { return _ANY_;         }
    #####:  197:"entrypoint"            { return _ENTRYPOINT_;  }
    #####:  198:"filesize"              { return _FILESIZE_;    }
    #####:  199:"matches"               { return _MATCHES_;     }
    #####:  200:"contains"              { return _CONTAINS_;    }
    #####:  201:"import"                { return _IMPORT_;      }
    #####:  202:
    #####:  203:
    #####:  204:"/*"                    { BEGIN(comment);       }
    #####:  205:<comment>"*/"           { BEGIN(INITIAL);       }
    #####:  206:<comment>(.|\n)         { /* skip comments */   }
    #####:  207:
    #####:  208:
        -:  209:"//"[^\n]*              { /* skip single-line comments */ }
    #####:  210:
    #####:  211:
        -:  212:include[ \t]+\"         {
    #####:  213:                          yyextra->lex_buf_ptr = yyextra->lex_buf;
    #####:  214:                          yyextra->lex_buf_len = 0;
    #####:  215:                          BEGIN(include);
        -:  216:                        }
    #####:  217:
    #####:  218:
    #####:  219:<include>[^\"]+         { yytext_to_buffer; }
    #####:  220:
    #####:  221:
        -:  222:<include>\"             {
        -:  223:
    #####:  224:  if (compiler->include_callback != NULL)
        -:  225:  {
        -:  226:    #ifdef _MSC_VER
        -:  227:    char* b = NULL;
        -:  228:    #endif
    #####:  229:    char* s = NULL;
        -:  230:    char* f;
        -:  231:
        -:  232:    char buffer[1024];
        -:  233:    const char* included_rules;
        -:  234:    char* current_file_name;
        -:  235:    char* include_path;
        -:  236:
    #####:  237:    *yyextra->lex_buf_ptr = '\0'; // null-terminate included file path
        -:  238:
    #####:  239:    current_file_name = yr_compiler_get_current_file_name(compiler);
        -:  240:
    #####:  241:    if (current_file_name == NULL ||
    #####:  242:        compiler->include_callback != _yr_compiler_default_include_callback ||
    #####:  243:        is_absolute_path(yyextra->lex_buf))
        -:  244:    {
    #####:  245:      include_path = yyextra->lex_buf;
        -:  246:    }
        -:  247:    else
        -:  248:    {
    #####:  249:      strlcpy(buffer, current_file_name, sizeof(buffer));
    #####:  250:      s = strrchr(buffer, '/');
        -:  251:
        -:  252:      #ifdef _MSC_VER
        -:  253:      b = strrchr(buffer, '\\'); // in Windows both path delimiters are accepted
        -:  254:      #endif
        -:  255:
        -:  256:      #ifdef _MSC_VER
        -:  257:      if (s != NULL || b != NULL)
        -:  258:      #else
    #####:  259:      if (s != NULL)
        -:  260:      #endif
        -:  261:      {
        -:  262:        #ifdef _MSC_VER
        -:  263:        f = (b > s) ? (b + 1) : (s + 1);
        -:  264:        #else
    #####:  265:        f = s + 1;
        -:  266:        #endif
        -:  267:
    #####:  268:        strlcpy(f, yyextra->lex_buf, sizeof(buffer) - (f - buffer));
    #####:  269:        include_path = buffer;
        -:  270:      }
        -:  271:      else
        -:  272:      {
    #####:  273:        include_path = yyextra->lex_buf;
        -:  274:      }
        -:  275:    }
        -:  276:
    #####:  277:    included_rules = compiler->include_callback(
        -:  278:        include_path,
        -:  279:        current_file_name,
    #####:  280:        compiler->current_namespace->name,
        -:  281:        compiler->incl_clbk_user_data);
        -:  282:
    #####:  283:    if (included_rules != NULL)
        -:  284:    {
    #####:  285:      int error_code = _yr_compiler_push_file_name(compiler, include_path);
        -:  286:
    #####:  287:      if (error_code != ERROR_SUCCESS)
        -:  288:      {
    #####:  289:        if (error_code == ERROR_INCLUDES_CIRCULAR_REFERENCE)
        -:  290:        {
    #####:  291:          yyerror(yyscanner, compiler, "includes circular reference");
        -:  292:        }
    #####:  293:        else if (error_code == ERROR_INCLUDE_DEPTH_EXCEEDED)
        -:  294:        {
    #####:  295:          yyerror(yyscanner, compiler, "includes depth exceeded");
        -:  296:        }
        -:  297:
    #####:  298:        if (compiler->include_free != NULL)
        -:  299:        {
    #####:  300:          compiler->include_free(included_rules, compiler->incl_clbk_user_data);
        -:  301:        }
        -:  302:
    #####:  303:        yyterminate();
        -:  304:      }
        -:  305:
        -:  306:      // Workaround for flex issue: https://github.com/westes/flex/issues/58
    #####:  307:      yypush_buffer_state(YY_CURRENT_BUFFER, yyscanner);
    #####:  308:      yy_scan_string(included_rules, yyscanner);
    #####:  309:      yyset_lineno(1, yyscanner);
        -:  310:
    #####:  311:      if (compiler->include_free != NULL)
        -:  312:      {
    #####:  313:        compiler->include_free(included_rules, compiler->incl_clbk_user_data);
        -:  314:      }
        -:  315:    }
        -:  316:    else
        -:  317:    {
        -:  318:      char* err_msg_fmt;
        -:  319:      char err_msg[512];
        -:  320:
    #####:  321:      if (compiler->include_callback == _yr_compiler_default_include_callback)
        -:  322:      {
    #####:  323:        err_msg_fmt = "can't open include file: %s";
        -:  324:      }
        -:  325:      else
        -:  326:      {
    #####:  327:        err_msg_fmt = "callback failed to provide include resource: %s";
        -:  328:      }
        -:  329:
    #####:  330:      snprintf(
        -:  331:          err_msg,
        -:  332:          sizeof(err_msg),
        -:  333:          err_msg_fmt,
    #####:  334:          yyextra->lex_buf);
        -:  335:
    #####:  336:      yyerror(yyscanner, compiler, err_msg);
        -:  337:    }
        -:  338:
        -:  339:  }
        -:  340:  else // not allowing includes
        -:  341:  {
    #####:  342:    yyerror(yyscanner, compiler, "includes are disabled");
        -:  343:  }
        -:  344:
    #####:  345:  BEGIN(INITIAL);
        -:  346:}
    #####:  347:
    #####:  348:
        -:  349:<<EOF>> {
        -:  350:
    #####:  351:  yypop_buffer_state(yyscanner);
        -:  352:
    #####:  353:  if (!YY_CURRENT_BUFFER)
    #####:  354:    yyterminate();
        -:  355:
    #####:  356:  return _END_OF_INCLUDED_FILE_;
        -:  357:}
        -:  358:
    #####:  359:
        -:  360:$({letter}|{digit}|_)*"*"  {
        -:  361:
    #####:  362:  yylval->c_string = yr_strdup(yytext);
        -:  363:
    #####:  364:  if (yylval->c_string == NULL)
    #####:  365:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  366:
    #####:  367:  return _STRING_IDENTIFIER_WITH_WILDCARD_;
        -:  368:}
        -:  369:
    #####:  370:
        -:  371:$({letter}|{digit}|_)*  {
        -:  372:
    #####:  373:  yylval->c_string = yr_strdup(yytext);
        -:  374:
    #####:  375:  if (yylval->c_string == NULL)
    #####:  376:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  377:
    #####:  378:  return _STRING_IDENTIFIER_;
        -:  379:}
        -:  380:
    #####:  381:
        -:  382:#({letter}|{digit}|_)*  {
        -:  383:
    #####:  384:  yylval->c_string = yr_strdup(yytext);
        -:  385:
    #####:  386:  if (yylval->c_string == NULL)
        -:  387:  {
    #####:  388:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  389:  }
        -:  390:  else
        -:  391:  {
    #####:  392:    yylval->c_string[0] = '$'; /* replace # by $*/
        -:  393:  }
        -:  394:
    #####:  395:  return _STRING_COUNT_;
        -:  396:}
        -:  397:
    #####:  398:
        -:  399:@({letter}|{digit}|_)*  {
        -:  400:
    #####:  401:  yylval->c_string = yr_strdup(yytext);
        -:  402:
    #####:  403:  if (yylval->c_string == NULL)
        -:  404:  {
    #####:  405:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  406:  }
        -:  407:  else
        -:  408:  {
    #####:  409:    yylval->c_string[0] = '$'; /* replace @ by $*/
        -:  410:  }
        -:  411:
    #####:  412:  return _STRING_OFFSET_;
        -:  413:}
        -:  414:
    #####:  415:
        -:  416:!({letter}|{digit}|_)*  {
        -:  417:
    #####:  418:  yylval->c_string = yr_strdup(yytext);
        -:  419:
    #####:  420:  if (yylval->c_string == NULL)
        -:  421:  {
    #####:  422:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  423:  }
        -:  424:  else
        -:  425:  {
    #####:  426:    yylval->c_string[0] = '$'; /* replace ! by $*/
        -:  427:  }
        -:  428:
    #####:  429:  return _STRING_LENGTH_;
        -:  430:}
        -:  431:
    #####:  432:
        -:  433:u?int(8|16|32)(be)? {
        -:  434:
    #####:  435:  char* text = yytext;
        -:  436:
    #####:  437:  if (*text == 'u')
        -:  438:  {
    #####:  439:    yylval->integer = 3;
    #####:  440:    text++;
        -:  441:  }
        -:  442:  else
        -:  443:  {
    #####:  444:    yylval->integer = 0;
        -:  445:  }
        -:  446:
    #####:  447:  if (strstr(text, "int8") == text)
        -:  448:  {
    #####:  449:    yylval->integer += 0;
    #####:  450:    text += 4;
        -:  451:  }
    #####:  452:  else if (strstr(text, "int16") == text)
        -:  453:  {
    #####:  454:    yylval->integer += 1;
    #####:  455:    text += 5;
        -:  456:  }
    #####:  457:  else if (strstr(text, "int32") == text)
        -:  458:  {
    #####:  459:    yylval->integer += 2;
    #####:  460:    text += 5;
        -:  461:  }
        -:  462:
    #####:  463:  if (strcmp(text, "be") == 0)
        -:  464:  {
    #####:  465:    yylval->integer += 6;
        -:  466:  }
        -:  467:
    #####:  468:  return _INTEGER_FUNCTION_;
        -:  469:}
        -:  470:
    #####:  471:
        -:  472:({letter}|_)({letter}|{digit}|_)*  {
        -:  473:
    #####:  474:  if (strlen(yytext) > 128)
    #####:  475:    syntax_error("identifier too long");
        -:  476:
    #####:  477:  yylval->c_string = yr_strdup(yytext);
        -:  478:
    #####:  479:  if (yylval->c_string == NULL)
    #####:  480:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  481:
    #####:  482:  return _IDENTIFIER_;
        -:  483:}
        -:  484:
    #####:  485:
        -:  486:{digit}+(MB|KB){0,1}  {
        -:  487:
        -:  488:  char *endptr;
        -:  489:
    #####:  490:  errno = 0;
    #####:  491:  yylval->integer = strtoll(yytext, &endptr, 10);
        -:  492:
    #####:  493:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -:  494:  {
    #####:  495:    yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  496:    error(ERROR_INTEGER_OVERFLOW);
        -:  497:  }
    #####:  498:  else if (strstr(yytext, "KB") != NULL)
        -:  499:  {
    #####:  500:    if (yylval->integer > LLONG_MAX / 1024)
        -:  501:    {
    #####:  502:      yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  503:      error(ERROR_INTEGER_OVERFLOW);
        -:  504:    }
        -:  505:    else
        -:  506:    {
    #####:  507:      yylval->integer *= 1024;
        -:  508:    }
        -:  509:  }
    #####:  510:  else if (strstr(yytext, "MB") != NULL)
        -:  511:  {
    #####:  512:    if (yylval->integer > LLONG_MAX / 1048576)
        -:  513:    {
    #####:  514:      yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  515:      error(ERROR_INTEGER_OVERFLOW);
        -:  516:    }
        -:  517:    else
        -:  518:    {
    #####:  519:      yylval->integer *= 1048576;
        -:  520:    }
        -:  521:  }
        -:  522:
    #####:  523:  return _NUMBER_;
        -:  524:}
        -:  525:
    #####:  526:{digit}+"."{digit}+  {
    #####:  527:  yylval->double_ = atof(yytext);
    #####:  528:  return _DOUBLE_;
        -:  529:}
        -:  530:
    #####:  531:0x{hexdigit}+  {
        -:  532:
        -:  533:  char *endptr;
        -:  534:
    #####:  535:  errno = 0;
    #####:  536:  yylval->integer = strtoll(yytext, &endptr, 16);
        -:  537:
    #####:  538:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -:  539:  {
    #####:  540:    yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  541:    error(ERROR_INTEGER_OVERFLOW);
        -:  542:  }
        -:  543:
    #####:  544:  return _NUMBER_;
        -:  545:}
        -:  546:
    #####:  547:0o{octdigit}+  {
        -:  548:
        -:  549:  char *endptr;
        -:  550:
    #####:  551:  errno = 0;
    #####:  552:  yylval->integer = strtoll(yytext + 2, &endptr, 8);
        -:  553:
    #####:  554:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -:  555:  {
    #####:  556:    yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  557:    error(ERROR_INTEGER_OVERFLOW);
        -:  558:  }
        -:  559:
    #####:  560:  return _NUMBER_;
        -:  561:}
        -:  562:
    #####:  563:
        -:  564:<str>\"   {     /* saw closing quote - all done */
        -:  565:
    #####:  566:  alloc_sized_string(s, yyextra->lex_buf_len);
        -:  567:
    #####:  568:  *yyextra->lex_buf_ptr = '\0';
    #####:  569:  memcpy(s->c_string, yyextra->lex_buf, yyextra->lex_buf_len + 1);
    #####:  570:  yylval->sized_string = s;
        -:  571:
    #####:  572:  BEGIN(INITIAL);
        -:  573:
    #####:  574:  return _TEXT_STRING_;
        -:  575:}
        -:  576:
    #####:  577:
        -:  578:<str>\\t   {
        -:  579:
    #####:  580:  lex_check_space_ok("\t", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  581:  *yyextra->lex_buf_ptr++ = '\t';
    #####:  582:  yyextra->lex_buf_len++;
        -:  583:}
    #####:  584:
    #####:  585:
        -:  586:<str>\\n   {
        -:  587:
    #####:  588:  lex_check_space_ok("\n", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  589:  *yyextra->lex_buf_ptr++ = '\n';
    #####:  590:  yyextra->lex_buf_len++;
        -:  591:}
    #####:  592:
    #####:  593:
        -:  594:<str>\\\"   {
        -:  595:
    #####:  596:  lex_check_space_ok("\"", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  597:  *yyextra->lex_buf_ptr++ = '\"';
    #####:  598:  yyextra->lex_buf_len++;
        -:  599:}
    #####:  600:
    #####:  601:
        -:  602:<str>\\\\   {
        -:  603:
    #####:  604:  lex_check_space_ok("\\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  605:  *yyextra->lex_buf_ptr++ = '\\';
    #####:  606:  yyextra->lex_buf_len++;
        -:  607:}
    #####:  608:
    #####:  609:
        -:  610:<str>\\x{hexdigit}{2} {
        -:  611:
        -:  612:   int result;
        -:  613:
    #####:  614:   sscanf( yytext + 2, "%x", &result );
    #####:  615:   lex_check_space_ok("X", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  616:   *yyextra->lex_buf_ptr++ = result;
    #####:  617:   yyextra->lex_buf_len++;
        -:  618:}
    #####:  619:
    #####:  620:
    #####:  621:<str>[^\\\n\"]+   { yytext_to_buffer; }
    #####:  622:
    #####:  623:
        -:  624:<str>\n  {
    #####:  625:  syntax_error("unterminated string");
        -:  626:}
        -:  627:
    #####:  628:
        -:  629:<str>\\(.|\n) {
    #####:  630:  syntax_error("illegal escape sequence");
        -:  631:}
        -:  632:
    #####:  633:
        -:  634:<regexp>\/i?s?  {
        -:  635:
    #####:  636:  if (yyextra->lex_buf_len > 0)
        -:  637:  {
    #####:  638:    alloc_sized_string(s, yyextra->lex_buf_len);
        -:  639:
    #####:  640:    if (yytext[1] == 'i')
    #####:  641:      s->flags |= SIZED_STRING_FLAGS_NO_CASE;
        -:  642:
    #####:  643:    if (yytext[1] == 's' || yytext[2] == 's')
    #####:  644:      s->flags |= SIZED_STRING_FLAGS_DOT_ALL;
        -:  645:
    #####:  646:    *yyextra->lex_buf_ptr = '\0';
    #####:  647:    strlcpy(s->c_string, yyextra->lex_buf, s->length + 1);
    #####:  648:    yylval->sized_string = s;
        -:  649:  }
        -:  650:  else
        -:  651:  {
    #####:  652:    syntax_error("empty regular expression");
        -:  653:  }
        -:  654:
    #####:  655:  BEGIN(INITIAL);
    #####:  656:  return _REGEXP_;
        -:  657:}
        -:  658:
    #####:  659:
        -:  660:<regexp>\\\/  {
        -:  661:
    #####:  662:  lex_check_space_ok("/", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  663:  *yyextra->lex_buf_ptr++ = '/';
    #####:  664:  yyextra->lex_buf_len++ ;
        -:  665:}
    #####:  666:
    #####:  667:
        -:  668:<regexp>\\. {
        -:  669:
    #####:  670:  lex_check_space_ok("\\.", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
        -:  671:
    #####:  672:  if (yytext[1] == 0)
    #####:  673:    syntax_error("malformed regular expression");
        -:  674:
    #####:  675:  *yyextra->lex_buf_ptr++ = yytext[0];
    #####:  676:  *yyextra->lex_buf_ptr++ = yytext[1];
    #####:  677:  yyextra->lex_buf_len += 2;
        -:  678:}
    #####:  679:
    #####:  680:
    #####:  681:<regexp>[^/\n\\]+ { yytext_to_buffer; }
    #####:  682:
    #####:  683:
        -:  684:<regexp>\n  {
    #####:  685:  syntax_error("unterminated regular expression");
        -:  686:}
        -:  687:
    #####:  688:
        -:  689:\"  {
        -:  690:
    #####:  691:  yylval->sized_string = NULL;
    #####:  692:  yyextra->lex_buf_ptr = yyextra->lex_buf;
    #####:  693:  yyextra->lex_buf_len = 0;
    #####:  694:  BEGIN(str);
        -:  695:}
    #####:  696:
    #####:  697:
        -:  698:"/"  {
        -:  699:
    #####:  700:  yylval->sized_string = NULL;
    #####:  701:  yyextra->lex_buf_ptr = yyextra->lex_buf;
    #####:  702:  yyextra->lex_buf_len = 0;
    #####:  703:  BEGIN(regexp);
        -:  704:}
    #####:  705:
    #####:  706:
        -:  707:\{(({hexdigit}|[ \-|\?\[\]\(\)\n\r\t]|\/\*[^*]*\*+([^*/][^*]*\*+)*\/)+|\/\/.*)+\}  {
        -:  708:  // Match hex-digits with whitespace or comments. The latter are stripped
        -:  709:  // out by hex_lexer.l
        -:  710:  // TODO(vmalvarez): Integrate the hex string lexer and parser into this one,
        -:  711:  // by having a single lexer/parser instead of two different ones we can avoid
        -:  712:  // complex regular expressions like the one above, which is actually trying to
        -:  713:  // do some parsing in the lexer.
        -:  714:
    #####:  715:  alloc_sized_string(s, strlen(yytext));
        -:  716:
    #####:  717:  strlcpy(s->c_string, yytext, s->length + 1);
    #####:  718:  yylval->sized_string = s;
        -:  719:
    #####:  720:  return _HEX_STRING_;
        -:  721:}
        -:  722:
    #####:  723:
        -:  724:[ \t\r\n]   /* skip whitespace */
    #####:  725:
    #####:  726:.   {
        -:  727:
    #####:  728:  if (yytext[0] >= 32 && yytext[0] < 127)
        -:  729:  {
    #####:  730:    return yytext[0];
        -:  731:  }
        -:  732:  else
        -:  733:  {
    #####:  734:    syntax_error("non-ascii character");
        -:  735:  }
        -:  736:}
        -:  737:
    #####:  738:%%
    #####:  739:
        -:  740:
    #####:  741:void yywarning(
        -:  742:    yyscan_t yyscanner,
        -:  743:    const char *message_fmt,
        -:  744:    ...)
        -:  745:{
    #####:  746:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  747:
        -:  748:  char* file_name;
        -:  749:  char message[512];
        -:  750:  va_list message_args;
        -:  751:
    #####:  752:  if (compiler->callback == NULL)
    #####:  753:    return;
        -:  754:
    #####:  755:  va_start(message_args, message_fmt);
        -:  756:
    #####:  757:  if (compiler->file_name_stack_ptr > 0)
    #####:  758:    file_name = compiler->file_name_stack[compiler->file_name_stack_ptr - 1];
        -:  759:  else
    #####:  760:    file_name = NULL;
        -:  761:
    #####:  762:  vsnprintf(message, sizeof(message), message_fmt, message_args);
        -:  763:
    #####:  764:  compiler->callback(
        -:  765:      YARA_ERROR_LEVEL_WARNING,
        -:  766:      file_name,
    #####:  767:      compiler->current_line ? compiler->current_line : yyget_lineno(yyscanner),
        -:  768:      message,
        -:  769:      compiler->user_data);
        -:  770:
    #####:  771:  va_end(message_args);
        -:  772:}
        -:  773:
        -:  774:
    #####:  775:void yyfatal(
        -:  776:    yyscan_t yyscanner,
        -:  777:    const char *error_message)
        -:  778:{
    #####:  779:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  780:
    #####:  781:  yyerror(yyscanner, compiler, error_message);
    #####:  782:  longjmp(compiler->error_recovery, 1);
        -:  783:}
        -:  784:
        -:  785:
    #####:  786:void yyerror(
        -:  787:    yyscan_t yyscanner,
        -:  788:    YR_COMPILER* compiler,
        -:  789:    const char *error_message)
        -:  790:{
    #####:  791:  char message[512] = {'\0'};
    #####:  792:  char* file_name = NULL;
        -:  793:
        -:  794:  /*
        -:  795:    if error_message != NULL the error comes from yyparse internal code
        -:  796:    else the error comes from my code and the error code is set in
        -:  797:    compiler->last_error
        -:  798:  */
        -:  799:
    #####:  800:  compiler->errors++;
        -:  801:
    #####:  802:  if (compiler->current_line != 0)
    #####:  803:    compiler->last_error_line = compiler->current_line;
        -:  804:  else
    #####:  805:    compiler->last_error_line = yyget_lineno(yyscanner);
        -:  806:
    #####:  807:  compiler->current_line = 0;
        -:  808:
    #####:  809:  if (compiler->file_name_stack_ptr > 0)
        -:  810:  {
    #####:  811:    file_name = compiler->file_name_stack[compiler->file_name_stack_ptr - 1];
        -:  812:  }
        -:  813:  else
        -:  814:  {
    #####:  815:    file_name = NULL;
        -:  816:  }
        -:  817:
    #####:  818:  if (error_message != NULL)
        -:  819:  {
    #####:  820:    yr_compiler_set_error_extra_info(compiler, error_message);
    #####:  821:    compiler->last_error = ERROR_SYNTAX_ERROR;
        -:  822:
    #####:  823:    if (compiler->callback != NULL)
        -:  824:    {
    #####:  825:      compiler->callback(
        -:  826:          YARA_ERROR_LEVEL_ERROR,
        -:  827:          file_name,
        -:  828:          compiler->last_error_line,
        -:  829:          error_message,
        -:  830:          compiler->user_data);
        -:  831:    }
        -:  832:  }
    #####:  833:  else if (compiler->callback != NULL)
        -:  834:  {
    #####:  835:    yr_compiler_get_error_message(compiler, message, sizeof(message));
        -:  836:
    #####:  837:    compiler->callback(
        -:  838:      YARA_ERROR_LEVEL_ERROR,
        -:  839:      file_name,
        -:  840:      compiler->last_error_line,
        -:  841:      message,
        -:  842:      compiler->user_data);
        -:  843:  }
    #####:  844:}
        -:  845:
        -:  846:
    #####:  847:int yr_lex_parse_rules_string(
        -:  848:    const char* rules_string,
        -:  849:    YR_COMPILER* compiler)
        -:  850:{
        -:  851:  yyscan_t yyscanner;
        -:  852:
    #####:  853:  compiler->errors = 0;
        -:  854:
    #####:  855:  if (setjmp(compiler->error_recovery) != 0)
    #####:  856:    return compiler->errors;
        -:  857:
    #####:  858:  yylex_init(&yyscanner);
        -:  859:
        -:  860:  #if YYDEBUG
        -:  861:  yydebug = 1;
        -:  862:  #endif
        -:  863:
    #####:  864:  yyset_extra(compiler, yyscanner);
    #####:  865:  yy_scan_string(rules_string, yyscanner);
    #####:  866:  yyset_lineno(1, yyscanner);
    #####:  867:  yyparse(yyscanner, compiler);
    #####:  868:  yylex_destroy(yyscanner);
        -:  869:
    #####:  870:  return compiler->errors;
        -:  871:}
        -:  872:
        -:  873:
    #####:  874:int yr_lex_parse_rules_file(
        -:  875:    FILE* rules_file,
        -:  876:    YR_COMPILER* compiler)
        -:  877:{
        -:  878:  yyscan_t yyscanner;
        -:  879:
    #####:  880:  compiler->errors = 0;
        -:  881:
    #####:  882:  if (setjmp(compiler->error_recovery) != 0)
    #####:  883:    return compiler->errors;
        -:  884:
    #####:  885:  yylex_init(&yyscanner);
        -:  886:
        -:  887:  #if YYDEBUG
        -:  888:  yydebug = 1;
        -:  889:  #endif
        -:  890:
    #####:  891:  yyset_in(rules_file, yyscanner);
    #####:  892:  yyset_extra(compiler, yyscanner);
    #####:  893:  yyparse(yyscanner, compiler);
    #####:  894:  yylex_destroy(yyscanner);
        -:  895:
    #####:  896:  return compiler->errors;
        -:  897:}
        -:  898:
        -:  899:
    #####:  900:int yr_lex_parse_rules_fd(
        -:  901:    YR_FILE_DESCRIPTOR rules_fd,
        -:  902:    YR_COMPILER* compiler)
        -:  903:{
        -:  904:  yyscan_t yyscanner;
        -:  905:  size_t file_size;
        -:  906:  void* buffer;
        -:  907:
    #####:  908:  compiler->errors = 0;
        -:  909:
    #####:  910:  if (setjmp(compiler->error_recovery) != 0)
    #####:  911:    return compiler->errors;
        -:  912:
        -:  913:  #if defined(_WIN32) || defined(__CYGWIN__)
        -:  914:  file_size = (size_t) GetFileSize(rules_fd, NULL);
        -:  915:  #else
        -:  916:  struct stat fs;
    #####:  917:  if (fstat(rules_fd, &fs) != 0)
        -:  918:  {
    #####:  919:    compiler->errors = 1;
    #####:  920:    compiler->last_error = ERROR_COULD_NOT_READ_FILE;
    #####:  921:    return compiler->errors;
        -:  922:  }
    #####:  923:  file_size = (size_t) fs.st_size;
        -:  924:  #endif
        -:  925:
    #####:  926:  buffer = yr_malloc(file_size);
        -:  927:
    #####:  928:  if (buffer == NULL)
        -:  929:  {
    #####:  930:    compiler->errors = 1;
    #####:  931:    compiler->last_error = ERROR_INSUFFICIENT_MEMORY;
    #####:  932:    return compiler->errors;
        -:  933:  }
        -:  934:
        -:  935:  #if defined(_WIN32) || defined(__CYGWIN__)
        -:  936:  if (!ReadFile(rules_fd, buffer, file_size, NULL, NULL))
        -:  937:  #else
    #####:  938:  if (read(rules_fd, buffer, file_size) != file_size)
        -:  939:  #endif
        -:  940:  {
    #####:  941:    yr_free(buffer);
    #####:  942:    compiler->errors = 1;
    #####:  943:    compiler->last_error = ERROR_COULD_NOT_READ_FILE;
    #####:  944:    return compiler->errors;
        -:  945:  }
        -:  946:
    #####:  947:  yylex_init(&yyscanner);
        -:  948:
        -:  949:  #if YYDEBUG
        -:  950:  yydebug = 1;
        -:  951:  #endif
        -:  952:
    #####:  953:  yyset_extra(compiler, yyscanner);
    #####:  954:  yy_scan_bytes((const char*) buffer, file_size, yyscanner);
    #####:  955:  yyparse(yyscanner, compiler);
    #####:  956:  yylex_destroy(yyscanner);
        -:  957:
    #####:  958:  yr_free(buffer);
        -:  959:
    #####:  960:  return compiler->errors;
        -:  961:}
