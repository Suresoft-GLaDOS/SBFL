        -:    0:Source:re_grammar.c
        -:    0:Graph:/home/workspace/libyara/re_grammar.gcno
        -:    0:Data:/home/workspace/libyara/re_grammar.gcda
        -:    0:Runs:8
        -:    0:Programs:8
        -:    1:/* A Bison parser, made by GNU Bison 3.0.4.  */
        -:    2:
        -:    3:/* Bison implementation for Yacc-like parsers in C
        -:    4:
        -:    5:   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
        -:    6:
        -:    7:   This program is free software: you can redistribute it and/or modify
        -:    8:   it under the terms of the GNU General Public License as published by
        -:    9:   the Free Software Foundation, either version 3 of the License, or
        -:   10:   (at your option) any later version.
        -:   11:
        -:   12:   This program is distributed in the hope that it will be useful,
        -:   13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   15:   GNU General Public License for more details.
        -:   16:
        -:   17:   You should have received a copy of the GNU General Public License
        -:   18:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   19:
        -:   20:/* As a special exception, you may create a larger work that contains
        -:   21:   part or all of the Bison parser skeleton and distribute that work
        -:   22:   under terms of your choice, so long as that work isn't itself a
        -:   23:   parser generator using the skeleton or a modified version thereof
        -:   24:   as a parser skeleton.  Alternatively, if you modify or redistribute
        -:   25:   the parser skeleton itself, you may (at your option) remove this
        -:   26:   special exception, which will cause the skeleton and the resulting
        -:   27:   Bison output files to be licensed under the GNU General Public
        -:   28:   License without this special exception.
        -:   29:
        -:   30:   This special exception was added by the Free Software Foundation in
        -:   31:   version 2.2 of Bison.  */
        -:   32:
        -:   33:/* C LALR(1) parser skeleton written by Richard Stallman, by
        -:   34:   simplifying the original so-called "semantic" parser.  */
        -:   35:
        -:   36:/* All symbols defined below should begin with yy or YY, to avoid
        -:   37:   infringing on user name space.  This should be done even for local
        -:   38:   variables, as they might otherwise be expanded by user macros.
        -:   39:   There are some unavoidable exceptions within include files to
        -:   40:   define necessary library symbols; they are noted "INFRINGES ON
        -:   41:   USER NAME SPACE" below.  */
        -:   42:
        -:   43:/* Identify Bison output.  */
        -:   44:#define YYBISON 1
        -:   45:
        -:   46:/* Bison version.  */
        -:   47:#define YYBISON_VERSION "3.0.4"
        -:   48:
        -:   49:/* Skeleton name.  */
        -:   50:#define YYSKELETON_NAME "yacc.c"
        -:   51:
        -:   52:/* Pure parsers.  */
        -:   53:#define YYPURE 1
        -:   54:
        -:   55:/* Push parsers.  */
        -:   56:#define YYPUSH 0
        -:   57:
        -:   58:/* Pull parsers.  */
        -:   59:#define YYPULL 1
        -:   60:
        -:   61:
        -:   62:/* Substitute the variable and function names.  */
        -:   63:#define yyparse         re_yyparse
        -:   64:#define yylex           re_yylex
        -:   65:#define yyerror         re_yyerror
        -:   66:#define yydebug         re_yydebug
        -:   67:#define yynerrs         re_yynerrs
        -:   68:
        -:   69:
        -:   70:/* Copy the first part of user declarations.  */
        -:   71:#line 30 "re_grammar.y" /* yacc.c:339  */
        -:   72:
        -:   73:
        -:   74:#include <yara/integers.h>
        -:   75:#include <yara/utils.h>
        -:   76:#include <yara/error.h>
        -:   77:#include <yara/limits.h>
        -:   78:#include <yara/mem.h>
        -:   79:#include <yara/re.h>
        -:   80:#include <yara/re_lexer.h>
        -:   81:
        -:   82:
        -:   83:#define YYERROR_VERBOSE
        -:   84:
        -:   85:#define YYMALLOC yr_malloc
        -:   86:#define YYFREE yr_free
        -:   87:
        -:   88:#define mark_as_not_fast_regexp() \
        -:   89:    ((RE_AST*) yyget_extra(yyscanner))->flags &= ~RE_FLAGS_FAST_REGEXP
        -:   90:
        -:   91:#define fail_if(x, error) \
        -:   92:    if (x) \
        -:   93:    { \
        -:   94:      lex_env->last_error = error; \
        -:   95:      YYABORT; \
        -:   96:    } \
        -:   97:
        -:   98:#define destroy_node_if(x, node) \
        -:   99:    if (x) \
        -:  100:    { \
        -:  101:      yr_re_node_destroy(node); \
        -:  102:    } \
        -:  103:
        -:  104:
        -:  105:#line 106 "re_grammar.c" /* yacc.c:339  */
        -:  106:
        -:  107:# ifndef YY_NULLPTR
        -:  108:#  if defined __cplusplus && 201103L <= __cplusplus
        -:  109:#   define YY_NULLPTR nullptr
        -:  110:#  else
        -:  111:#   define YY_NULLPTR 0
        -:  112:#  endif
        -:  113:# endif
        -:  114:
        -:  115:/* Enabling verbose error messages.  */
        -:  116:#ifdef YYERROR_VERBOSE
        -:  117:# undef YYERROR_VERBOSE
        -:  118:# define YYERROR_VERBOSE 1
        -:  119:#else
        -:  120:# define YYERROR_VERBOSE 0
        -:  121:#endif
        -:  122:
        -:  123:/* In a future release of Bison, this section will be replaced
        -:  124:   by #include "y.tab.h".  */
        -:  125:#ifndef YY_RE_YY_RE_GRAMMAR_H_INCLUDED
        -:  126:# define YY_RE_YY_RE_GRAMMAR_H_INCLUDED
        -:  127:/* Debug traces.  */
        -:  128:#ifndef YYDEBUG
        -:  129:# define YYDEBUG 0
        -:  130:#endif
        -:  131:#if YYDEBUG
        -:  132:extern int re_yydebug;
        -:  133:#endif
        -:  134:
        -:  135:/* Token type.  */
        -:  136:#ifndef YYTOKENTYPE
        -:  137:# define YYTOKENTYPE
        -:  138:  enum yytokentype
        -:  139:  {
        -:  140:    _CHAR_ = 258,
        -:  141:    _ANY_ = 259,
        -:  142:    _RANGE_ = 260,
        -:  143:    _CLASS_ = 261,
        -:  144:    _WORD_CHAR_ = 262,
        -:  145:    _NON_WORD_CHAR_ = 263,
        -:  146:    _SPACE_ = 264,
        -:  147:    _NON_SPACE_ = 265,
        -:  148:    _DIGIT_ = 266,
        -:  149:    _NON_DIGIT_ = 267,
        -:  150:    _WORD_BOUNDARY_ = 268,
        -:  151:    _NON_WORD_BOUNDARY_ = 269
        -:  152:  };
        -:  153:#endif
        -:  154:/* Tokens.  */
        -:  155:#define _CHAR_ 258
        -:  156:#define _ANY_ 259
        -:  157:#define _RANGE_ 260
        -:  158:#define _CLASS_ 261
        -:  159:#define _WORD_CHAR_ 262
        -:  160:#define _NON_WORD_CHAR_ 263
        -:  161:#define _SPACE_ 264
        -:  162:#define _NON_SPACE_ 265
        -:  163:#define _DIGIT_ 266
        -:  164:#define _NON_DIGIT_ 267
        -:  165:#define _WORD_BOUNDARY_ 268
        -:  166:#define _NON_WORD_BOUNDARY_ 269
        -:  167:
        -:  168:/* Value type.  */
        -:  169:#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
        -:  170:
        -:  171:union YYSTYPE
        -:  172:{
        -:  173:#line 73 "re_grammar.y" /* yacc.c:355  */
        -:  174:
        -:  175:  int integer;
        -:  176:  uint32_t range;
        -:  177:  RE_NODE* re_node;
        -:  178:  RE_CLASS* re_class;
        -:  179:
        -:  180:#line 181 "re_grammar.c" /* yacc.c:355  */
        -:  181:};
        -:  182:
        -:  183:typedef union YYSTYPE YYSTYPE;
        -:  184:# define YYSTYPE_IS_TRIVIAL 1
        -:  185:# define YYSTYPE_IS_DECLARED 1
        -:  186:#endif
        -:  187:
        -:  188:
        -:  189:
        -:  190:int re_yyparse (void *yyscanner, RE_LEX_ENVIRONMENT *lex_env);
        -:  191:
        -:  192:#endif /* !YY_RE_YY_RE_GRAMMAR_H_INCLUDED  */
        -:  193:
        -:  194:/* Copy the second part of user declarations.  */
        -:  195:
        -:  196:#line 197 "re_grammar.c" /* yacc.c:358  */
        -:  197:
        -:  198:#ifdef short
        -:  199:# undef short
        -:  200:#endif
        -:  201:
        -:  202:#ifdef YYTYPE_UINT8
        -:  203:typedef YYTYPE_UINT8 yytype_uint8;
        -:  204:#else
        -:  205:typedef unsigned char yytype_uint8;
        -:  206:#endif
        -:  207:
        -:  208:#ifdef YYTYPE_INT8
        -:  209:typedef YYTYPE_INT8 yytype_int8;
        -:  210:#else
        -:  211:typedef signed char yytype_int8;
        -:  212:#endif
        -:  213:
        -:  214:#ifdef YYTYPE_UINT16
        -:  215:typedef YYTYPE_UINT16 yytype_uint16;
        -:  216:#else
        -:  217:typedef unsigned short int yytype_uint16;
        -:  218:#endif
        -:  219:
        -:  220:#ifdef YYTYPE_INT16
        -:  221:typedef YYTYPE_INT16 yytype_int16;
        -:  222:#else
        -:  223:typedef short int yytype_int16;
        -:  224:#endif
        -:  225:
        -:  226:#ifndef YYSIZE_T
        -:  227:# ifdef __SIZE_TYPE__
        -:  228:#  define YYSIZE_T __SIZE_TYPE__
        -:  229:# elif defined size_t
        -:  230:#  define YYSIZE_T size_t
        -:  231:# elif ! defined YYSIZE_T
        -:  232:#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  233:#  define YYSIZE_T size_t
        -:  234:# else
        -:  235:#  define YYSIZE_T unsigned int
        -:  236:# endif
        -:  237:#endif
        -:  238:
        -:  239:#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
        -:  240:
        -:  241:#ifndef YY_
        -:  242:# if defined YYENABLE_NLS && YYENABLE_NLS
        -:  243:#  if ENABLE_NLS
        -:  244:#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
        -:  245:#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
        -:  246:#  endif
        -:  247:# endif
        -:  248:# ifndef YY_
        -:  249:#  define YY_(Msgid) Msgid
        -:  250:# endif
        -:  251:#endif
        -:  252:
        -:  253:#ifndef YY_ATTRIBUTE
        -:  254:# if (defined __GNUC__                                               \
        -:  255:      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
        -:  256:     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
        -:  257:#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
        -:  258:# else
        -:  259:#  define YY_ATTRIBUTE(Spec) /* empty */
        -:  260:# endif
        -:  261:#endif
        -:  262:
        -:  263:#ifndef YY_ATTRIBUTE_PURE
        -:  264:# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
        -:  265:#endif
        -:  266:
        -:  267:#ifndef YY_ATTRIBUTE_UNUSED
        -:  268:# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
        -:  269:#endif
        -:  270:
        -:  271:#if !defined _Noreturn \
        -:  272:     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
        -:  273:# if defined _MSC_VER && 1200 <= _MSC_VER
        -:  274:#  define _Noreturn __declspec (noreturn)
        -:  275:# else
        -:  276:#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
        -:  277:# endif
        -:  278:#endif
        -:  279:
        -:  280:/* Suppress unused-variable warnings by "using" E.  */
        -:  281:#if ! defined lint || defined __GNUC__
        -:  282:# define YYUSE(E) ((void) (E))
        -:  283:#else
        -:  284:# define YYUSE(E) /* empty */
        -:  285:#endif
        -:  286:
        -:  287:#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
        -:  288:/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
        -:  289:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
        -:  290:    _Pragma ("GCC diagnostic push") \
        -:  291:    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
        -:  292:    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
        -:  293:# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
        -:  294:    _Pragma ("GCC diagnostic pop")
        -:  295:#else
        -:  296:# define YY_INITIAL_VALUE(Value) Value
        -:  297:#endif
        -:  298:#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  299:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  300:# define YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  301:#endif
        -:  302:#ifndef YY_INITIAL_VALUE
        -:  303:# define YY_INITIAL_VALUE(Value) /* Nothing. */
        -:  304:#endif
        -:  305:
        -:  306:
        -:  307:#if ! defined yyoverflow || YYERROR_VERBOSE
        -:  308:
        -:  309:/* The parser invokes alloca or malloc; define the necessary symbols.  */
        -:  310:
        -:  311:# ifdef YYSTACK_USE_ALLOCA
        -:  312:#  if YYSTACK_USE_ALLOCA
        -:  313:#   ifdef __GNUC__
        -:  314:#    define YYSTACK_ALLOC __builtin_alloca
        -:  315:#   elif defined __BUILTIN_VA_ARG_INCR
        -:  316:#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
        -:  317:#   elif defined _AIX
        -:  318:#    define YYSTACK_ALLOC __alloca
        -:  319:#   elif defined _MSC_VER
        -:  320:#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
        -:  321:#    define alloca _alloca
        -:  322:#   else
        -:  323:#    define YYSTACK_ALLOC alloca
        -:  324:#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
        -:  325:#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  326:      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
        -:  327:#     ifndef EXIT_SUCCESS
        -:  328:#      define EXIT_SUCCESS 0
        -:  329:#     endif
        -:  330:#    endif
        -:  331:#   endif
        -:  332:#  endif
        -:  333:# endif
        -:  334:
        -:  335:# ifdef YYSTACK_ALLOC
        -:  336:   /* Pacify GCC's 'empty if-body' warning.  */
        -:  337:#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
        -:  338:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  339:    /* The OS might guarantee only one guard page at the bottom of the stack,
        -:  340:       and a page size can be as small as 4096 bytes.  So we cannot safely
        -:  341:       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
        -:  342:       to allow for a few compiler-allocated temporary stack slots.  */
        -:  343:#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
        -:  344:#  endif
        -:  345:# else
        -:  346:#  define YYSTACK_ALLOC YYMALLOC
        -:  347:#  define YYSTACK_FREE YYFREE
        -:  348:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  349:#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
        -:  350:#  endif
        -:  351:#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        -:  352:       && ! ((defined YYMALLOC || defined malloc) \
        -:  353:             && (defined YYFREE || defined free)))
        -:  354:#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  355:#   ifndef EXIT_SUCCESS
        -:  356:#    define EXIT_SUCCESS 0
        -:  357:#   endif
        -:  358:#  endif
        -:  359:#  ifndef YYMALLOC
        -:  360:#   define YYMALLOC malloc
        -:  361:#   if ! defined malloc && ! defined EXIT_SUCCESS
        -:  362:void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
        -:  363:#   endif
        -:  364:#  endif
        -:  365:#  ifndef YYFREE
        -:  366:#   define YYFREE free
        -:  367:#   if ! defined free && ! defined EXIT_SUCCESS
        -:  368:void free (void *); /* INFRINGES ON USER NAME SPACE */
        -:  369:#   endif
        -:  370:#  endif
        -:  371:# endif
        -:  372:#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
        -:  373:
        -:  374:
        -:  375:#if (! defined yyoverflow \
        -:  376:     && (! defined __cplusplus \
        -:  377:         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
        -:  378:
        -:  379:/* A type that is properly aligned for any stack member.  */
        -:  380:union yyalloc
        -:  381:{
        -:  382:  yytype_int16 yyss_alloc;
        -:  383:  YYSTYPE yyvs_alloc;
        -:  384:};
        -:  385:
        -:  386:/* The size of the maximum gap between one aligned stack and the next.  */
        -:  387:# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
        -:  388:
        -:  389:/* The size of an array large to enough to hold all stacks, each with
        -:  390:   N elements.  */
        -:  391:# define YYSTACK_BYTES(N) \
        -:  392:     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
        -:  393:      + YYSTACK_GAP_MAXIMUM)
        -:  394:
        -:  395:# define YYCOPY_NEEDED 1
        -:  396:
        -:  397:/* Relocate STACK from its old location to the new one.  The
        -:  398:   local variables YYSIZE and YYSTACKSIZE give the old and new number of
        -:  399:   elements in the stack, and YYPTR gives the new location of the
        -:  400:   stack.  Advance YYPTR to a properly aligned location for the next
        -:  401:   stack.  */
        -:  402:# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
        -:  403:    do                                                                  \
        -:  404:      {                                                                 \
        -:  405:        YYSIZE_T yynewbytes;                                            \
        -:  406:        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        -:  407:        Stack = &yyptr->Stack_alloc;                                    \
        -:  408:        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
        -:  409:        yyptr += yynewbytes / sizeof (*yyptr);                          \
        -:  410:      }                                                                 \
        -:  411:    while (0)
        -:  412:
        -:  413:#endif
        -:  414:
        -:  415:#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
        -:  416:/* Copy COUNT objects from SRC to DST.  The source and destination do
        -:  417:   not overlap.  */
        -:  418:# ifndef YYCOPY
        -:  419:#  if defined __GNUC__ && 1 < __GNUC__
        -:  420:#   define YYCOPY(Dst, Src, Count) \
        -:  421:      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
        -:  422:#  else
        -:  423:#   define YYCOPY(Dst, Src, Count)              \
        -:  424:      do                                        \
        -:  425:        {                                       \
        -:  426:          YYSIZE_T yyi;                         \
        -:  427:          for (yyi = 0; yyi < (Count); yyi++)   \
        -:  428:            (Dst)[yyi] = (Src)[yyi];            \
        -:  429:        }                                       \
        -:  430:      while (0)
        -:  431:#  endif
        -:  432:# endif
        -:  433:#endif /* !YYCOPY_NEEDED */
        -:  434:
        -:  435:/* YYFINAL -- State number of the termination state.  */
        -:  436:#define YYFINAL  22
        -:  437:/* YYLAST -- Last index in YYTABLE.  */
        -:  438:#define YYLAST   45
        -:  439:
        -:  440:/* YYNTOKENS -- Number of terminals.  */
        -:  441:#define YYNTOKENS  24
        -:  442:/* YYNNTS -- Number of nonterminals.  */
        -:  443:#define YYNNTS  6
        -:  444:/* YYNRULES -- Number of rules.  */
        -:  445:#define YYNRULES  31
        -:  446:/* YYNSTATES -- Number of states.  */
        -:  447:#define YYNSTATES  35
        -:  448:
        -:  449:/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
        -:  450:   by yylex, with out-of-bounds checking.  */
        -:  451:#define YYUNDEFTOK  2
        -:  452:#define YYMAXUTOK   269
        -:  453:
        -:  454:#define YYTRANSLATE(YYX)                                                \
        -:  455:  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
        -:  456:
        -:  457:/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
        -:  458:   as returned by yylex, without out-of-bounds checking.  */
        -:  459:static const yytype_uint8 yytranslate[] =
        -:  460:{
        -:  461:       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  462:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  463:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  464:       2,     2,     2,     2,     2,     2,    20,     2,     2,     2,
        -:  465:      21,    22,    16,    18,     2,     2,    23,     2,     2,     2,
        -:  466:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  467:       2,     2,     2,    17,     2,     2,     2,     2,     2,     2,
        -:  468:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  469:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  470:       2,     2,     2,     2,    19,     2,     2,     2,     2,     2,
        -:  471:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  472:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  473:       2,     2,     2,     2,    15,     2,     2,     2,     2,     2,
        -:  474:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  475:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  476:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  477:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  478:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  479:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  480:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  481:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  482:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  483:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  484:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  485:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  486:       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
        -:  487:       5,     6,     7,     8,     9,    10,    11,    12,    13,    14
        -:  488:};
        -:  489:
        -:  490:#if YYDEBUG
        -:  491:  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
        -:  492:static const yytype_uint16 yyrline[] =
        -:  493:{
        -:  494:       0,   104,   104,   109,   113,   117,   131,   152,   161,   169,
        -:  495:     185,   203,   219,   236,   259,   283,   306,   330,   334,   340,
        -:  496:     346,   352,   361,   365,   374,   383,   389,   395,   401,   407,
        -:  497:     413,   419
        -:  498:};
        -:  499:#endif
        -:  500:
        -:  501:#if YYDEBUG || YYERROR_VERBOSE || 0
        -:  502:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
        -:  503:   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
        -:  504:static const char *const yytname[] =
        -:  505:{
        -:  506:  "$end", "error", "$undefined", "_CHAR_", "_ANY_", "_RANGE_", "_CLASS_",
        -:  507:  "_WORD_CHAR_", "_NON_WORD_CHAR_", "_SPACE_", "_NON_SPACE_", "_DIGIT_",
        -:  508:  "_NON_DIGIT_", "_WORD_BOUNDARY_", "_NON_WORD_BOUNDARY_", "'|'", "'*'",
        -:  509:  "'?'", "'+'", "'^'", "'$'", "'('", "')'", "'.'", "$accept", "re",
        -:  510:  "alternative", "concatenation", "repeat", "single", YY_NULLPTR
        -:  511:};
        -:  512:#endif
        -:  513:
        -:  514:# ifdef YYPRINT
        -:  515:/* YYTOKNUM[NUM] -- (External) token number corresponding to the
        -:  516:   (internal) symbol number NUM (which must be that of a token).  */
        -:  517:static const yytype_uint16 yytoknum[] =
        -:  518:{
        -:  519:       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
        -:  520:     265,   266,   267,   268,   269,   124,    42,    63,    43,    94,
        -:  521:      36,    40,    41,    46
        -:  522:};
        -:  523:# endif
        -:  524:
        -:  525:#define YYPACT_NINF -12
        -:  526:
        -:  527:#define yypact_value_is_default(Yystate) \
        -:  528:  (!!((Yystate) == (-12)))
        -:  529:
        -:  530:#define YYTABLE_NINF -1
        -:  531:
        -:  532:#define yytable_value_is_error(Yytable_value) \
        -:  533:  0
        -:  534:
        -:  535:  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
        -:  536:     STATE-NUM.  */
        -:  537:static const yytype_int8 yypact[] =
        -:  538:{
        -:  539:      -1,   -12,   -12,   -12,   -12,   -12,   -12,   -12,   -12,   -12,
        -:  540:     -12,   -12,   -12,   -12,    18,   -12,     1,   -11,    18,   -12,
        -:  541:      -2,    21,   -12,    18,   -12,     0,    16,    17,    23,   -12,
        -:  542:      18,   -12,   -12,   -12,   -12
        -:  543:};
        -:  544:
        -:  545:  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
        -:  546:     Performed when YYTABLE does not specify something else to do.  Zero
        -:  547:     means the default is an error.  */
        -:  548:static const yytype_uint8 yydefact[] =
        -:  549:{
        -:  550:       0,     3,    24,    31,    25,    26,    27,    28,    29,    30,
        -:  551:      18,    19,    20,    21,     0,    23,     0,     2,     4,     7,
        -:  552:      17,     0,     1,     6,     8,    15,     9,    13,    11,    22,
        -:  553:       5,    16,    10,    14,    12
        -:  554:};
        -:  555:
        -:  556:  /* YYPGOTO[NTERM-NUM].  */
        -:  557:static const yytype_int8 yypgoto[] =
        -:  558:{
        -:  559:     -12,   -12,    28,    22,     5,   -12
        -:  560:};
        -:  561:
        -:  562:  /* YYDEFGOTO[NTERM-NUM].  */
        -:  563:static const yytype_int8 yydefgoto[] =
        -:  564:{
        -:  565:      -1,    16,    17,    18,    19,    20
        -:  566:};
        -:  567:
        -:  568:  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
        -:  569:     positive, shift that token.  If negative, reduce the rule whose
        -:  570:     number is the opposite.  If YYTABLE_NINF, syntax error.  */
        -:  571:static const yytype_uint8 yytable[] =
        -:  572:{
        -:  573:       1,    22,     2,    25,    23,     3,     4,     5,     6,     7,
        -:  574:       8,     9,    10,    11,    26,    27,    28,    31,    12,    13,
        -:  575:      14,     2,    15,    24,     3,     4,     5,     6,     7,     8,
        -:  576:       9,    10,    11,    32,    33,    24,    23,    12,    13,    14,
        -:  577:      34,    15,    21,    29,     0,    30
        -:  578:};
        -:  579:
        -:  580:static const yytype_int8 yycheck[] =
        -:  581:{
        -:  582:       1,     0,     3,     5,    15,     6,     7,     8,     9,    10,
        -:  583:      11,    12,    13,    14,    16,    17,    18,    17,    19,    20,
        -:  584:      21,     3,    23,    18,     6,     7,     8,     9,    10,    11,
        -:  585:      12,    13,    14,    17,    17,    30,    15,    19,    20,    21,
        -:  586:      17,    23,    14,    22,    -1,    23
        -:  587:};
        -:  588:
        -:  589:  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
        -:  590:     symbol of state STATE-NUM.  */
        -:  591:static const yytype_uint8 yystos[] =
        -:  592:{
        -:  593:       0,     1,     3,     6,     7,     8,     9,    10,    11,    12,
        -:  594:      13,    14,    19,    20,    21,    23,    25,    26,    27,    28,
        -:  595:      29,    26,     0,    15,    28,     5,    16,    17,    18,    22,
        -:  596:      27,    17,    17,    17,    17
        -:  597:};
        -:  598:
        -:  599:  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
        -:  600:static const yytype_uint8 yyr1[] =
        -:  601:{
        -:  602:       0,    24,    25,    25,    26,    26,    26,    27,    27,    28,
        -:  603:      28,    28,    28,    28,    28,    28,    28,    28,    28,    28,
        -:  604:      28,    28,    29,    29,    29,    29,    29,    29,    29,    29,
        -:  605:      29,    29
        -:  606:};
        -:  607:
        -:  608:  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
        -:  609:static const yytype_uint8 yyr2[] =
        -:  610:{
        -:  611:       0,     2,     1,     1,     1,     3,     2,     1,     2,     2,
        -:  612:       3,     2,     3,     2,     3,     2,     3,     1,     1,     1,
        -:  613:       1,     1,     3,     1,     1,     1,     1,     1,     1,     1,
        -:  614:       1,     1
        -:  615:};
        -:  616:
        -:  617:
        -:  618:#define yyerrok         (yyerrstatus = 0)
        -:  619:#define yyclearin       (yychar = YYEMPTY)
        -:  620:#define YYEMPTY         (-2)
        -:  621:#define YYEOF           0
        -:  622:
        -:  623:#define YYACCEPT        goto yyacceptlab
        -:  624:#define YYABORT         goto yyabortlab
        -:  625:#define YYERROR         goto yyerrorlab
        -:  626:
        -:  627:
        -:  628:#define YYRECOVERING()  (!!yyerrstatus)
        -:  629:
        -:  630:#define YYBACKUP(Token, Value)                                  \
        -:  631:do                                                              \
        -:  632:  if (yychar == YYEMPTY)                                        \
        -:  633:    {                                                           \
        -:  634:      yychar = (Token);                                         \
        -:  635:      yylval = (Value);                                         \
        -:  636:      YYPOPSTACK (yylen);                                       \
        -:  637:      yystate = *yyssp;                                         \
        -:  638:      goto yybackup;                                            \
        -:  639:    }                                                           \
        -:  640:  else                                                          \
        -:  641:    {                                                           \
        -:  642:      yyerror (yyscanner, lex_env, YY_("syntax error: cannot back up")); \
        -:  643:      YYERROR;                                                  \
        -:  644:    }                                                           \
        -:  645:while (0)
        -:  646:
        -:  647:/* Error token number */
        -:  648:#define YYTERROR        1
        -:  649:#define YYERRCODE       256
        -:  650:
        -:  651:
        -:  652:
        -:  653:/* Enable debugging if requested.  */
        -:  654:#if YYDEBUG
        -:  655:
        -:  656:# ifndef YYFPRINTF
        -:  657:#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
        -:  658:#  define YYFPRINTF fprintf
        -:  659:# endif
        -:  660:
        -:  661:# define YYDPRINTF(Args)                        \
        -:  662:do {                                            \
        -:  663:  if (yydebug)                                  \
        -:  664:    YYFPRINTF Args;                             \
        -:  665:} while (0)
        -:  666:
        -:  667:/* This macro is provided for backward compatibility. */
        -:  668:#ifndef YY_LOCATION_PRINT
        -:  669:# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
        -:  670:#endif
        -:  671:
        -:  672:
        -:  673:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
        -:  674:do {                                                                      \
        -:  675:  if (yydebug)                                                            \
        -:  676:    {                                                                     \
        -:  677:      YYFPRINTF (stderr, "%s ", Title);                                   \
        -:  678:      yy_symbol_print (stderr,                                            \
        -:  679:                  Type, Value, yyscanner, lex_env); \
        -:  680:      YYFPRINTF (stderr, "\n");                                           \
        -:  681:    }                                                                     \
        -:  682:} while (0)
        -:  683:
        -:  684:
        -:  685:/*----------------------------------------.
        -:  686:| Print this symbol's value on YYOUTPUT.  |
        -:  687:`----------------------------------------*/
        -:  688:
        -:  689:static void
        -:  690:yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)
        -:  691:{
        -:  692:  FILE *yyo = yyoutput;
        -:  693:  YYUSE (yyo);
        -:  694:  YYUSE (yyscanner);
        -:  695:  YYUSE (lex_env);
        -:  696:  if (!yyvaluep)
        -:  697:    return;
        -:  698:# ifdef YYPRINT
        -:  699:  if (yytype < YYNTOKENS)
        -:  700:    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
        -:  701:# endif
        -:  702:  YYUSE (yytype);
        -:  703:}
        -:  704:
        -:  705:
        -:  706:/*--------------------------------.
        -:  707:| Print this symbol on YYOUTPUT.  |
        -:  708:`--------------------------------*/
        -:  709:
        -:  710:static void
        -:  711:yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)
        -:  712:{
        -:  713:  YYFPRINTF (yyoutput, "%s %s (",
        -:  714:             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
        -:  715:
        -:  716:  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yyscanner, lex_env);
        -:  717:  YYFPRINTF (yyoutput, ")");
        -:  718:}
        -:  719:
        -:  720:/*------------------------------------------------------------------.
        -:  721:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
        -:  722:| TOP (included).                                                   |
        -:  723:`------------------------------------------------------------------*/
        -:  724:
        -:  725:static void
        -:  726:yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
        -:  727:{
        -:  728:  YYFPRINTF (stderr, "Stack now");
        -:  729:  for (; yybottom <= yytop; yybottom++)
        -:  730:    {
        -:  731:      int yybot = *yybottom;
        -:  732:      YYFPRINTF (stderr, " %d", yybot);
        -:  733:    }
        -:  734:  YYFPRINTF (stderr, "\n");
        -:  735:}
        -:  736:
        -:  737:# define YY_STACK_PRINT(Bottom, Top)                            \
        -:  738:do {                                                            \
        -:  739:  if (yydebug)                                                  \
        -:  740:    yy_stack_print ((Bottom), (Top));                           \
        -:  741:} while (0)
        -:  742:
        -:  743:
        -:  744:/*------------------------------------------------.
        -:  745:| Report that the YYRULE is going to be reduced.  |
        -:  746:`------------------------------------------------*/
        -:  747:
        -:  748:static void
        -:  749:yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)
        -:  750:{
        -:  751:  unsigned long int yylno = yyrline[yyrule];
        -:  752:  int yynrhs = yyr2[yyrule];
        -:  753:  int yyi;
        -:  754:  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
        -:  755:             yyrule - 1, yylno);
        -:  756:  /* The symbols being reduced.  */
        -:  757:  for (yyi = 0; yyi < yynrhs; yyi++)
        -:  758:    {
        -:  759:      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
        -:  760:      yy_symbol_print (stderr,
        -:  761:                       yystos[yyssp[yyi + 1 - yynrhs]],
        -:  762:                       &(yyvsp[(yyi + 1) - (yynrhs)])
        -:  763:                                              , yyscanner, lex_env);
        -:  764:      YYFPRINTF (stderr, "\n");
        -:  765:    }
        -:  766:}
        -:  767:
        -:  768:# define YY_REDUCE_PRINT(Rule)          \
        -:  769:do {                                    \
        -:  770:  if (yydebug)                          \
        -:  771:    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner, lex_env); \
        -:  772:} while (0)
        -:  773:
        -:  774:/* Nonzero means print parse trace.  It is left uninitialized so that
        -:  775:   multiple parsers can coexist.  */
        -:  776:int yydebug;
        -:  777:#else /* !YYDEBUG */
        -:  778:# define YYDPRINTF(Args)
        -:  779:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
        -:  780:# define YY_STACK_PRINT(Bottom, Top)
        -:  781:# define YY_REDUCE_PRINT(Rule)
        -:  782:#endif /* !YYDEBUG */
        -:  783:
        -:  784:
        -:  785:/* YYINITDEPTH -- initial size of the parser's stacks.  */
        -:  786:#ifndef YYINITDEPTH
        -:  787:# define YYINITDEPTH 200
        -:  788:#endif
        -:  789:
        -:  790:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
        -:  791:   if the built-in stack extension method is used).
        -:  792:
        -:  793:   Do not make this value too large; the results are undefined if
        -:  794:   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
        -:  795:   evaluated with infinite-precision integer arithmetic.  */
        -:  796:
        -:  797:#ifndef YYMAXDEPTH
        -:  798:# define YYMAXDEPTH 10000
        -:  799:#endif
        -:  800:
        -:  801:
        -:  802:#if YYERROR_VERBOSE
        -:  803:
        -:  804:# ifndef yystrlen
        -:  805:#  if defined __GLIBC__ && defined _STRING_H
        -:  806:#   define yystrlen strlen
        -:  807:#  else
        -:  808:/* Return the length of YYSTR.  */
        -:  809:static YYSIZE_T
        -:  810:yystrlen (const char *yystr)
        -:  811:{
        -:  812:  YYSIZE_T yylen;
        -:  813:  for (yylen = 0; yystr[yylen]; yylen++)
        -:  814:    continue;
        -:  815:  return yylen;
        -:  816:}
        -:  817:#  endif
        -:  818:# endif
        -:  819:
        -:  820:# ifndef yystpcpy
        -:  821:#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
        -:  822:#   define yystpcpy stpcpy
        -:  823:#  else
        -:  824:/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
        -:  825:   YYDEST.  */
        -:  826:static char *
    #####:  827:yystpcpy (char *yydest, const char *yysrc)
        -:  828:{
    #####:  829:  char *yyd = yydest;
    #####:  830:  const char *yys = yysrc;
        -:  831:
    #####:  832:  while ((*yyd++ = *yys++) != '\0')
    #####:  833:    continue;
        -:  834:
    #####:  835:  return yyd - 1;
        -:  836:}
        -:  837:#  endif
        -:  838:# endif
        -:  839:
        -:  840:# ifndef yytnamerr
        -:  841:/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
        -:  842:   quotes and backslashes, so that it's suitable for yyerror.  The
        -:  843:   heuristic is that double-quoting is unnecessary unless the string
        -:  844:   contains an apostrophe, a comma, or backslash (other than
        -:  845:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
        -:  846:   null, do not copy; instead, return the length of what the result
        -:  847:   would have been.  */
        -:  848:static YYSIZE_T
    #####:  849:yytnamerr (char *yyres, const char *yystr)
        -:  850:{
    #####:  851:  if (*yystr == '"')
        -:  852:    {
    #####:  853:      YYSIZE_T yyn = 0;
    #####:  854:      char const *yyp = yystr;
        -:  855:
        -:  856:      for (;;)
    #####:  857:        switch (*++yyp)
        -:  858:          {
    #####:  859:          case '\'':
        -:  860:          case ',':
    #####:  861:            goto do_not_strip_quotes;
        -:  862:
    #####:  863:          case '\\':
    #####:  864:            if (*++yyp != '\\')
    #####:  865:              goto do_not_strip_quotes;
        -:  866:            /* Fall through.  */
        -:  867:          default:
    #####:  868:            if (yyres)
    #####:  869:              yyres[yyn] = *yyp;
    #####:  870:            yyn++;
    #####:  871:            break;
        -:  872:
    #####:  873:          case '"':
    #####:  874:            if (yyres)
    #####:  875:              yyres[yyn] = '\0';
    #####:  876:            return yyn;
        -:  877:          }
    #####:  878:    do_not_strip_quotes: ;
        -:  879:    }
        -:  880:
    #####:  881:  if (! yyres)
    #####:  882:    return yystrlen (yystr);
        -:  883:
    #####:  884:  return yystpcpy (yyres, yystr) - yyres;
        -:  885:}
        -:  886:# endif
        -:  887:
        -:  888:/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
        -:  889:   about the unexpected token YYTOKEN for the state stack whose top is
        -:  890:   YYSSP.
        -:  891:
        -:  892:   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
        -:  893:   not large enough to hold the message.  In that case, also set
        -:  894:   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
        -:  895:   required number of bytes is too large to store.  */
        -:  896:static int
    #####:  897:yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
        -:  898:                yytype_int16 *yyssp, int yytoken)
        -:  899:{
    #####:  900:  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
    #####:  901:  YYSIZE_T yysize = yysize0;
        -:  902:  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
        -:  903:  /* Internationalized format string. */
    #####:  904:  const char *yyformat = YY_NULLPTR;
        -:  905:  /* Arguments of yyformat. */
        -:  906:  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
        -:  907:  /* Number of reported tokens (one for the "unexpected", one per
        -:  908:     "expected"). */
    #####:  909:  int yycount = 0;
        -:  910:
        -:  911:  /* There are many possibilities here to consider:
        -:  912:     - If this state is a consistent state with a default action, then
        -:  913:       the only way this function was invoked is if the default action
        -:  914:       is an error action.  In that case, don't check for expected
        -:  915:       tokens because there are none.
        -:  916:     - The only way there can be no lookahead present (in yychar) is if
        -:  917:       this state is a consistent state with a default action.  Thus,
        -:  918:       detecting the absence of a lookahead is sufficient to determine
        -:  919:       that there is no unexpected or expected token to report.  In that
        -:  920:       case, just report a simple "syntax error".
        -:  921:     - Don't assume there isn't a lookahead just because this state is a
        -:  922:       consistent state with a default action.  There might have been a
        -:  923:       previous inconsistent state, consistent state with a non-default
        -:  924:       action, or user semantic action that manipulated yychar.
        -:  925:     - Of course, the expected token list depends on states to have
        -:  926:       correct lookahead information, and it depends on the parser not
        -:  927:       to perform extra reductions after fetching a lookahead from the
        -:  928:       scanner and before detecting a syntax error.  Thus, state merging
        -:  929:       (from LALR or IELR) and default reductions corrupt the expected
        -:  930:       token list.  However, the list is correct for canonical LR with
        -:  931:       one exception: it will still contain any token that will not be
        -:  932:       accepted due to an error action in a later state.
        -:  933:  */
    #####:  934:  if (yytoken != YYEMPTY)
        -:  935:    {
    #####:  936:      int yyn = yypact[*yyssp];
    #####:  937:      yyarg[yycount++] = yytname[yytoken];
    #####:  938:      if (!yypact_value_is_default (yyn))
        -:  939:        {
        -:  940:          /* Start YYX at -YYN if negative to avoid negative indexes in
        -:  941:             YYCHECK.  In other words, skip the first -YYN actions for
        -:  942:             this state because they are default actions.  */
    #####:  943:          int yyxbegin = yyn < 0 ? -yyn : 0;
        -:  944:          /* Stay within bounds of both yycheck and yytname.  */
    #####:  945:          int yychecklim = YYLAST - yyn + 1;
    #####:  946:          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
        -:  947:          int yyx;
        -:  948:
    #####:  949:          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
    #####:  950:            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
    #####:  951:                && !yytable_value_is_error (yytable[yyx + yyn]))
        -:  952:              {
    #####:  953:                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
        -:  954:                  {
    #####:  955:                    yycount = 1;
    #####:  956:                    yysize = yysize0;
    #####:  957:                    break;
        -:  958:                  }
    #####:  959:                yyarg[yycount++] = yytname[yyx];
        -:  960:                {
    #####:  961:                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
    #####:  962:                  if (! (yysize <= yysize1
        -:  963:                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
    #####:  964:                    return 2;
    #####:  965:                  yysize = yysize1;
        -:  966:                }
        -:  967:              }
        -:  968:        }
        -:  969:    }
        -:  970:
    #####:  971:  switch (yycount)
        -:  972:    {
        -:  973:# define YYCASE_(N, S)                      \
        -:  974:      case N:                               \
        -:  975:        yyformat = S;                       \
        -:  976:      break
    #####:  977:      YYCASE_(0, YY_("syntax error"));
    #####:  978:      YYCASE_(1, YY_("syntax error, unexpected %s"));
    #####:  979:      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
    #####:  980:      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
    #####:  981:      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
    #####:  982:      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
        -:  983:# undef YYCASE_
        -:  984:    }
        -:  985:
        -:  986:  {
    #####:  987:    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
    #####:  988:    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
    #####:  989:      return 2;
    #####:  990:    yysize = yysize1;
        -:  991:  }
        -:  992:
    #####:  993:  if (*yymsg_alloc < yysize)
        -:  994:    {
    #####:  995:      *yymsg_alloc = 2 * yysize;
    #####:  996:      if (! (yysize <= *yymsg_alloc
        -:  997:             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
    #####:  998:        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
    #####:  999:      return 1;
        -: 1000:    }
        -: 1001:
        -: 1002:  /* Avoid sprintf, as that infringes on the user's name space.
        -: 1003:     Don't have undefined behavior even if the translation
        -: 1004:     produced a string with the wrong number of "%s"s.  */
        -: 1005:  {
    #####: 1006:    char *yyp = *yymsg;
    #####: 1007:    int yyi = 0;
    #####: 1008:    while ((*yyp = *yyformat) != '\0')
    #####: 1009:      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        -: 1010:        {
    #####: 1011:          yyp += yytnamerr (yyp, yyarg[yyi++]);
    #####: 1012:          yyformat += 2;
        -: 1013:        }
        -: 1014:      else
        -: 1015:        {
    #####: 1016:          yyp++;
    #####: 1017:          yyformat++;
        -: 1018:        }
        -: 1019:  }
    #####: 1020:  return 0;
        -: 1021:}
        -: 1022:#endif /* YYERROR_VERBOSE */
        -: 1023:
        -: 1024:/*-----------------------------------------------.
        -: 1025:| Release the memory associated to this symbol.  |
        -: 1026:`-----------------------------------------------*/
        -: 1027:
        -: 1028:static void
    #####: 1029:yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)
        -: 1030:{
        -: 1031:  YYUSE (yyvaluep);
        -: 1032:  YYUSE (yyscanner);
        -: 1033:  YYUSE (lex_env);
    #####: 1034:  if (!yymsg)
    #####: 1035:    yymsg = "Deleting";
        -: 1036:  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
        -: 1037:
        -: 1038:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 1039:  switch (yytype)
        -: 1040:    {
    #####: 1041:          case 6: /* _CLASS_  */
        -: 1042:#line 96 "re_grammar.y" /* yacc.c:1257  */
        -: 1043:      { yr_free(((*yyvaluep).re_class)); ((*yyvaluep).re_class) = NULL; }
        -: 1044:#line 1045 "re_grammar.c" /* yacc.c:1257  */
    #####: 1045:        break;
        -: 1046:
    #####: 1047:    case 26: /* alternative  */
        -: 1048:#line 97 "re_grammar.y" /* yacc.c:1257  */
        -: 1049:      { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1050:#line 1051 "re_grammar.c" /* yacc.c:1257  */
    #####: 1051:        break;
        -: 1052:
    #####: 1053:    case 27: /* concatenation  */
        -: 1054:#line 98 "re_grammar.y" /* yacc.c:1257  */
        -: 1055:      { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1056:#line 1057 "re_grammar.c" /* yacc.c:1257  */
    #####: 1057:        break;
        -: 1058:
    #####: 1059:    case 28: /* repeat  */
        -: 1060:#line 99 "re_grammar.y" /* yacc.c:1257  */
        -: 1061:      { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1062:#line 1063 "re_grammar.c" /* yacc.c:1257  */
    #####: 1063:        break;
        -: 1064:
    #####: 1065:    case 29: /* single  */
        -: 1066:#line 100 "re_grammar.y" /* yacc.c:1257  */
        -: 1067:      { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1068:#line 1069 "re_grammar.c" /* yacc.c:1257  */
    #####: 1069:        break;
        -: 1070:
        -: 1071:
    #####: 1072:      default:
    #####: 1073:        break;
        -: 1074:    }
        -: 1075:  YY_IGNORE_MAYBE_UNINITIALIZED_END
    #####: 1076:}
        -: 1077:
        -: 1078:
        -: 1079:
        -: 1080:
        -: 1081:/*----------.
        -: 1082:| yyparse.  |
        -: 1083:`----------*/
        -: 1084:
        -: 1085:int
    #####: 1086:yyparse (void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)
        -: 1087:{
        -: 1088:/* The lookahead symbol.  */
        -: 1089:int yychar;
        -: 1090:
        -: 1091:
        -: 1092:/* The semantic value of the lookahead symbol.  */
        -: 1093:/* Default value used for initialization, for pacifying older GCCs
        -: 1094:   or non-GCC compilers.  */
        -: 1095:YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
        -: 1096:YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
        -: 1097:
        -: 1098:    /* Number of syntax errors so far.  */
        -: 1099:    int yynerrs;
        -: 1100:
        -: 1101:    int yystate;
        -: 1102:    /* Number of tokens to shift before error messages enabled.  */
        -: 1103:    int yyerrstatus;
        -: 1104:
        -: 1105:    /* The stacks and their tools:
        -: 1106:       'yyss': related to states.
        -: 1107:       'yyvs': related to semantic values.
        -: 1108:
        -: 1109:       Refer to the stacks through separate pointers, to allow yyoverflow
        -: 1110:       to reallocate them elsewhere.  */
        -: 1111:
        -: 1112:    /* The state stack.  */
        -: 1113:    yytype_int16 yyssa[YYINITDEPTH];
        -: 1114:    yytype_int16 *yyss;
        -: 1115:    yytype_int16 *yyssp;
        -: 1116:
        -: 1117:    /* The semantic value stack.  */
        -: 1118:    YYSTYPE yyvsa[YYINITDEPTH];
        -: 1119:    YYSTYPE *yyvs;
        -: 1120:    YYSTYPE *yyvsp;
        -: 1121:
        -: 1122:    YYSIZE_T yystacksize;
        -: 1123:
        -: 1124:  int yyn;
        -: 1125:  int yyresult;
        -: 1126:  /* Lookahead token as an internal (translated) token number.  */
    #####: 1127:  int yytoken = 0;
        -: 1128:  /* The variables used to return semantic value and location from the
        -: 1129:     action routines.  */
        -: 1130:  YYSTYPE yyval;
        -: 1131:
        -: 1132:#if YYERROR_VERBOSE
        -: 1133:  /* Buffer for error messages, and its allocated size.  */
        -: 1134:  char yymsgbuf[128];
    #####: 1135:  char *yymsg = yymsgbuf;
    #####: 1136:  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
        -: 1137:#endif
        -: 1138:
        -: 1139:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
        -: 1140:
        -: 1141:  /* The number of symbols on the RHS of the reduced rule.
        -: 1142:     Keep to zero when no symbol should be popped.  */
    #####: 1143:  int yylen = 0;
        -: 1144:
    #####: 1145:  yyssp = yyss = yyssa;
    #####: 1146:  yyvsp = yyvs = yyvsa;
    #####: 1147:  yystacksize = YYINITDEPTH;
        -: 1148:
        -: 1149:  YYDPRINTF ((stderr, "Starting parse\n"));
        -: 1150:
    #####: 1151:  yystate = 0;
    #####: 1152:  yyerrstatus = 0;
    #####: 1153:  yynerrs = 0;
    #####: 1154:  yychar = YYEMPTY; /* Cause a token to be read.  */
    #####: 1155:  goto yysetstate;
        -: 1156:
        -: 1157:/*------------------------------------------------------------.
        -: 1158:| yynewstate -- Push a new state, which is found in yystate.  |
        -: 1159:`------------------------------------------------------------*/
    #####: 1160: yynewstate:
        -: 1161:  /* In all cases, when you get here, the value and location stacks
        -: 1162:     have just been pushed.  So pushing a state here evens the stacks.  */
    #####: 1163:  yyssp++;
        -: 1164:
    #####: 1165: yysetstate:
    #####: 1166:  *yyssp = yystate;
        -: 1167:
    #####: 1168:  if (yyss + yystacksize - 1 <= yyssp)
        -: 1169:    {
        -: 1170:      /* Get the current used size of the three stacks, in elements.  */
    #####: 1171:      YYSIZE_T yysize = yyssp - yyss + 1;
        -: 1172:
        -: 1173:#ifdef yyoverflow
        -: 1174:      {
        -: 1175:        /* Give user a chance to reallocate the stack.  Use copies of
        -: 1176:           these so that the &'s don't force the real ones into
        -: 1177:           memory.  */
        -: 1178:        YYSTYPE *yyvs1 = yyvs;
        -: 1179:        yytype_int16 *yyss1 = yyss;
        -: 1180:
        -: 1181:        /* Each stack pointer address is followed by the size of the
        -: 1182:           data in use in that stack, in bytes.  This used to be a
        -: 1183:           conditional around just the two extra args, but that might
        -: 1184:           be undefined if yyoverflow is a macro.  */
        -: 1185:        yyoverflow (YY_("memory exhausted"),
        -: 1186:                    &yyss1, yysize * sizeof (*yyssp),
        -: 1187:                    &yyvs1, yysize * sizeof (*yyvsp),
        -: 1188:                    &yystacksize);
        -: 1189:
        -: 1190:        yyss = yyss1;
        -: 1191:        yyvs = yyvs1;
        -: 1192:      }
        -: 1193:#else /* no yyoverflow */
        -: 1194:# ifndef YYSTACK_RELOCATE
        -: 1195:      goto yyexhaustedlab;
        -: 1196:# else
        -: 1197:      /* Extend the stack our own way.  */
    #####: 1198:      if (YYMAXDEPTH <= yystacksize)
    #####: 1199:        goto yyexhaustedlab;
    #####: 1200:      yystacksize *= 2;
    #####: 1201:      if (YYMAXDEPTH < yystacksize)
    #####: 1202:        yystacksize = YYMAXDEPTH;
        -: 1203:
        -: 1204:      {
    #####: 1205:        yytype_int16 *yyss1 = yyss;
    #####: 1206:        union yyalloc *yyptr =
    #####: 1207:          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
    #####: 1208:        if (! yyptr)
    #####: 1209:          goto yyexhaustedlab;
    #####: 1210:        YYSTACK_RELOCATE (yyss_alloc, yyss);
    #####: 1211:        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        -: 1212:#  undef YYSTACK_RELOCATE
    #####: 1213:        if (yyss1 != yyssa)
    #####: 1214:          YYSTACK_FREE (yyss1);
        -: 1215:      }
        -: 1216:# endif
        -: 1217:#endif /* no yyoverflow */
        -: 1218:
    #####: 1219:      yyssp = yyss + yysize - 1;
    #####: 1220:      yyvsp = yyvs + yysize - 1;
        -: 1221:
        -: 1222:      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
        -: 1223:                  (unsigned long int) yystacksize));
        -: 1224:
    #####: 1225:      if (yyss + yystacksize - 1 <= yyssp)
    #####: 1226:        YYABORT;
        -: 1227:    }
        -: 1228:
        -: 1229:  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
        -: 1230:
    #####: 1231:  if (yystate == YYFINAL)
    #####: 1232:    YYACCEPT;
        -: 1233:
    #####: 1234:  goto yybackup;
        -: 1235:
        -: 1236:/*-----------.
        -: 1237:| yybackup.  |
        -: 1238:`-----------*/
    #####: 1239:yybackup:
        -: 1240:
        -: 1241:  /* Do appropriate processing given the current state.  Read a
        -: 1242:     lookahead token if we need one and don't already have one.  */
        -: 1243:
        -: 1244:  /* First try to decide what to do without reference to lookahead token.  */
    #####: 1245:  yyn = yypact[yystate];
    #####: 1246:  if (yypact_value_is_default (yyn))
    #####: 1247:    goto yydefault;
        -: 1248:
        -: 1249:  /* Not known => get a lookahead token if don't already have one.  */
        -: 1250:
        -: 1251:  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
    #####: 1252:  if (yychar == YYEMPTY)
        -: 1253:    {
        -: 1254:      YYDPRINTF ((stderr, "Reading a token: "));
    #####: 1255:      yychar = yylex (&yylval, yyscanner, lex_env);
        -: 1256:    }
        -: 1257:
    #####: 1258:  if (yychar <= YYEOF)
        -: 1259:    {
    #####: 1260:      yychar = yytoken = YYEOF;
        -: 1261:      YYDPRINTF ((stderr, "Now at end of input.\n"));
        -: 1262:    }
        -: 1263:  else
        -: 1264:    {
    #####: 1265:      yytoken = YYTRANSLATE (yychar);
        -: 1266:      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
        -: 1267:    }
        -: 1268:
        -: 1269:  /* If the proper action on seeing token YYTOKEN is to reduce or to
        -: 1270:     detect an error, take that action.  */
    #####: 1271:  yyn += yytoken;
    #####: 1272:  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
        -: 1273:    goto yydefault;
    #####: 1274:  yyn = yytable[yyn];
    #####: 1275:  if (yyn <= 0)
        -: 1276:    {
        -: 1277:      if (yytable_value_is_error (yyn))
        -: 1278:        goto yyerrlab;
    #####: 1279:      yyn = -yyn;
    #####: 1280:      goto yyreduce;
        -: 1281:    }
        -: 1282:
        -: 1283:  /* Count tokens shifted since error; after three, turn off error
        -: 1284:     status.  */
    #####: 1285:  if (yyerrstatus)
    #####: 1286:    yyerrstatus--;
        -: 1287:
        -: 1288:  /* Shift the lookahead token.  */
        -: 1289:  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
        -: 1290:
        -: 1291:  /* Discard the shifted token.  */
    #####: 1292:  yychar = YYEMPTY;
        -: 1293:
    #####: 1294:  yystate = yyn;
        -: 1295:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 1296:  *++yyvsp = yylval;
        -: 1297:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1298:
    #####: 1299:  goto yynewstate;
        -: 1300:
        -: 1301:
        -: 1302:/*-----------------------------------------------------------.
        -: 1303:| yydefault -- do the default action for the current state.  |
        -: 1304:`-----------------------------------------------------------*/
    #####: 1305:yydefault:
    #####: 1306:  yyn = yydefact[yystate];
    #####: 1307:  if (yyn == 0)
    #####: 1308:    goto yyerrlab;
    #####: 1309:  goto yyreduce;
        -: 1310:
        -: 1311:
        -: 1312:/*-----------------------------.
        -: 1313:| yyreduce -- Do a reduction.  |
        -: 1314:`-----------------------------*/
    #####: 1315:yyreduce:
        -: 1316:  /* yyn is the number of a rule to reduce with.  */
    #####: 1317:  yylen = yyr2[yyn];
        -: 1318:
        -: 1319:  /* If YYLEN is nonzero, implement the default value of the action:
        -: 1320:     '$$ = $1'.
        -: 1321:
        -: 1322:     Otherwise, the following line sets YYVAL to garbage.
        -: 1323:     This behavior is undocumented and Bison
        -: 1324:     users should not rely upon it.  Assigning to YYVAL
        -: 1325:     unconditionally makes the parser a bit smaller, and it avoids a
        -: 1326:     GCC warning that YYVAL may be used uninitialized.  */
    #####: 1327:  yyval = yyvsp[1-yylen];
        -: 1328:
        -: 1329:
        -: 1330:  YY_REDUCE_PRINT (yyn);
    #####: 1331:  switch (yyn)
        -: 1332:    {
    #####: 1333:        case 2:
        -: 1334:#line 105 "re_grammar.y" /* yacc.c:1646  */
        -: 1335:    {
        -: 1336:        RE_AST* re_ast = yyget_extra(yyscanner);
        -: 1337:        re_ast->root_node = (yyvsp[0].re_node);
        -: 1338:      }
        -: 1339:#line 1340 "re_grammar.c" /* yacc.c:1646  */
    #####: 1340:    break;
        -: 1341:
    #####: 1342:  case 4:
        -: 1343:#line 114 "re_grammar.y" /* yacc.c:1646  */
        -: 1344:    {
        -: 1345:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1346:      }
        -: 1347:#line 1348 "re_grammar.c" /* yacc.c:1646  */
    #####: 1348:    break;
        -: 1349:
    #####: 1350:  case 5:
        -: 1351:#line 118 "re_grammar.y" /* yacc.c:1646  */
        -: 1352:    {
        -: 1353:        mark_as_not_fast_regexp();
        -: 1354:
        -: 1355:        (yyval.re_node) = yr_re_node_create(RE_NODE_ALT);
        -: 1356:
        -: 1357:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));
        -: 1358:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));
        -: 1359:
        -: 1360:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1361:
        -: 1362:        yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));
        -: 1363:        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));
        -: 1364:      }
        -: 1365:#line 1366 "re_grammar.c" /* yacc.c:1646  */
    #####: 1366:    break;
        -: 1367:
    #####: 1368:  case 6:
        -: 1369:#line 132 "re_grammar.y" /* yacc.c:1646  */
        -: 1370:    {
        -: 1371:        RE_NODE* node;
        -: 1372:
        -: 1373:        mark_as_not_fast_regexp();
        -: 1374:
        -: 1375:        node = yr_re_node_create(RE_NODE_EMPTY);
        -: 1376:
        -: 1377:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1378:        fail_if(node == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1379:
        -: 1380:        (yyval.re_node) = yr_re_node_create(RE_NODE_ALT);
        -: 1381:
        -: 1382:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1383:
        -: 1384:        yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));
        -: 1385:        yr_re_node_append_child((yyval.re_node), node);
        -: 1386:      }
        -: 1387:#line 1388 "re_grammar.c" /* yacc.c:1646  */
    #####: 1388:    break;
        -: 1389:
    #####: 1390:  case 7:
        -: 1391:#line 153 "re_grammar.y" /* yacc.c:1646  */
        -: 1392:    {
        -: 1393:        (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT);
        -: 1394:
        -: 1395:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));
        -: 1396:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1397:
        -: 1398:        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));
        -: 1399:      }
        -: 1400:#line 1401 "re_grammar.c" /* yacc.c:1646  */
    #####: 1401:    break;
        -: 1402:
    #####: 1403:  case 8:
        -: 1404:#line 162 "re_grammar.y" /* yacc.c:1646  */
        -: 1405:    {
        -: 1406:        yr_re_node_append_child((yyvsp[-1].re_node), (yyvsp[0].re_node));
        -: 1407:        (yyval.re_node) = (yyvsp[-1].re_node);
        -: 1408:      }
        -: 1409:#line 1410 "re_grammar.c" /* yacc.c:1646  */
    #####: 1410:    break;
        -: 1411:
    #####: 1412:  case 9:
        -: 1413:#line 170 "re_grammar.y" /* yacc.c:1646  */
        -: 1414:    {
        -: 1415:        RE_AST* re_ast;
        -: 1416:
        -: 1417:        mark_as_not_fast_regexp();
        -: 1418:
        -: 1419:        re_ast = yyget_extra(yyscanner);
        -: 1420:        re_ast->flags |= RE_FLAGS_GREEDY;
        -: 1421:
        -: 1422:        (yyval.re_node) = yr_re_node_create(RE_NODE_STAR);
        -: 1423:
        -: 1424:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1425:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1426:
        -: 1427:        yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));
        -: 1428:      }
        -: 1429:#line 1430 "re_grammar.c" /* yacc.c:1646  */
    #####: 1430:    break;
        -: 1431:
    #####: 1432:  case 10:
        -: 1433:#line 186 "re_grammar.y" /* yacc.c:1646  */
        -: 1434:    {
        -: 1435:        RE_AST* re_ast;
        -: 1436:
        -: 1437:        mark_as_not_fast_regexp();
        -: 1438:
        -: 1439:        re_ast = yyget_extra(yyscanner);
        -: 1440:        re_ast->flags |= RE_FLAGS_UNGREEDY;
        -: 1441:
        -: 1442:        (yyval.re_node) = yr_re_node_create(RE_NODE_STAR);
        -: 1443:
        -: 1444:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));
        -: 1445:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1446:
        -: 1447:        yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));
        -: 1448:
        -: 1449:        (yyval.re_node)->greedy = false;
        -: 1450:      }
        -: 1451:#line 1452 "re_grammar.c" /* yacc.c:1646  */
    #####: 1452:    break;
        -: 1453:
    #####: 1454:  case 11:
        -: 1455:#line 204 "re_grammar.y" /* yacc.c:1646  */
        -: 1456:    {
        -: 1457:        RE_AST* re_ast;
        -: 1458:
        -: 1459:        mark_as_not_fast_regexp();
        -: 1460:
        -: 1461:        re_ast = yyget_extra(yyscanner);
        -: 1462:        re_ast->flags |= RE_FLAGS_GREEDY;
        -: 1463:
        -: 1464:        (yyval.re_node) = yr_re_node_create(RE_NODE_PLUS);
        -: 1465:
        -: 1466:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1467:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1468:
        -: 1469:        yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));
        -: 1470:      }
        -: 1471:#line 1472 "re_grammar.c" /* yacc.c:1646  */
    #####: 1472:    break;
        -: 1473:
    #####: 1474:  case 12:
        -: 1475:#line 220 "re_grammar.y" /* yacc.c:1646  */
        -: 1476:    {
        -: 1477:        RE_AST* re_ast;
        -: 1478:
        -: 1479:        mark_as_not_fast_regexp();
        -: 1480:
        -: 1481:        re_ast = yyget_extra(yyscanner);
        -: 1482:        re_ast->flags |= RE_FLAGS_UNGREEDY;
        -: 1483:
        -: 1484:        (yyval.re_node) = yr_re_node_create(RE_NODE_PLUS);
        -: 1485:
        -: 1486:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));
        -: 1487:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1488:
        -: 1489:        yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));
        -: 1490:        (yyval.re_node)->greedy = false;
        -: 1491:      }
        -: 1492:#line 1493 "re_grammar.c" /* yacc.c:1646  */
    #####: 1493:    break;
        -: 1494:
    #####: 1495:  case 13:
        -: 1496:#line 237 "re_grammar.y" /* yacc.c:1646  */
        -: 1497:    {
        -: 1498:        RE_AST* re_ast = yyget_extra(yyscanner);
        -: 1499:        re_ast->flags |= RE_FLAGS_GREEDY;
        -: 1500:
        -: 1501:        if ((yyvsp[-1].re_node)->type == RE_NODE_ANY)
        -: 1502:        {
        -: 1503:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);
        -: 1504:          destroy_node_if(true, (yyvsp[-1].re_node));
        -: 1505:          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1506:        }
        -: 1507:        else
        -: 1508:        {
        -: 1509:          mark_as_not_fast_regexp();
        -: 1510:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE);
        -: 1511:          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1512:          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1513:          yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));
        -: 1514:        }
        -: 1515:
        -: 1516:        (yyval.re_node)->start = 0;
        -: 1517:        (yyval.re_node)->end = 1;
        -: 1518:      }
        -: 1519:#line 1520 "re_grammar.c" /* yacc.c:1646  */
    #####: 1520:    break;
        -: 1521:
    #####: 1522:  case 14:
        -: 1523:#line 260 "re_grammar.y" /* yacc.c:1646  */
        -: 1524:    {
        -: 1525:        RE_AST* re_ast = yyget_extra(yyscanner);
        -: 1526:        re_ast->flags |= RE_FLAGS_UNGREEDY;
        -: 1527:
        -: 1528:        if ((yyvsp[-2].re_node)->type == RE_NODE_ANY)
        -: 1529:        {
        -: 1530:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);
        -: 1531:          destroy_node_if(true, (yyvsp[-2].re_node));
        -: 1532:          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1533:        }
        -: 1534:        else
        -: 1535:        {
        -: 1536:          mark_as_not_fast_regexp();
        -: 1537:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE);
        -: 1538:          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));
        -: 1539:          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1540:          yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));
        -: 1541:        }
        -: 1542:
        -: 1543:        (yyval.re_node)->start = 0;
        -: 1544:        (yyval.re_node)->end = 1;
        -: 1545:        (yyval.re_node)->greedy = false;
        -: 1546:      }
        -: 1547:#line 1548 "re_grammar.c" /* yacc.c:1646  */
    #####: 1548:    break;
        -: 1549:
    #####: 1550:  case 15:
        -: 1551:#line 284 "re_grammar.y" /* yacc.c:1646  */
        -: 1552:    {
        -: 1553:        RE_AST* re_ast = yyget_extra(yyscanner);
        -: 1554:        re_ast->flags |= RE_FLAGS_GREEDY;
        -: 1555:
        -: 1556:        if ((yyvsp[-1].re_node)->type == RE_NODE_ANY)
        -: 1557:        {
        -: 1558:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);
        -: 1559:          destroy_node_if(true, (yyvsp[-1].re_node));
        -: 1560:          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1561:        }
        -: 1562:        else
        -: 1563:        {
        -: 1564:          mark_as_not_fast_regexp();
        -: 1565:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE);
        -: 1566:          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1567:          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1568:          yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));
        -: 1569:        }
        -: 1570:
        -: 1571:        (yyval.re_node)->start = (yyvsp[0].range) & 0xFFFF;;
        -: 1572:        (yyval.re_node)->end = (yyvsp[0].range) >> 16;;
        -: 1573:      }
        -: 1574:#line 1575 "re_grammar.c" /* yacc.c:1646  */
    #####: 1575:    break;
        -: 1576:
    #####: 1577:  case 16:
        -: 1578:#line 307 "re_grammar.y" /* yacc.c:1646  */
        -: 1579:    {
        -: 1580:        RE_AST* re_ast = yyget_extra(yyscanner);
        -: 1581:        re_ast->flags |= RE_FLAGS_UNGREEDY;
        -: 1582:
        -: 1583:        if ((yyvsp[-2].re_node)->type == RE_NODE_ANY)
        -: 1584:        {
        -: 1585:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);
        -: 1586:          destroy_node_if(true, (yyvsp[-2].re_node));
        -: 1587:          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1588:        }
        -: 1589:        else
        -: 1590:        {
        -: 1591:          mark_as_not_fast_regexp();
        -: 1592:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE);
        -: 1593:          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));
        -: 1594:          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1595:          yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));
        -: 1596:        }
        -: 1597:
        -: 1598:        (yyval.re_node)->start = (yyvsp[-1].range) & 0xFFFF;;
        -: 1599:        (yyval.re_node)->end = (yyvsp[-1].range) >> 16;;
        -: 1600:        (yyval.re_node)->greedy = false;
        -: 1601:      }
        -: 1602:#line 1603 "re_grammar.c" /* yacc.c:1646  */
    #####: 1603:    break;
        -: 1604:
    #####: 1605:  case 17:
        -: 1606:#line 331 "re_grammar.y" /* yacc.c:1646  */
        -: 1607:    {
        -: 1608:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1609:      }
        -: 1610:#line 1611 "re_grammar.c" /* yacc.c:1646  */
    #####: 1611:    break;
        -: 1612:
    #####: 1613:  case 18:
        -: 1614:#line 335 "re_grammar.y" /* yacc.c:1646  */
        -: 1615:    {
        -: 1616:        (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_BOUNDARY);
        -: 1617:
        -: 1618:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1619:      }
        -: 1620:#line 1621 "re_grammar.c" /* yacc.c:1646  */
    #####: 1621:    break;
        -: 1622:
    #####: 1623:  case 19:
        -: 1624:#line 341 "re_grammar.y" /* yacc.c:1646  */
        -: 1625:    {
        -: 1626:        (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_BOUNDARY);
        -: 1627:
        -: 1628:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1629:      }
        -: 1630:#line 1631 "re_grammar.c" /* yacc.c:1646  */
    #####: 1631:    break;
        -: 1632:
    #####: 1633:  case 20:
        -: 1634:#line 347 "re_grammar.y" /* yacc.c:1646  */
        -: 1635:    {
        -: 1636:        (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_START);
        -: 1637:
        -: 1638:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1639:      }
        -: 1640:#line 1641 "re_grammar.c" /* yacc.c:1646  */
    #####: 1641:    break;
        -: 1642:
    #####: 1643:  case 21:
        -: 1644:#line 353 "re_grammar.y" /* yacc.c:1646  */
        -: 1645:    {
        -: 1646:        (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_END);
        -: 1647:
        -: 1648:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1649:      }
        -: 1650:#line 1651 "re_grammar.c" /* yacc.c:1646  */
    #####: 1651:    break;
        -: 1652:
    #####: 1653:  case 22:
        -: 1654:#line 362 "re_grammar.y" /* yacc.c:1646  */
        -: 1655:    {
        -: 1656:        (yyval.re_node) = (yyvsp[-1].re_node);
        -: 1657:      }
        -: 1658:#line 1659 "re_grammar.c" /* yacc.c:1646  */
    #####: 1659:    break;
        -: 1660:
    #####: 1661:  case 23:
        -: 1662:#line 366 "re_grammar.y" /* yacc.c:1646  */
        -: 1663:    {
        -: 1664:        (yyval.re_node) = yr_re_node_create(RE_NODE_ANY);
        -: 1665:
        -: 1666:        (yyval.re_node)->value = 0x00;
        -: 1667:        (yyval.re_node)->mask = 0x00;
        -: 1668:
        -: 1669:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1670:      }
        -: 1671:#line 1672 "re_grammar.c" /* yacc.c:1646  */
    #####: 1672:    break;
        -: 1673:
    #####: 1674:  case 24:
        -: 1675:#line 375 "re_grammar.y" /* yacc.c:1646  */
        -: 1676:    {
        -: 1677:        (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL);
        -: 1678:
        -: 1679:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1680:
        -: 1681:        (yyval.re_node)->value = (yyvsp[0].integer);
        -: 1682:        (yyval.re_node)->mask = 0xFF;
        -: 1683:      }
        -: 1684:#line 1685 "re_grammar.c" /* yacc.c:1646  */
    #####: 1685:    break;
        -: 1686:
    #####: 1687:  case 25:
        -: 1688:#line 384 "re_grammar.y" /* yacc.c:1646  */
        -: 1689:    {
        -: 1690:        (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_CHAR);
        -: 1691:
        -: 1692:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1693:      }
        -: 1694:#line 1695 "re_grammar.c" /* yacc.c:1646  */
    #####: 1695:    break;
        -: 1696:
    #####: 1697:  case 26:
        -: 1698:#line 390 "re_grammar.y" /* yacc.c:1646  */
        -: 1699:    {
        -: 1700:        (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_CHAR);
        -: 1701:
        -: 1702:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1703:      }
        -: 1704:#line 1705 "re_grammar.c" /* yacc.c:1646  */
    #####: 1705:    break;
        -: 1706:
    #####: 1707:  case 27:
        -: 1708:#line 396 "re_grammar.y" /* yacc.c:1646  */
        -: 1709:    {
        -: 1710:        (yyval.re_node) = yr_re_node_create(RE_NODE_SPACE);
        -: 1711:
        -: 1712:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1713:      }
        -: 1714:#line 1715 "re_grammar.c" /* yacc.c:1646  */
    #####: 1715:    break;
        -: 1716:
    #####: 1717:  case 28:
        -: 1718:#line 402 "re_grammar.y" /* yacc.c:1646  */
        -: 1719:    {
        -: 1720:         (yyval.re_node) = yr_re_node_create(RE_NODE_NON_SPACE);
        -: 1721:
        -: 1722:         fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1723:      }
        -: 1724:#line 1725 "re_grammar.c" /* yacc.c:1646  */
    #####: 1725:    break;
        -: 1726:
    #####: 1727:  case 29:
        -: 1728:#line 408 "re_grammar.y" /* yacc.c:1646  */
        -: 1729:    {
        -: 1730:        (yyval.re_node) = yr_re_node_create(RE_NODE_DIGIT);
        -: 1731:
        -: 1732:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1733:      }
        -: 1734:#line 1735 "re_grammar.c" /* yacc.c:1646  */
    #####: 1735:    break;
        -: 1736:
    #####: 1737:  case 30:
        -: 1738:#line 414 "re_grammar.y" /* yacc.c:1646  */
        -: 1739:    {
        -: 1740:        (yyval.re_node) = yr_re_node_create(RE_NODE_NON_DIGIT);
        -: 1741:
        -: 1742:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1743:      }
        -: 1744:#line 1745 "re_grammar.c" /* yacc.c:1646  */
    #####: 1745:    break;
        -: 1746:
    #####: 1747:  case 31:
        -: 1748:#line 420 "re_grammar.y" /* yacc.c:1646  */
        -: 1749:    {
        -: 1750:        (yyval.re_node) = yr_re_node_create(RE_NODE_CLASS);
        -: 1751:
        -: 1752:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1753:
        -: 1754:        (yyval.re_node)->re_class = (yyvsp[0].re_class);
        -: 1755:      }
        -: 1756:#line 1757 "re_grammar.c" /* yacc.c:1646  */
    #####: 1757:    break;
        -: 1758:
        -: 1759:
        -: 1760:#line 1761 "re_grammar.c" /* yacc.c:1646  */
    #####: 1761:      default: break;
        -: 1762:    }
        -: 1763:  /* User semantic actions sometimes alter yychar, and that requires
        -: 1764:     that yytoken be updated with the new translation.  We take the
        -: 1765:     approach of translating immediately before every use of yytoken.
        -: 1766:     One alternative is translating here after every semantic action,
        -: 1767:     but that translation would be missed if the semantic action invokes
        -: 1768:     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
        -: 1769:     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
        -: 1770:     incorrect destructor might then be invoked immediately.  In the
        -: 1771:     case of YYERROR or YYBACKUP, subsequent parser actions might lead
        -: 1772:     to an incorrect destructor call or verbose syntax error message
        -: 1773:     before the lookahead is translated.  */
        -: 1774:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
        -: 1775:
    #####: 1776:  YYPOPSTACK (yylen);
    #####: 1777:  yylen = 0;
        -: 1778:  YY_STACK_PRINT (yyss, yyssp);
        -: 1779:
    #####: 1780:  *++yyvsp = yyval;
        -: 1781:
        -: 1782:  /* Now 'shift' the result of the reduction.  Determine what state
        -: 1783:     that goes to, based on the state we popped back to and the rule
        -: 1784:     number reduced by.  */
        -: 1785:
    #####: 1786:  yyn = yyr1[yyn];
        -: 1787:
    #####: 1788:  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
    #####: 1789:  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    #####: 1790:    yystate = yytable[yystate];
        -: 1791:  else
    #####: 1792:    yystate = yydefgoto[yyn - YYNTOKENS];
        -: 1793:
    #####: 1794:  goto yynewstate;
        -: 1795:
        -: 1796:
        -: 1797:/*--------------------------------------.
        -: 1798:| yyerrlab -- here on detecting error.  |
        -: 1799:`--------------------------------------*/
    #####: 1800:yyerrlab:
        -: 1801:  /* Make sure we have latest lookahead translation.  See comments at
        -: 1802:     user semantic actions for why this is necessary.  */
    #####: 1803:  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
        -: 1804:
        -: 1805:  /* If not already recovering from an error, report this error.  */
    #####: 1806:  if (!yyerrstatus)
        -: 1807:    {
    #####: 1808:      ++yynerrs;
        -: 1809:#if ! YYERROR_VERBOSE
        -: 1810:      yyerror (yyscanner, lex_env, YY_("syntax error"));
        -: 1811:#else
        -: 1812:# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
        -: 1813:                                        yyssp, yytoken)
        -: 1814:      {
    #####: 1815:        char const *yymsgp = YY_("syntax error");
        -: 1816:        int yysyntax_error_status;
    #####: 1817:        yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 1818:        if (yysyntax_error_status == 0)
    #####: 1819:          yymsgp = yymsg;
    #####: 1820:        else if (yysyntax_error_status == 1)
        -: 1821:          {
    #####: 1822:            if (yymsg != yymsgbuf)
    #####: 1823:              YYSTACK_FREE (yymsg);
    #####: 1824:            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
    #####: 1825:            if (!yymsg)
        -: 1826:              {
    #####: 1827:                yymsg = yymsgbuf;
    #####: 1828:                yymsg_alloc = sizeof yymsgbuf;
    #####: 1829:                yysyntax_error_status = 2;
        -: 1830:              }
        -: 1831:            else
        -: 1832:              {
    #####: 1833:                yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 1834:                yymsgp = yymsg;
        -: 1835:              }
        -: 1836:          }
    #####: 1837:        yyerror (yyscanner, lex_env, yymsgp);
    #####: 1838:        if (yysyntax_error_status == 2)
    #####: 1839:          goto yyexhaustedlab;
        -: 1840:      }
        -: 1841:# undef YYSYNTAX_ERROR
        -: 1842:#endif
        -: 1843:    }
        -: 1844:
        -: 1845:
        -: 1846:
    #####: 1847:  if (yyerrstatus == 3)
        -: 1848:    {
        -: 1849:      /* If just tried and failed to reuse lookahead token after an
        -: 1850:         error, discard it.  */
        -: 1851:
    #####: 1852:      if (yychar <= YYEOF)
        -: 1853:        {
        -: 1854:          /* Return failure if at end of input.  */
    #####: 1855:          if (yychar == YYEOF)
    #####: 1856:            YYABORT;
        -: 1857:        }
        -: 1858:      else
        -: 1859:        {
    #####: 1860:          yydestruct ("Error: discarding",
        -: 1861:                      yytoken, &yylval, yyscanner, lex_env);
    #####: 1862:          yychar = YYEMPTY;
        -: 1863:        }
        -: 1864:    }
        -: 1865:
        -: 1866:  /* Else will try to reuse lookahead token after shifting the error
        -: 1867:     token.  */
    #####: 1868:  goto yyerrlab1;
        -: 1869:
        -: 1870:
        -: 1871:/*---------------------------------------------------.
        -: 1872:| yyerrorlab -- error raised explicitly by YYERROR.  |
        -: 1873:`---------------------------------------------------*/
        -: 1874:yyerrorlab:
        -: 1875:
        -: 1876:  /* Pacify compilers like GCC when the user code never invokes
        -: 1877:     YYERROR and the label yyerrorlab therefore never appears in user
        -: 1878:     code.  */
        -: 1879:  if (/*CONSTCOND*/ 0)
        -: 1880:     goto yyerrorlab;
        -: 1881:
        -: 1882:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 1883:     this YYERROR.  */
        -: 1884:  YYPOPSTACK (yylen);
        -: 1885:  yylen = 0;
        -: 1886:  YY_STACK_PRINT (yyss, yyssp);
        -: 1887:  yystate = *yyssp;
        -: 1888:  goto yyerrlab1;
        -: 1889:
        -: 1890:
        -: 1891:/*-------------------------------------------------------------.
        -: 1892:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
        -: 1893:`-------------------------------------------------------------*/
    #####: 1894:yyerrlab1:
    #####: 1895:  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
        -: 1896:
        -: 1897:  for (;;)
        -: 1898:    {
    #####: 1899:      yyn = yypact[yystate];
    #####: 1900:      if (!yypact_value_is_default (yyn))
        -: 1901:        {
    #####: 1902:          yyn += YYTERROR;
    #####: 1903:          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
        -: 1904:            {
    #####: 1905:              yyn = yytable[yyn];
    #####: 1906:              if (0 < yyn)
    #####: 1907:                break;
        -: 1908:            }
        -: 1909:        }
        -: 1910:
        -: 1911:      /* Pop the current state because it cannot handle the error token.  */
    #####: 1912:      if (yyssp == yyss)
    #####: 1913:        YYABORT;
        -: 1914:
        -: 1915:
    #####: 1916:      yydestruct ("Error: popping",
    #####: 1917:                  yystos[yystate], yyvsp, yyscanner, lex_env);
    #####: 1918:      YYPOPSTACK (1);
    #####: 1919:      yystate = *yyssp;
        -: 1920:      YY_STACK_PRINT (yyss, yyssp);
        -: 1921:    }
        -: 1922:
        -: 1923:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 1924:  *++yyvsp = yylval;
        -: 1925:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1926:
        -: 1927:
        -: 1928:  /* Shift the error token.  */
        -: 1929:  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
        -: 1930:
    #####: 1931:  yystate = yyn;
    #####: 1932:  goto yynewstate;
        -: 1933:
        -: 1934:
        -: 1935:/*-------------------------------------.
        -: 1936:| yyacceptlab -- YYACCEPT comes here.  |
        -: 1937:`-------------------------------------*/
    #####: 1938:yyacceptlab:
    #####: 1939:  yyresult = 0;
    #####: 1940:  goto yyreturn;
        -: 1941:
        -: 1942:/*-----------------------------------.
        -: 1943:| yyabortlab -- YYABORT comes here.  |
        -: 1944:`-----------------------------------*/
    #####: 1945:yyabortlab:
    #####: 1946:  yyresult = 1;
    #####: 1947:  goto yyreturn;
        -: 1948:
        -: 1949:#if !defined yyoverflow || YYERROR_VERBOSE
        -: 1950:/*-------------------------------------------------.
        -: 1951:| yyexhaustedlab -- memory exhaustion comes here.  |
        -: 1952:`-------------------------------------------------*/
    #####: 1953:yyexhaustedlab:
    #####: 1954:  yyerror (yyscanner, lex_env, YY_("memory exhausted"));
    #####: 1955:  yyresult = 2;
        -: 1956:  /* Fall through.  */
        -: 1957:#endif
        -: 1958:
    #####: 1959:yyreturn:
    #####: 1960:  if (yychar != YYEMPTY)
        -: 1961:    {
        -: 1962:      /* Make sure we have latest lookahead translation.  See comments at
        -: 1963:         user semantic actions for why this is necessary.  */
    #####: 1964:      yytoken = YYTRANSLATE (yychar);
    #####: 1965:      yydestruct ("Cleanup: discarding lookahead",
        -: 1966:                  yytoken, &yylval, yyscanner, lex_env);
        -: 1967:    }
        -: 1968:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 1969:     this YYABORT or YYACCEPT.  */
    #####: 1970:  YYPOPSTACK (yylen);
        -: 1971:  YY_STACK_PRINT (yyss, yyssp);
    #####: 1972:  while (yyssp != yyss)
        -: 1973:    {
    #####: 1974:      yydestruct ("Cleanup: popping",
    #####: 1975:                  yystos[*yyssp], yyvsp, yyscanner, lex_env);
    #####: 1976:      YYPOPSTACK (1);
        -: 1977:    }
        -: 1978:#ifndef yyoverflow
    #####: 1979:  if (yyss != yyssa)
    #####: 1980:    YYSTACK_FREE (yyss);
        -: 1981:#endif
        -: 1982:#if YYERROR_VERBOSE
    #####: 1983:  if (yymsg != yymsgbuf)
    #####: 1984:    YYSTACK_FREE (yymsg);
        -: 1985:#endif
    #####: 1986:  return yyresult;
        -: 1987:}
        -: 1988:#line 428 "re_grammar.y" /* yacc.c:1906  */
        -: 1989:
