        -:    0:Source:re_lexer.l
        -:    0:Graph:/home/workspace/libyara/re_lexer.gcno
        -:    0:Data:/home/workspace/libyara/re_lexer.gcda
        -:    0:Runs:8
        -:    0:Programs:8
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/* Lexical analyzer for regular expressions */
        -:   31:
        -:   32:%{
        -:   33:
        -:   34:/* Disable warnings for unused functions in this file.
        -:   35:
        -:   36:As we redefine YY_FATAL_ERROR macro to use our own function re_yyfatal, the
        -:   37:yy_fatal_error function generated by Flex is not actually used, causing a
        -:   38:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -:   39:function. When they include something like %option noyy_fatal_error as they do
        -:   40:with noyywrap then we can remove this pragma.
        -:   41:*/
        -:   42:
        -:   43:#ifdef __GNUC__
        -:   44:#pragma GCC diagnostic ignored "-Wunused-function"
        -:   45:#endif
        -:   46:
        -:   47:#include <assert.h>
        -:   48:#include <setjmp.h>
        -:   49:
        -:   50:#include <yara/globals.h>
        -:   51:#include <yara/utils.h>
        -:   52:#include <yara/error.h>
        -:   53:#include <yara/limits.h>
        -:   54:#include <yara/mem.h>
        -:   55:#include <yara/re.h>
        -:   56:#include <yara/re_lexer.h>
        -:   57:#include <yara/threading.h>
        -:   58:#include <yara/strutils.h>
        -:   59:
        -:   60:
        -:   61:#ifdef _WIN32
        -:   62:#define snprintf _snprintf
        -:   63:#endif
        -:   64:
        -:   65:static uint8_t word_chars[] = {
        -:   66:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        -:   67:    0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07,
        -:   68:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        -:   69:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        -:   70:
        -:   71:
        -:   72:int escaped_char_value(
        -:   73:    char* text,
        -:   74:    uint8_t* value);
        -:   75:
        -:   76:int read_escaped_char(
        -:   77:    yyscan_t yyscanner,
        -:   78:    uint8_t* escaped_char);
        -:   79:
        -:   80:%}
        -:   81:
        -:   82:%option reentrant bison-bridge
        -:   83:%option noyywrap
        -:   84:%option nounistd
        -:   85:%option nounput
        -:   86:%option never-interactive
        -:   87:%option yylineno
        -:   88:%option prefix="re_yy"
        -:   89:
        -:   90:%option outfile="lex.yy.c"
        -:   91:
        -:   92:%option verbose
        -:   93:%option warn
        -:   94:
        -:   95:%x char_class
        -:   96:
        -:   97:digit         [0-9]
        -:   98:hex_digit     [0-9a-fA-F]
        -:   99:
        -:  100:%%
        -:  101:
        -:  102:\{{digit}*,{digit}*\} {
        -:  103:
        -:  104:  // Examples: {3,8} {0,5} {,5} {7,}
        -:  105:
        -:  106:  int hi_bound;
    #####:  107:  int lo_bound = atoi(yytext + 1);
        -:  108:
    #####:  109:  char* comma = strchr(yytext, ',');
        -:  110:
    #####:  111:  if (comma - yytext == strlen(yytext) - 2)
        -:  112:    // if comma is followed by the closing curly bracket
        -:  113:    // (example: {2,}) set high bound value to maximum.
    #####:  114:    hi_bound = INT16_MAX;
        -:  115:  else
    #####:  116:    hi_bound = atoi(comma + 1);
        -:  117:
    #####:  118:  if (hi_bound > INT16_MAX)
        -:  119:  {
    #####:  120:    yyerror(yyscanner, lex_env, "repeat interval too large");
    #####:  121:    yyterminate();
        -:  122:  }
        -:  123:
    #####:  124:  if (hi_bound < lo_bound || hi_bound < 0 || lo_bound < 0)
        -:  125:  {
    #####:  126:    yyerror(yyscanner, lex_env, "bad repeat interval");
    #####:  127:    yyterminate();
        -:  128:  }
        -:  129:
    #####:  130:  if (hi_bound == 0 && lo_bound == 0)
        -:  131:  {
    #####:  132:    yyerror(yyscanner, lex_env, "bad repeat interval");
    #####:  133:    yyterminate();
        -:  134:  }
        -:  135:
    #####:  136:  yylval->range = (hi_bound << 16) | lo_bound;
        -:  137:
    #####:  138:  return _RANGE_;
        -:  139:}
        -:  140:
    #####:  141:
        -:  142:\{{digit}+\} {
        -:  143:
        -:  144:  // Example: {10}
        -:  145:
    #####:  146:  int value = atoi(yytext + 1);
        -:  147:
        -:  148:  // atoi can return a negative value if the input string represents a number
        -:  149:  // too large to fit in an integer.
        -:  150:
    #####:  151:  if (value > INT16_MAX || value < 0)
        -:  152:  {
    #####:  153:    yyerror(yyscanner, lex_env, "repeat interval too large");
    #####:  154:    yyterminate();
        -:  155:  }
        -:  156:
    #####:  157:  if (value == 0)
        -:  158:  {
    #####:  159:    yyerror(yyscanner, lex_env, "bad repeat interval");
    #####:  160:    yyterminate();
        -:  161:  }
        -:  162:
    #####:  163:  yylval->range = (value << 16) | value;
        -:  164:
    #####:  165:  return _RANGE_;
        -:  166:}
        -:  167:
    #####:  168:
        -:  169:\[\^ {
        -:  170:
        -:  171:  // Start of a negated character class. Example: [^abcd]
        -:  172:
    #####:  173:  BEGIN(char_class);
    #####:  174:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  175:  LEX_ENV->re_class.negated = true;
        -:  176:}
    #####:  177:
    #####:  178:\[\^\] {
        -:  179:
        -:  180:  // Start of character negated class containing a ].
        -:  181:  // Example: [^]abc] this must be interpreted as a class
        -:  182:  // not matching ], a, b, nor c
        -:  183:
    #####:  184:  BEGIN(char_class);
    #####:  185:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  186:  LEX_ENV->re_class.negated = true;
    #####:  187:  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;
        -:  188:}
    #####:  189:
    #####:  190:
        -:  191:\[\] {
        -:  192:
        -:  193:  // Start of character class containing a ].
        -:  194:  // Example: []abc] this must be interpreted as a class
        -:  195:  // matching ], a, b, or c.
        -:  196:
    #####:  197:  BEGIN(char_class);
    #####:  198:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  199:  LEX_ENV->re_class.negated = false;
    #####:  200:  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;
        -:  201:}
    #####:  202:
    #####:  203:
        -:  204:\[ {
        -:  205:
        -:  206:  // Start of character class. Example: [abcd]
        -:  207:
    #####:  208:  BEGIN(char_class);
    #####:  209:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  210:  LEX_ENV->re_class.negated = false;
        -:  211:}
    #####:  212:
    #####:  213:
        -:  214:[^\\\[\(\)\|\$\.\^\+\*\?] {
        -:  215:
        -:  216:  // Any non-special character is passed as a CHAR token to the scanner.
        -:  217:
    #####:  218:  yylval->integer = yytext[0];
    #####:  219:  return _CHAR_;
        -:  220:}
        -:  221:
    #####:  222:
        -:  223:\\w {
    #####:  224:  return _WORD_CHAR_;
        -:  225:}
        -:  226:
    #####:  227:
        -:  228:\\W {
    #####:  229:  return _NON_WORD_CHAR_;
        -:  230:}
        -:  231:
    #####:  232:
        -:  233:\\s {
    #####:  234:  return _SPACE_;
        -:  235:}
        -:  236:
    #####:  237:
        -:  238:\\S {
    #####:  239:  return _NON_SPACE_;
        -:  240:}
        -:  241:
    #####:  242:
        -:  243:\\d {
    #####:  244:  return _DIGIT_;
        -:  245:}
        -:  246:
    #####:  247:
        -:  248:\\D {
    #####:  249:  return _NON_DIGIT_;
        -:  250:}
        -:  251:
    #####:  252:
        -:  253:\\b {
    #####:  254:  return _WORD_BOUNDARY_;
        -:  255:}
        -:  256:
    #####:  257:\\B {
    #####:  258:  return _NON_WORD_BOUNDARY_;
        -:  259:}
        -:  260:
    #####:  261:
        -:  262:\\{digit}+ {
        -:  263:
    #####:  264:  yyerror(yyscanner, lex_env, "backreferences are not allowed");
    #####:  265:  yyterminate();
        -:  266:}
        -:  267:
    #####:  268:
        -:  269:\\ {
        -:  270:
        -:  271:  uint8_t c;
        -:  272:
    #####:  273:  if (read_escaped_char(yyscanner, &c))
        -:  274:  {
    #####:  275:    yylval->integer = c;
    #####:  276:    return _CHAR_;
        -:  277:  }
        -:  278:  else
        -:  279:  {
    #####:  280:    yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  281:    yyterminate();
        -:  282:  }
        -:  283:}
        -:  284:
    #####:  285:
        -:  286:<char_class>\] {
        -:  287:
        -:  288:  // End of character class.
    #####:  289:  yylval->re_class = (RE_CLASS*) yr_malloc(sizeof(RE_CLASS));
    #####:  290:  memcpy(yylval->re_class->bitmap, LEX_ENV->re_class.bitmap, 32);
        -:  291:
    #####:  292:  yylval->re_class->negated = LEX_ENV->re_class.negated;
        -:  293:
    #####:  294:  BEGIN(INITIAL);
    #####:  295:  return _CLASS_;
        -:  296:}
        -:  297:
    #####:  298:
        -:  299:
        -:  300:<char_class>(\\x{hex_digit}{2}|\\.|[^\\])\-[^]] {
        -:  301:
        -:  302:  // A range inside a character class.
        -:  303:  //  [abc0-9]
        -:  304:  //      ^- matching here
        -:  305:
        -:  306:  uint16_t c;
    #####:  307:  uint8_t start = yytext[0];
    #####:  308:  uint8_t end = yytext[2];
        -:  309:
    #####:  310:  if (start == '\\')
        -:  311:  {
    #####:  312:    if (!escaped_char_value(yytext, &start))
        -:  313:    {
    #####:  314:      yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  315:      yyterminate();
        -:  316:    }
        -:  317:
    #####:  318:    if (yytext[1] == 'x')
    #####:  319:      end = yytext[5];
        -:  320:    else
    #####:  321:      end = yytext[3];
        -:  322:  }
        -:  323:
    #####:  324:  if (end == '\\')
        -:  325:  {
    #####:  326:    if (!read_escaped_char(yyscanner, &end))
        -:  327:    {
    #####:  328:      yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  329:      yyterminate();
        -:  330:    }
        -:  331:  }
        -:  332:
    #####:  333:  if (end < start)
        -:  334:  {
    #####:  335:    yyerror(yyscanner, lex_env, "bad character range");
    #####:  336:    yyterminate();
        -:  337:  }
        -:  338:
    #####:  339:  for (c = start; c <= end; c++)
        -:  340:  {
    #####:  341:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  342:  }
        -:  343:}
    #####:  344:
    #####:  345:
        -:  346:<char_class>\\w {
        -:  347:
        -:  348:  int i;
        -:  349:
    #####:  350:  for (i = 0; i < 32; i++)
    #####:  351:    LEX_ENV->re_class.bitmap[i] |= word_chars[i];
        -:  352:}
    #####:  353:
    #####:  354:
        -:  355:<char_class>\\W {
        -:  356:
        -:  357:  int i;
        -:  358:
    #####:  359:  for (i = 0; i < 32; i++)
    #####:  360:    LEX_ENV->re_class.bitmap[i] |= ~word_chars[i];
        -:  361:}
    #####:  362:
    #####:  363:
        -:  364:<char_class>\\s {
        -:  365:
    #####:  366:  LEX_ENV->re_class.bitmap[' ' / 8] |= 1 << ' ' % 8;
    #####:  367:  LEX_ENV->re_class.bitmap['\t' / 8] |= 1 << '\t' % 8;
        -:  368:}
    #####:  369:
    #####:  370:
        -:  371:<char_class>\\S {
        -:  372:
        -:  373:  int i;
        -:  374:
    #####:  375:  for (i = 0; i < 32; i++)
        -:  376:  {
    #####:  377:    if (i == ' ' / 8)
    #####:  378:      LEX_ENV->re_class.bitmap[i] |= ~(1 << ' ' % 8);
    #####:  379:    else if (i == '\t' / 8)
    #####:  380:      LEX_ENV->re_class.bitmap[i] |= ~(1 << '\t' % 8);
        -:  381:    else
    #####:  382:      LEX_ENV->re_class.bitmap[i] = 0xFF;
        -:  383:  }
        -:  384:}
    #####:  385:
    #####:  386:
        -:  387:<char_class>\\d {
        -:  388:
        -:  389:  char c;
        -:  390:
    #####:  391:  for (c = '0'; c <= '9'; c++)
    #####:  392:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  393:}
    #####:  394:
    #####:  395:
        -:  396:<char_class>\\D {
        -:  397:
        -:  398:  int i;
        -:  399:
    #####:  400:  for (i = 0; i < 32; i++)
        -:  401:  {
        -:  402:    // digits 0-7 are in the sixth byte of the vector, let that byte alone
    #####:  403:    if (i == 6)
    #####:  404:      continue;
        -:  405:
        -:  406:    // digits 8 and 9 are the lowest two bits in the seventh byte of the
        -:  407:    // vector, let those bits alone.
    #####:  408:    if (i == 7)
    #####:  409:      LEX_ENV->re_class.bitmap[i] |= 0xFC;
        -:  410:    else
    #####:  411:      LEX_ENV->re_class.bitmap[i] = 0xFF;
        -:  412:  }
        -:  413:}
    #####:  414:
    #####:  415:
        -:  416:<char_class>\\ {
        -:  417:
        -:  418:  uint8_t c;
        -:  419:
    #####:  420:  if (read_escaped_char(yyscanner, &c))
        -:  421:  {
    #####:  422:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  423:  }
        -:  424:  else
        -:  425:  {
    #####:  426:    yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  427:    yyterminate();
        -:  428:  }
        -:  429:}
    #####:  430:
    #####:  431:
        -:  432:<char_class>. {
        -:  433:
    #####:  434:  if (yytext[0] >= 32 && yytext[0] < 127)
        -:  435:  {
        -:  436:    // A character class (i.e: [0-9a-f]) is represented by a 256-bits vector,
        -:  437:    // here we set to 1 the vector's bit corresponding to the input character.
        -:  438:
    #####:  439:    LEX_ENV->re_class.bitmap[yytext[0] / 8] |= 1 << yytext[0] % 8;
        -:  440:  }
        -:  441:  else
        -:  442:  {
    #####:  443:    yyerror(yyscanner, lex_env, "non-ascii character");
    #####:  444:    yyterminate();
        -:  445:  }
        -:  446:}
    #####:  447:
    #####:  448:
        -:  449:<char_class><<EOF>> {
        -:  450:
        -:  451:  // End of regexp reached while scanning a character class.
        -:  452:
    #####:  453:  yyerror(yyscanner, lex_env, "missing terminating ] for character class");
    #####:  454:  yyterminate();
        -:  455:}
        -:  456:
    #####:  457:
        -:  458:. {
        -:  459:
    #####:  460:  if (yytext[0] >= 32 && yytext[0] < 127)
        -:  461:  {
    #####:  462:    return yytext[0];
        -:  463:  }
        -:  464:  else
        -:  465:  {
    #####:  466:    yyerror(yyscanner, lex_env, "non-ascii character");
    #####:  467:    yyterminate();
        -:  468:  }
        -:  469:}
        -:  470:
    #####:  471:
        -:  472:<<EOF>> {
        -:  473:
    #####:  474:  yyterminate();
        -:  475:}
        -:  476:
    #####:  477:%%
    #####:  478:
    #####:  479:int escaped_char_value(
        -:  480:    char* text,
        -:  481:    uint8_t* value)
        -:  482:{
        -:  483:  unsigned int hex_value;
        -:  484:  char hex[3];
        -:  485:
    #####:  486:  assert(text[0] == '\\');
        -:  487:
    #####:  488:  switch(text[1])
        -:  489:  {
    #####:  490:  case 'x':
    #####:  491:    if (!isxdigit(text[2]) || !isxdigit(text[3]))
    #####:  492:      return 0;
    #####:  493:    hex[0] = text[2];
    #####:  494:    hex[1] = text[3];
    #####:  495:    hex[2] = '\0';
    #####:  496:    sscanf(hex, "%x", &hex_value);
    #####:  497:    *value = (uint8_t) hex_value;
    #####:  498:    break;
        -:  499:
    #####:  500:  case 'n':
    #####:  501:    *value = '\n';
    #####:  502:    break;
        -:  503:
    #####:  504:  case 't':
    #####:  505:    *value = '\t';
    #####:  506:    break;
        -:  507:
    #####:  508:  case 'r':
    #####:  509:    *value = '\r';
    #####:  510:    break;
        -:  511:
    #####:  512:  case 'f':
    #####:  513:    *value = '\f';
    #####:  514:    break;
        -:  515:
    #####:  516:  case 'a':
    #####:  517:    *value = '\a';
    #####:  518:    break;
        -:  519:
    #####:  520:  default:
    #####:  521:    *value = text[1];
        -:  522:  }
        -:  523:
    #####:  524:  return 1;
        -:  525:}
        -:  526:
        -:  527:
        -:  528:#ifdef __cplusplus
        -:  529:#define RE_YY_INPUT yyinput
        -:  530:#else
        -:  531:#define RE_YY_INPUT input
        -:  532:#endif
        -:  533:
        -:  534:
    #####:  535:int read_escaped_char(
        -:  536:    yyscan_t yyscanner,
        -:  537:    uint8_t* escaped_char)
        -:  538:{
    #####:  539:  char text[4] = {0, 0, 0, 0};
        -:  540:
    #####:  541:  text[0] = '\\';
    #####:  542:  text[1] = RE_YY_INPUT(yyscanner);
        -:  543:
    #####:  544:  if (text[1] == EOF || text[1] == 0)
    #####:  545:    return 0;
        -:  546:
    #####:  547:  if (text[1] == 'x')
        -:  548:  {
    #####:  549:    text[2] = RE_YY_INPUT(yyscanner);
        -:  550:
    #####:  551:    if (text[2] == EOF || text[2] == 0)
    #####:  552:      return 0;
        -:  553:
    #####:  554:    text[3] = RE_YY_INPUT(yyscanner);
        -:  555:
    #####:  556:    if (text[3] == EOF || text[3] == 0)
    #####:  557:      return 0;
        -:  558:  }
        -:  559:
    #####:  560:  return escaped_char_value(text, escaped_char);
        -:  561:}
        -:  562:
        -:  563:
    #####:  564:void yyfatal(
        -:  565:    yyscan_t yyscanner,
        -:  566:    const char *error_message)
        -:  567:{
    #####:  568:  jmp_buf* recovery_state = (jmp_buf*) yr_thread_storage_get_value(
        -:  569:      &yr_recovery_state_key);
        -:  570:
    #####:  571:  longjmp(*recovery_state, 1);
        -:  572:}
        -:  573:
        -:  574:
    #####:  575:void yyerror(
        -:  576:    yyscan_t yyscanner,
        -:  577:    RE_LEX_ENVIRONMENT* lex_env,
        -:  578:    const char *error_message)
        -:  579:{
        -:  580:  // if lex_env->last_error was set to some error code before
        -:  581:  // don't overwrite it, we are interested in the first error, not in
        -:  582:  // subsequent errors like "syntax error, unexpected $end" caused by
        -:  583:  // early parser termination.
        -:  584:
    #####:  585:  if (lex_env->last_error == ERROR_SUCCESS)
        -:  586:  {
    #####:  587:    lex_env->last_error = ERROR_INVALID_REGULAR_EXPRESSION;
        -:  588:
    #####:  589:    strlcpy(
    #####:  590:        lex_env->last_error_message,
        -:  591:        error_message,
        -:  592:        sizeof(lex_env->last_error_message));
        -:  593:  }
    #####:  594:}
        -:  595:
        -:  596:
    #####:  597:int yr_parse_re_string(
        -:  598:  const char* re_string,
        -:  599:  RE_AST** re_ast,
        -:  600:  RE_ERROR* error)
        -:  601:{
        -:  602:  yyscan_t yyscanner;
        -:  603:  jmp_buf recovery_state;
        -:  604:  RE_LEX_ENVIRONMENT lex_env;
        -:  605:
    #####:  606:  lex_env.last_error = ERROR_SUCCESS;
    #####:  607:  lex_env.last_error_message[0] = '\0';
        -:  608:
    #####:  609:  yr_thread_storage_set_value(&yr_recovery_state_key, &recovery_state);
        -:  610:
    #####:  611:  if (setjmp(recovery_state) != 0)
    #####:  612:    return ERROR_INTERNAL_FATAL_ERROR;
        -:  613:
    #####:  614:  FAIL_ON_ERROR(yr_re_ast_create(re_ast));
        -:  615:
    #####:  616:  yylex_init(&yyscanner);
    #####:  617:  yyset_extra(*re_ast, yyscanner);
    #####:  618:  yy_scan_string(re_string, yyscanner);
    #####:  619:  yyparse(yyscanner, &lex_env);
    #####:  620:  yylex_destroy(yyscanner);
        -:  621:
    #####:  622:  if (lex_env.last_error != ERROR_SUCCESS)
        -:  623:  {
    #####:  624:    yr_re_ast_destroy(*re_ast);
    #####:  625:    *re_ast = NULL;
        -:  626:
    #####:  627:    strlcpy(
    #####:  628:        error->message,
        -:  629:        lex_env.last_error_message,
        -:  630:        sizeof(error->message));
        -:  631:
    #####:  632:    return lex_env.last_error;
        -:  633:  }
        -:  634:
    #####:  635:  return ERROR_SUCCESS;
        -:  636:}
