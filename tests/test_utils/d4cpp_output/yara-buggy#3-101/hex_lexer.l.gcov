        -:    0:Source:hex_lexer.l
        -:    0:Graph:/home/workspace/libyara/hex_lexer.gcno
        -:    0:Data:/home/workspace/libyara/hex_lexer.gcda
        -:    0:Runs:8
        -:    0:Programs:8
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/* Lexical analyzer for hex strings */
        -:   31:
        -:   32:%{
        -:   33:
        -:   34:/* Disable warnings for unused functions in this file.
        -:   35:
        -:   36:As we redefine YY_FATAL_ERROR macro to use our own function hex_yyfatal, the
        -:   37:yy_fatal_error function generated by Flex is not actually used, causing a
        -:   38:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -:   39:function. When they include something like %option noyy_fatal_error as they do
        -:   40:with noyywrap then we can remove this pragma.
        -:   41:*/
        -:   42:
        -:   43:#ifdef __GNUC__
        -:   44:#pragma GCC diagnostic ignored "-Wunused-function"
        -:   45:#endif
        -:   46:
        -:   47:#include <setjmp.h>
        -:   48:
        -:   49:#include <yara/globals.h>
        -:   50:#include <yara/limits.h>
        -:   51:#include <yara/error.h>
        -:   52:#include <yara/mem.h>
        -:   53:#include <yara/re.h>
        -:   54:#include <yara/threading.h>
        -:   55:#include <yara/strutils.h>
        -:   56:#include <yara/hex_lexer.h>
        -:   57:
        -:   58:#include "hex_grammar.h"
        -:   59:
        -:   60:#ifdef _WIN32
        -:   61:#define snprintf _snprintf
        -:   62:#endif
        -:   63:
        -:   64:#define ERROR_IF(x, error) \
        -:   65:    if (x) \
        -:   66:    { \
        -:   67:      RE_AST* re_ast = yyget_extra(yyscanner); \
        -:   68:      re_ast->error_code = error; \
        -:   69:      YYABORT; \
        -:   70:    } \
        -:   71:
        -:   72:%}
        -:   73:
        -:   74:%option reentrant bison-bridge
        -:   75:%option noyywrap
        -:   76:%option nounistd
        -:   77:%option noinput
        -:   78:%option nounput
        -:   79:%option never-interactive
        -:   80:%option yylineno
        -:   81:%option prefix="hex_yy"
        -:   82:
        -:   83:%option outfile="lex.yy.c"
        -:   84:
        -:   85:%option verbose
        -:   86:%option warn
        -:   87:
        -:   88:digit         [0-9]
        -:   89:letter        [a-zA-Z]
        -:   90:hexdigit      [a-fA-F0-9]
        -:   91:
        -:   92:%x comment
        -:   93:%x range
        -:   94:
        -:   95:%%
        -:   96:
        -:   97:
        -:   98:<INITIAL>{hexdigit}{2}  {
        -:   99:
        7:  100:  yylval->integer = xtoi(yytext);
        7:  101:  return _BYTE_;
        -:  102:}
        -:  103:
    #####:  104:<INITIAL>{hexdigit}\?  {
        -:  105:
    #####:  106:  yytext[1] = '0'; // replace ? by 0
    #####:  107:  yylval->integer = xtoi(yytext) | 0xF000 ;
    #####:  108:  return _MASKED_BYTE_;
        -:  109:}
        -:  110:
    #####:  111:\?{hexdigit}  {
        -:  112:
    #####:  113:  yytext[0] = '0'; // replace ? by 0
    #####:  114:  yylval->integer = xtoi(yytext) | 0x0F00 ;
    #####:  115:  return _MASKED_BYTE_;
        -:  116:}
        -:  117:
        2:  118:\?\? {
        -:  119:
        2:  120:  yylval->integer = 0x0000;
        2:  121:  return _MASKED_BYTE_;
        -:  122:}
        -:  123:
    #####:  124:\[ {
        -:  125:
    #####:  126:  BEGIN(range);
    #####:  127:  return yytext[0];
        -:  128:}
        -:  129:
    #####:  130:"/*" {
        -:  131:
    #####:  132:  BEGIN(comment);
        -:  133:}
    #####:  134:
    #####:  135:<comment>"*/" {
        -:  136:
    #####:  137:  BEGIN(INITIAL);
        -:  138:}
    #####:  139:
    #####:  140:<comment>.|\n      // skip comments
    #####:  141:
    #####:  142:"//".*             // skip single-line comments
    #####:  143:
    #####:  144:<range>\- {
        -:  145:
    #####:  146:  return yytext[0];
        -:  147:}
        -:  148:
    #####:  149:<range>{digit}+ {
        -:  150:
    #####:  151:  yylval->integer = atoi(yytext);
    #####:  152:  return _NUMBER_;
        -:  153:}
        -:  154:
    #####:  155:<range>\] {
        -:  156:
    #####:  157:  BEGIN(INITIAL);
    #####:  158:  return yytext[0];
        -:  159:}
        -:  160:
    #####:  161:<range>[ \t\r\n]   // skip whitespaces
    #####:  162:
    #####:  163:<range>. {
        -:  164:
    #####:  165:  yyerror(yyscanner, lex_env, "invalid character in hex string jump");
    #####:  166:  yyterminate();
        -:  167:}
        -:  168:
        9:  169:[ \t\r\n]         // skip whitespaces
        9:  170:
        2:  171:[{}()|]  {        // pass valid characters to the parser
        -:  172:
        2:  173:  return yytext[0];
        -:  174:}
        -:  175:
    #####:  176:. {               // reject all other characters
        -:  177:
    #####:  178:  yyerror(yyscanner, lex_env, "invalid character in hex string");
    #####:  179:  yyterminate();
        -:  180:}
        -:  181:
    #####:  182:%%
    #####:  183:
    #####:  184:void yyfatal(
        -:  185:    yyscan_t yyscanner,
        -:  186:    const char *error_message)
        -:  187:{
    #####:  188:  jmp_buf* recovery_state = (jmp_buf*) yr_thread_storage_get_value(
        -:  189:      &yr_recovery_state_key);
        -:  190:
    #####:  191:  longjmp(*recovery_state, 1);
        -:  192:}
        -:  193:
    #####:  194:void yyerror(
        -:  195:    yyscan_t yyscanner,
        -:  196:    HEX_LEX_ENVIRONMENT* lex_env,
        -:  197:    const char *error_message)
        -:  198:{
        -:  199:  // if lex_env->last_error was set to some error code before
        -:  200:  // don't overwrite it, we are interested in the first error, not in
        -:  201:  // subsequent errors like "syntax error, unexpected $end" caused by
        -:  202:  // early parser termination.
        -:  203:
    #####:  204:  if (lex_env->last_error == ERROR_SUCCESS)
        -:  205:  {
    #####:  206:    lex_env->last_error = ERROR_INVALID_HEX_STRING;
        -:  207:
    #####:  208:    strlcpy(
    #####:  209:        lex_env->last_error_message,
        -:  210:        error_message,
        -:  211:        sizeof(lex_env->last_error_message));
        -:  212:  }
    #####:  213:}
        -:  214:
        -:  215:
        1:  216:int yr_parse_hex_string(
        -:  217:    const char* hex_string,
        -:  218:    RE_AST** re_ast,
        -:  219:    RE_ERROR* error)
        -:  220:{
        -:  221:  yyscan_t yyscanner;
        -:  222:  jmp_buf recovery_state;
        -:  223:  HEX_LEX_ENVIRONMENT lex_env;
        -:  224:
        1:  225:  lex_env.last_error = ERROR_SUCCESS;
        1:  226:  lex_env.inside_or = 0;
        -:  227:
        1:  228:  yr_thread_storage_set_value(&yr_recovery_state_key, &recovery_state);
        -:  229:
        1:  230:  if (setjmp(recovery_state) != 0)
    #####:  231:    return ERROR_INTERNAL_FATAL_ERROR;
        -:  232:
        1:  233:  FAIL_ON_ERROR(yr_re_ast_create(re_ast));
        -:  234:
        -:  235:  // The RE_FLAGS_FAST_REGEXP flag indicates a regular expression can be
        -:  236:  // matched by faster algorithm. These regular expressions come from hex
        -:  237:  // strings that do not contain alternatives, like in:
        -:  238:  //
        -:  239:  // { ( 01 02 | 03 04) 05 06 }.
        -:  240:  //
        -:  241:  // This flag is unset later during parsing if alternatives are used.
        -:  242:
        1:  243:  (*re_ast)->flags |= RE_FLAGS_FAST_REGEXP;
        -:  244:
        -:  245:  // Set RE_FLAGS_DOT_ALL because in hex strings the "dot" (?? in this case)
        -:  246:  // must match all characters including new-line.
        -:  247:
        1:  248:  (*re_ast)->flags |= RE_FLAGS_DOT_ALL;
        -:  249:
        1:  250:  yylex_init(&yyscanner);
        1:  251:  yyset_extra(*re_ast, yyscanner);
        1:  252:  yy_scan_string(hex_string, yyscanner);
        1:  253:  yyparse(yyscanner, &lex_env);
        1:  254:  yylex_destroy(yyscanner);
        -:  255:
        1:  256:  if (lex_env.last_error != ERROR_SUCCESS)
        -:  257:  {
    #####:  258:    strlcpy(error->message, lex_env.last_error_message, sizeof(error->message));
    #####:  259:    return lex_env.last_error;
        -:  260:  }
        -:  261:
        1:  262:  return ERROR_SUCCESS;
        -:  263:}
