        -:    0:Source:exec.c
        -:    0:Graph:/home/workspace/libyara/exec.gcno
        -:    0:Data:/home/workspace/libyara/exec.gcda
        -:    0:Runs:7
        -:    0:Programs:7
        -:    1:/*
        -:    2:Copyright (c) 2013-2014. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#define _GNU_SOURCE
        -:   31:
        -:   32:#include <string.h>
        -:   33:#include <assert.h>
        -:   34:#include <math.h>
        -:   35:#include <float.h>
        -:   36:
        -:   37:#include <yara/globals.h>
        -:   38:#include <yara/arena.h>
        -:   39:#include <yara/endian.h>
        -:   40:#include <yara/exec.h>
        -:   41:#include <yara/limits.h>
        -:   42:#include <yara/error.h>
        -:   43:#include <yara/object.h>
        -:   44:#include <yara/modules.h>
        -:   45:#include <yara/re.h>
        -:   46:#include <yara/strutils.h>
        -:   47:#include <yara/utils.h>
        -:   48:#include <yara/mem.h>
        -:   49:#include <yara/stopwatch.h>
        -:   50:
        -:   51:
        -:   52:#include <yara.h>
        -:   53:
        -:   54:
        -:   55:// Turn on paranoid mode by default if not defined otherwise. In paranoid
        -:   56:// mode additional checks are performed in order to mitigate the effects of
        -:   57:// malicious tampering with compiled rules. Such checks are not necessary
        -:   58:// when you can ensure that the compiled rules are executed exactly as they
        -:   59:// were generated by YARA, without any further modification. Check issue #891
        -:   60:// (https://github.com/VirusTotal/yara/issues/891) for more context.
        -:   61://
        -:   62:// Paranoid mode does not guarantee that it's safe to load compiled rules from
        -:   63:// third parties, it only prevents severe security issues. Maliciously crafted
        -:   64:// compiled rules can still crash YARA. Loading third-party compiled rules is
        -:   65:// *highly* undiscouraged. If you need to distribute YARA rules in compiled
        -:   66:// form you should encapsulate them in some digitally-signed package that
        -:   67:// ensure that they haven't been modified by someone else.
        -:   68:
        -:   69:#if !defined(PARANOID_EXEC)
        -:   70:#define PARANOID_EXEC   1
        -:   71:#endif
        -:   72:
        -:   73:
        -:   74:#define MEM_SIZE   YR_MAX_LOOP_NESTING * LOOP_LOCAL_VARS
        -:   75:
        -:   76:
        -:   77:#define push(x)  \
        -:   78:    if (sp < stack_size) \
        -:   79:    { \
        -:   80:      stack[sp++] = (x); \
        -:   81:    } \
        -:   82:    else \
        -:   83:    { \
        -:   84:      result = ERROR_EXEC_STACK_OVERFLOW; \
        -:   85:      stop = true; \
        -:   86:      break; \
        -:   87:    } \
        -:   88:
        -:   89:
        -:   90:#define pop(x) { assert(sp > 0); x = stack[--sp]; }
        -:   91:
        -:   92:#define is_undef(x) IS_UNDEFINED((x).i)
        -:   93:
        -:   94:#define ensure_defined(x) \
        -:   95:    if (is_undef(x)) \
        -:   96:    { \
        -:   97:      r1.i = UNDEFINED; \
        -:   98:      push(r1); \
        -:   99:      break; \
        -:  100:    }
        -:  101:
        -:  102:#define ensure_within_mem(x) \
        -:  103:    if (x < 0 || x >= MEM_SIZE) \
        -:  104:    { \
        -:  105:      stop = true; \
        -:  106:      result = ERROR_INTERNAL_FATAL_ERROR; \
        -:  107:      break; \
        -:  108:    }
        -:  109:
        -:  110:#define check_object_canary(o) \
        -:  111:    if (o->canary != yr_canary) \
        -:  112:    { \
        -:  113:      stop = true; \
        -:  114:      result = ERROR_INTERNAL_FATAL_ERROR; \
        -:  115:      break; \
        -:  116:    }
        -:  117:
        -:  118:#define little_endian_uint8_t(x)     (x)
        -:  119:#define little_endian_int8_t(x)      (x)
        -:  120:#define little_endian_uint16_t(x)    yr_le16toh(x)
        -:  121:#define little_endian_int16_t(x)     yr_le16toh(x)
        -:  122:#define little_endian_uint32_t(x)    yr_le32toh(x)
        -:  123:#define little_endian_int32_t(x)     yr_le32toh(x)
        -:  124:
        -:  125:#define big_endian_uint8_t(x)        (x)
        -:  126:#define big_endian_int8_t(x)         (x)
        -:  127:#define big_endian_uint16_t(x)       yr_be16toh(x)
        -:  128:#define big_endian_int16_t(x)        yr_be16toh(x)
        -:  129:#define big_endian_uint32_t(x)       yr_be32toh(x)
        -:  130:#define big_endian_int32_t(x)        yr_be32toh(x)
        -:  131:
        -:  132:
        -:  133:#define function_read(type, endianess) \
        -:  134:    int64_t read_##type##_##endianess(YR_MEMORY_BLOCK_ITERATOR* iterator, size_t offset) \
        -:  135:    { \
        -:  136:      YR_MEMORY_BLOCK* block = iterator->first(iterator); \
        -:  137:      while (block != NULL) \
        -:  138:      { \
        -:  139:        if (offset >= block->base && \
        -:  140:            block->size >= sizeof(type) && \
        -:  141:            offset <= block->base + block->size - sizeof(type)) \
        -:  142:        { \
        -:  143:          type result; \
        -:  144:          const uint8_t* data = block->fetch_data(block); \
        -:  145:          if (data == NULL) \
        -:  146:            return UNDEFINED; \
        -:  147:          result = *(type *)(data + offset - block->base); \
        -:  148:          result = endianess##_##type(result); \
        -:  149:          return result; \
        -:  150:        } \
        -:  151:        block = iterator->next(iterator); \
        -:  152:      } \
        -:  153:      return UNDEFINED; \
        -:  154:    };
        -:  155:
        -:  156:
    #####:  157:function_read(uint8_t, little_endian)
    #####:  158:function_read(uint16_t, little_endian)
    #####:  159:function_read(uint32_t, little_endian)
    #####:  160:function_read(int8_t, little_endian)
    #####:  161:function_read(int16_t, little_endian)
    #####:  162:function_read(int32_t, little_endian)
    #####:  163:function_read(uint8_t, big_endian)
    #####:  164:function_read(uint16_t, big_endian)
    #####:  165:function_read(uint32_t, big_endian)
    #####:  166:function_read(int8_t, big_endian)
    #####:  167:function_read(int16_t, big_endian)
    #####:  168:function_read(int32_t, big_endian)
        -:  169:
        -:  170:
    #####:  171:static const uint8_t* jmp_if(
        -:  172:    int condition,
        -:  173:    const uint8_t* ip)
        -:  174:{
        -:  175:  const uint8_t* result;
        -:  176:
    #####:  177:  if (condition)
        -:  178:  {
    #####:  179:    result = *(const uint8_t**)(ip);
        -:  180:  }
        -:  181:  else
        -:  182:  {
    #####:  183:    result = ip + sizeof(uint64_t);
        -:  184:  }
        -:  185:
    #####:  186:  return result;
        -:  187:}
        -:  188:
        -:  189:
    #####:  190:int yr_execute_code(
        -:  191:    YR_SCAN_CONTEXT* context)
        -:  192:{
        -:  193:  int64_t mem[MEM_SIZE];
    #####:  194:  int32_t sp = 0;
        -:  195:
    #####:  196:  const uint8_t* ip = context->rules->code_start;
        -:  197:
        -:  198:  YR_VALUE args[YR_MAX_FUNCTION_ARGS];
        -:  199:  YR_VALUE *stack;
        -:  200:  YR_VALUE r1;
        -:  201:  YR_VALUE r2;
        -:  202:  YR_VALUE r3;
        -:  203:
        -:  204:  uint64_t elapsed_time;
        -:  205:
        -:  206:  #ifdef PROFILING_ENABLED
        -:  207:  uint64_t start_time;
        -:  208:  YR_RULE* current_rule = NULL;
        -:  209:  #endif
        -:  210:
        -:  211:  YR_INIT_RULE_ARGS init_rule_args;
        -:  212:
        -:  213:  YR_RULE* rule;
        -:  214:  YR_MATCH* match;
        -:  215:  YR_OBJECT_FUNCTION* function;
        -:  216:  YR_OBJECT** obj_ptr;
        -:  217:  YR_ARENA* obj_arena;
        -:  218:
        -:  219:  char* identifier;
        -:  220:  char* args_fmt;
        -:  221:
        -:  222:  int i;
        -:  223:  int found;
        -:  224:  int count;
    #####:  225:  int result = ERROR_SUCCESS;
    #####:  226:  int cycle = 0;
    #####:  227:  int tidx = context->tidx;
        -:  228:  int stack_size;
        -:  229:
    #####:  230:  bool stop = false;
        -:  231:
        -:  232:  uint8_t opcode;
        -:  233:
    #####:  234:  yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);
        -:  235:
    #####:  236:  stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));
        -:  237:
    #####:  238:  if (stack == NULL)
    #####:  239:    return ERROR_INSUFFICIENT_MEMORY;
        -:  240:
    #####:  241:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  242:      yr_arena_create(1024, 0, &obj_arena),
        -:  243:      yr_free(stack));
        -:  244:
        -:  245:  #ifdef PROFILING_ENABLED
        -:  246:  start_time = yr_stopwatch_elapsed_us(&context->stopwatch);
        -:  247:  #endif
        -:  248:
        -:  249:  #if PARANOID_EXEC
    #####:  250:  memset(mem, 0, MEM_SIZE * sizeof(mem[0]));
        -:  251:  #endif
        -:  252:
    #####:  253:  while(!stop)
        -:  254:  {
    #####:  255:    opcode = *ip;
    #####:  256:    ip++;
        -:  257:
    #####:  258:    switch(opcode)
        -:  259:    {
    #####:  260:      case OP_NOP:
    #####:  261:        break;
        -:  262:
    #####:  263:      case OP_HALT:
    #####:  264:        assert(sp == 0); // When HALT is reached the stack should be empty.
    #####:  265:        stop = true;
    #####:  266:        break;
        -:  267:
    #####:  268:      case OP_PUSH:
    #####:  269:        r1.i = *(uint64_t*)(ip);
    #####:  270:        ip += sizeof(uint64_t);
    #####:  271:        push(r1);
    #####:  272:        break;
        -:  273:
    #####:  274:      case OP_POP:
    #####:  275:        pop(r1);
    #####:  276:        break;
        -:  277:
    #####:  278:      case OP_CLEAR_M:
    #####:  279:        r1.i = *(uint64_t*)(ip);
    #####:  280:        ip += sizeof(uint64_t);
        -:  281:        #if PARANOID_EXEC
    #####:  282:        ensure_within_mem(r1.i);
        -:  283:        #endif
    #####:  284:        mem[r1.i] = 0;
    #####:  285:        break;
        -:  286:
    #####:  287:      case OP_ADD_M:
    #####:  288:        r1.i = *(uint64_t*)(ip);
    #####:  289:        ip += sizeof(uint64_t);
        -:  290:        #if PARANOID_EXEC
    #####:  291:        ensure_within_mem(r1.i);
        -:  292:        #endif
    #####:  293:        pop(r2);
    #####:  294:        if (!is_undef(r2))
    #####:  295:          mem[r1.i] += r2.i;
    #####:  296:        break;
        -:  297:
    #####:  298:      case OP_INCR_M:
    #####:  299:        r1.i = *(uint64_t*)(ip);
    #####:  300:        ip += sizeof(uint64_t);
        -:  301:        #if PARANOID_EXEC
    #####:  302:        ensure_within_mem(r1.i);
        -:  303:        #endif
    #####:  304:        mem[r1.i]++;
    #####:  305:        break;
        -:  306:
    #####:  307:      case OP_PUSH_M:
    #####:  308:        r1.i = *(uint64_t*)(ip);
    #####:  309:        ip += sizeof(uint64_t);
        -:  310:        #if PARANOID_EXEC
    #####:  311:        ensure_within_mem(r1.i);
        -:  312:        #endif
    #####:  313:        r1.i = mem[r1.i];
    #####:  314:        push(r1);
    #####:  315:        break;
        -:  316:
    #####:  317:      case OP_POP_M:
    #####:  318:        r1.i = *(uint64_t*)(ip);
    #####:  319:        ip += sizeof(uint64_t);
        -:  320:        #if PARANOID_EXEC
    #####:  321:        ensure_within_mem(r1.i);
        -:  322:        #endif
    #####:  323:        pop(r2);
    #####:  324:        mem[r1.i] = r2.i;
    #####:  325:        break;
        -:  326:
    #####:  327:      case OP_SET_M:
    #####:  328:        r1.i = *(uint64_t*)(ip);
    #####:  329:        ip += sizeof(uint64_t);
        -:  330:        #if PARANOID_EXEC
    #####:  331:        ensure_within_mem(r1.i);
        -:  332:        #endif
    #####:  333:        pop(r2);
    #####:  334:        push(r2);
    #####:  335:        if (!is_undef(r2))
    #####:  336:          mem[r1.i] = r2.i;
    #####:  337:        break;
        -:  338:
    #####:  339:      case OP_SWAPUNDEF:
    #####:  340:        r1.i = *(uint64_t*)(ip);
    #####:  341:        ip += sizeof(uint64_t);
        -:  342:        #if PARANOID_EXEC
    #####:  343:        ensure_within_mem(r1.i);
        -:  344:        #endif
    #####:  345:        pop(r2);
        -:  346:
    #####:  347:        if (is_undef(r2))
        -:  348:        {
    #####:  349:          r1.i = mem[r1.i];
    #####:  350:          push(r1);
        -:  351:        }
        -:  352:        else
        -:  353:        {
    #####:  354:          push(r2);
        -:  355:        }
    #####:  356:        break;
        -:  357:
    #####:  358:      case OP_JNUNDEF:
    #####:  359:        pop(r1);
    #####:  360:        push(r1);
    #####:  361:        ip = jmp_if(!is_undef(r1), ip);
    #####:  362:        break;
        -:  363:
    #####:  364:      case OP_JLE_P:
    #####:  365:        pop(r2);
    #####:  366:        pop(r1);
    #####:  367:        ip = jmp_if(r1.i <= r2.i, ip);
    #####:  368:        break;
        -:  369:
    #####:  370:      case OP_JTRUE:
    #####:  371:        pop(r1);
    #####:  372:        push(r1);
    #####:  373:        ip = jmp_if(!is_undef(r1) && r1.i, ip);
    #####:  374:        break;
        -:  375:
    #####:  376:      case OP_JFALSE:
    #####:  377:        pop(r1);
    #####:  378:        push(r1);
    #####:  379:        ip = jmp_if(is_undef(r1) || !r1.i, ip);
    #####:  380:        break;
        -:  381:
    #####:  382:      case OP_JFALSE_P:
    #####:  383:        pop(r1);
    #####:  384:        ip = jmp_if(is_undef(r1) || !r1.i, ip);
    #####:  385:        break;
        -:  386:
    #####:  387:      case OP_AND:
    #####:  388:        pop(r2);
    #####:  389:        pop(r1);
        -:  390:
    #####:  391:        if (is_undef(r1) || is_undef(r2))
    #####:  392:          r1.i = 0;
        -:  393:        else
    #####:  394:          r1.i = r1.i && r2.i;
        -:  395:
    #####:  396:        push(r1);
    #####:  397:        break;
        -:  398:
    #####:  399:      case OP_OR:
    #####:  400:        pop(r2);
    #####:  401:        pop(r1);
        -:  402:
    #####:  403:        if (is_undef(r1))
        -:  404:        {
    #####:  405:          push(r2);
        -:  406:        }
    #####:  407:        else if (is_undef(r2))
        -:  408:        {
    #####:  409:          push(r1);
        -:  410:        }
        -:  411:        else
        -:  412:        {
    #####:  413:          r1.i = r1.i || r2.i;
    #####:  414:          push(r1);
        -:  415:        }
    #####:  416:        break;
        -:  417:
    #####:  418:      case OP_NOT:
    #####:  419:        pop(r1);
        -:  420:
    #####:  421:        if (is_undef(r1))
    #####:  422:          r1.i = UNDEFINED;
        -:  423:        else
    #####:  424:          r1.i = !r1.i;
        -:  425:
    #####:  426:        push(r1);
    #####:  427:        break;
        -:  428:
    #####:  429:      case OP_MOD:
    #####:  430:        pop(r2);
    #####:  431:        pop(r1);
    #####:  432:        ensure_defined(r2);
    #####:  433:        ensure_defined(r1);
    #####:  434:        if (r2.i != 0)
    #####:  435:          r1.i = r1.i % r2.i;
        -:  436:        else
    #####:  437:          r1.i = UNDEFINED;
    #####:  438:        push(r1);
    #####:  439:        break;
        -:  440:
    #####:  441:      case OP_SHR:
    #####:  442:        pop(r2);
    #####:  443:        pop(r1);
    #####:  444:        ensure_defined(r2);
    #####:  445:        ensure_defined(r1);
    #####:  446:        if (r2.i < 0)
    #####:  447:          r1.i = UNDEFINED;
    #####:  448:        else if (r2.i < 64)
    #####:  449:          r1.i = r1.i >> r2.i;
        -:  450:        else
    #####:  451:          r1.i = 0;
    #####:  452:        push(r1);
    #####:  453:        break;
        -:  454:
    #####:  455:      case OP_SHL:
    #####:  456:        pop(r2);
    #####:  457:        pop(r1);
    #####:  458:        ensure_defined(r2);
    #####:  459:        ensure_defined(r1);
    #####:  460:        if (r2.i < 0)
    #####:  461:          r1.i = UNDEFINED;
    #####:  462:        else if (r2.i < 64)
    #####:  463:          r1.i = r1.i << r2.i;
        -:  464:        else
    #####:  465:          r1.i = 0;
    #####:  466:        push(r1);
    #####:  467:        break;
        -:  468:
    #####:  469:      case OP_BITWISE_NOT:
    #####:  470:        pop(r1);
    #####:  471:        ensure_defined(r1);
    #####:  472:        r1.i = ~r1.i;
    #####:  473:        push(r1);
    #####:  474:        break;
        -:  475:
    #####:  476:      case OP_BITWISE_AND:
    #####:  477:        pop(r2);
    #####:  478:        pop(r1);
    #####:  479:        ensure_defined(r2);
    #####:  480:        ensure_defined(r1);
    #####:  481:        r1.i = r1.i & r2.i;
    #####:  482:        push(r1);
    #####:  483:        break;
        -:  484:
    #####:  485:      case OP_BITWISE_OR:
    #####:  486:        pop(r2);
    #####:  487:        pop(r1);
    #####:  488:        ensure_defined(r2);
    #####:  489:        ensure_defined(r1);
    #####:  490:        r1.i = r1.i | r2.i;
    #####:  491:        push(r1);
    #####:  492:        break;
        -:  493:
    #####:  494:      case OP_BITWISE_XOR:
    #####:  495:        pop(r2);
    #####:  496:        pop(r1);
    #####:  497:        ensure_defined(r2);
    #####:  498:        ensure_defined(r1);
    #####:  499:        r1.i = r1.i ^ r2.i;
    #####:  500:        push(r1);
    #####:  501:        break;
        -:  502:
    #####:  503:      case OP_PUSH_RULE:
    #####:  504:        rule = *(YR_RULE**)(ip);
    #####:  505:        ip += sizeof(uint64_t);
    #####:  506:        if (RULE_IS_DISABLED(rule))
    #####:  507:          r1.i = UNDEFINED;
        -:  508:        else
    #####:  509:          r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;
    #####:  510:        push(r1);
    #####:  511:        break;
        -:  512:
    #####:  513:      case OP_INIT_RULE:
    #####:  514:        memcpy(&init_rule_args, ip, sizeof(init_rule_args));
        -:  515:        #ifdef PROFILING_ENABLED
        -:  516:        current_rule = init_rule_args.rule;
        -:  517:        #endif
    #####:  518:        if (RULE_IS_DISABLED(init_rule_args.rule))
    #####:  519:          ip = init_rule_args.jmp_addr;
        -:  520:        else
    #####:  521:          ip += sizeof(init_rule_args);
    #####:  522:        break;
        -:  523:
    #####:  524:      case OP_MATCH_RULE:
    #####:  525:        pop(r1);
    #####:  526:        rule = *(YR_RULE**)(ip);
    #####:  527:        ip += sizeof(uint64_t);
        -:  528:
    #####:  529:        if (!is_undef(r1) && r1.i)
    #####:  530:          rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;
    #####:  531:        else if (RULE_IS_GLOBAL(rule))
    #####:  532:          rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;
        -:  533:
        -:  534:        #ifdef PROFILING_ENABLED
        -:  535:        elapsed_time = yr_stopwatch_elapsed_us(&context->stopwatch);
        -:  536:        rule->time_cost_per_thread[tidx] += (elapsed_time - start_time);
        -:  537:        start_time = elapsed_time;
        -:  538:        #endif
        -:  539:
    #####:  540:        assert(sp == 0); // at this point the stack should be empty.
    #####:  541:        break;
        -:  542:
    #####:  543:      case OP_OBJ_LOAD:
    #####:  544:        identifier = *(char**)(ip);
    #####:  545:        ip += sizeof(uint64_t);
        -:  546:
    #####:  547:        r1.o = (YR_OBJECT*) yr_hash_table_lookup(
        -:  548:            context->objects_table,
        -:  549:            identifier,
        -:  550:            NULL);
        -:  551:
    #####:  552:        assert(r1.o != NULL);
    #####:  553:        push(r1);
    #####:  554:        break;
        -:  555:
    #####:  556:      case OP_OBJ_FIELD:
    #####:  557:        identifier = *(char**)(ip);
    #####:  558:        ip += sizeof(uint64_t);
        -:  559:
    #####:  560:        pop(r1);
    #####:  561:        ensure_defined(r1);
        -:  562:
    #####:  563:        r1.o = yr_object_lookup_field(r1.o, identifier);
        -:  564:
    #####:  565:        assert(r1.o != NULL);
    #####:  566:        push(r1);
    #####:  567:        break;
        -:  568:
    #####:  569:      case OP_OBJ_VALUE:
    #####:  570:        pop(r1);
    #####:  571:        ensure_defined(r1);
        -:  572:
        -:  573:        #if PARANOID_EXEC
    #####:  574:        check_object_canary(r1.o);
        -:  575:        #endif
        -:  576:
    #####:  577:        switch(r1.o->type)
        -:  578:        {
    #####:  579:          case OBJECT_TYPE_INTEGER:
    #####:  580:            r1.i = r1.o->value.i;
    #####:  581:            break;
        -:  582:
    #####:  583:          case OBJECT_TYPE_FLOAT:
    #####:  584:            if (isnan(r1.o->value.d))
    #####:  585:              r1.i = UNDEFINED;
        -:  586:            else
    #####:  587:              r1.d = r1.o->value.d;
    #####:  588:            break;
        -:  589:
    #####:  590:          case OBJECT_TYPE_STRING:
    #####:  591:            if (r1.o->value.ss == NULL)
    #####:  592:              r1.i = UNDEFINED;
        -:  593:            else
    #####:  594:              r1.ss = r1.o->value.ss;
    #####:  595:            break;
        -:  596:
    #####:  597:          default:
    #####:  598:            assert(false);
        -:  599:        }
        -:  600:
    #####:  601:        push(r1);
    #####:  602:        break;
        -:  603:
    #####:  604:      case OP_INDEX_ARRAY:
    #####:  605:        pop(r1);  // index
    #####:  606:        pop(r2);  // array
        -:  607:
    #####:  608:        ensure_defined(r1);
    #####:  609:        ensure_defined(r2);
        -:  610:
    #####:  611:        assert(r2.o->type == OBJECT_TYPE_ARRAY);
        -:  612:
        -:  613:        #if PARANOID_EXEC
    #####:  614:        check_object_canary(r2.o);
        -:  615:        #endif
        -:  616:
    #####:  617:        r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);
        -:  618:
    #####:  619:        if (r1.o == NULL)
    #####:  620:          r1.i = UNDEFINED;
        -:  621:
    #####:  622:        push(r1);
    #####:  623:        break;
        -:  624:
    #####:  625:      case OP_LOOKUP_DICT:
    #####:  626:        pop(r1);  // key
    #####:  627:        pop(r2);  // dictionary
        -:  628:
    #####:  629:        ensure_defined(r1);
    #####:  630:        ensure_defined(r2);
        -:  631:
    #####:  632:        assert(r2.o->type == OBJECT_TYPE_DICTIONARY);
        -:  633:
        -:  634:        #if PARANOID_EXEC
    #####:  635:        check_object_canary(r2.o);
        -:  636:        #endif
        -:  637:
    #####:  638:        r1.o = yr_object_dict_get_item(
    #####:  639:            r2.o, 0, r1.ss->c_string);
        -:  640:
    #####:  641:        if (r1.o == NULL)
    #####:  642:          r1.i = UNDEFINED;
        -:  643:
    #####:  644:        push(r1);
    #####:  645:        break;
        -:  646:
    #####:  647:      case OP_CALL:
    #####:  648:        args_fmt = *(char**)(ip);
    #####:  649:        ip += sizeof(uint64_t);
        -:  650:
    #####:  651:        i = (int) strlen(args_fmt);
    #####:  652:        count = 0;
        -:  653:
        -:  654:        #if PARANOID_EXEC
    #####:  655:        if (i > YR_MAX_FUNCTION_ARGS)
        -:  656:        {
    #####:  657:          stop = true;
    #####:  658:          result = ERROR_INTERNAL_FATAL_ERROR;
    #####:  659:          break;
        -:  660:        }
        -:  661:        #endif
        -:  662:
        -:  663:        // pop arguments from stack and copy them to args array
        -:  664:
    #####:  665:        while (i > 0)
        -:  666:        {
    #####:  667:          pop(r1);
        -:  668:
    #####:  669:          if (is_undef(r1))  // count the number of undefined args
    #####:  670:            count++;
        -:  671:
    #####:  672:          args[i - 1] = r1;
    #####:  673:          i--;
        -:  674:        }
        -:  675:
    #####:  676:        pop(r2);
    #####:  677:        ensure_defined(r2);
        -:  678:
        -:  679:        #if PARANOID_EXEC
    #####:  680:        check_object_canary(r2.o);
        -:  681:        #endif
        -:  682:
    #####:  683:        if (count > 0)
        -:  684:        {
        -:  685:          // if there are undefined args, result for function call
        -:  686:          // is undefined as well.
        -:  687:
    #####:  688:          r1.i = UNDEFINED;
    #####:  689:          push(r1);
    #####:  690:          break;
        -:  691:        }
        -:  692:
    #####:  693:        function = object_as_function(r2.o);
    #####:  694:        result = ERROR_INTERNAL_FATAL_ERROR;
        -:  695:
    #####:  696:        for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
        -:  697:        {
    #####:  698:          if (function->prototypes[i].arguments_fmt == NULL)
    #####:  699:            break;
        -:  700:
    #####:  701:          if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)
        -:  702:          {
    #####:  703:            result = function->prototypes[i].code(args, context, function);
    #####:  704:            break;
        -:  705:          }
        -:  706:        }
        -:  707:
        -:  708:        // if i == YR_MAX_OVERLOADED_FUNCTIONS at this point no matching
        -:  709:        // prototype was found, but this shouldn't happen.
        -:  710:
    #####:  711:        assert(i < YR_MAX_OVERLOADED_FUNCTIONS);
        -:  712:
        -:  713:        // make a copy of the returned object and push the copy into the stack
        -:  714:        // function->return_obj can't be pushed because it can change in
        -:  715:        // subsequent calls to the same function.
        -:  716:
    #####:  717:        if (result == ERROR_SUCCESS)
    #####:  718:          result = yr_object_copy(function->return_obj, &r1.o);
        -:  719:
        -:  720:        // a pointer to the copied object is stored in a arena in order to
        -:  721:        // free the object before exiting yr_execute_code
        -:  722:
    #####:  723:        if (result == ERROR_SUCCESS)
    #####:  724:          result = yr_arena_write_data(obj_arena, &r1.o, sizeof(r1.o), NULL);
        -:  725:
    #####:  726:        stop = (result != ERROR_SUCCESS);
    #####:  727:        push(r1);
    #####:  728:        break;
        -:  729:
    #####:  730:      case OP_FOUND:
    #####:  731:        pop(r1);
    #####:  732:        r1.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;
    #####:  733:        push(r1);
    #####:  734:        break;
        -:  735:
    #####:  736:      case OP_FOUND_AT:
    #####:  737:        pop(r2);
    #####:  738:        pop(r1);
        -:  739:
    #####:  740:        if (is_undef(r1))
        -:  741:        {
    #####:  742:          r1.i = 0;
    #####:  743:          push(r1);
    #####:  744:          break;
        -:  745:        }
        -:  746:
    #####:  747:        match = r2.s->matches[tidx].head;
    #####:  748:        r3.i = false;
        -:  749:
    #####:  750:        while (match != NULL)
        -:  751:        {
    #####:  752:          if (r1.i == match->base + match->offset)
        -:  753:          {
    #####:  754:            r3.i = true;
    #####:  755:            break;
        -:  756:          }
        -:  757:
    #####:  758:          if (r1.i < match->base + match->offset)
    #####:  759:            break;
        -:  760:
    #####:  761:          match = match->next;
        -:  762:        }
        -:  763:
    #####:  764:        push(r3);
    #####:  765:        break;
        -:  766:
    #####:  767:      case OP_FOUND_IN:
    #####:  768:        pop(r3);
    #####:  769:        pop(r2);
    #####:  770:        pop(r1);
        -:  771:
    #####:  772:        ensure_defined(r1);
    #####:  773:        ensure_defined(r2);
        -:  774:
    #####:  775:        match = r3.s->matches[tidx].head;
    #####:  776:        r3.i = false;
        -:  777:
    #####:  778:        while (match != NULL && !r3.i)
        -:  779:        {
    #####:  780:          if (match->base + match->offset >= r1.i &&
    #####:  781:              match->base + match->offset <= r2.i)
        -:  782:          {
    #####:  783:            r3.i = true;
        -:  784:          }
        -:  785:
    #####:  786:          if (match->base + match->offset > r2.i)
    #####:  787:            break;
        -:  788:
    #####:  789:          match = match->next;
        -:  790:        }
        -:  791:
    #####:  792:        push(r3);
    #####:  793:        break;
        -:  794:
    #####:  795:      case OP_COUNT:
    #####:  796:        pop(r1);
        -:  797:
        -:  798:        #if PARANOID_EXEC
        -:  799:        // Make sure that the string pointer is within the rules arena.
    #####:  800:        if (yr_arena_page_for_address(context->rules->arena, r1.p) == NULL)
    #####:  801:          return ERROR_INTERNAL_FATAL_ERROR;
        -:  802:        #endif
        -:  803:
    #####:  804:        r1.i = r1.s->matches[tidx].count;
    #####:  805:        push(r1);
    #####:  806:        break;
        -:  807:
    #####:  808:      case OP_OFFSET:
    #####:  809:        pop(r2);
    #####:  810:        pop(r1);
        -:  811:
    #####:  812:        ensure_defined(r1);
        -:  813:
    #####:  814:        match = r2.s->matches[tidx].head;
    #####:  815:        i = 1;
    #####:  816:        r3.i = UNDEFINED;
        -:  817:
    #####:  818:        while (match != NULL && r3.i == UNDEFINED)
        -:  819:        {
    #####:  820:          if (r1.i == i)
    #####:  821:            r3.i = match->base + match->offset;
        -:  822:
    #####:  823:          i++;
    #####:  824:          match = match->next;
        -:  825:        }
        -:  826:
    #####:  827:        push(r3);
    #####:  828:        break;
        -:  829:
    #####:  830:      case OP_LENGTH:
    #####:  831:        pop(r2);
    #####:  832:        pop(r1);
        -:  833:
    #####:  834:        ensure_defined(r1);
        -:  835:
    #####:  836:        match = r2.s->matches[tidx].head;
    #####:  837:        i = 1;
    #####:  838:        r3.i = UNDEFINED;
        -:  839:
    #####:  840:        while (match != NULL && r3.i == UNDEFINED)
        -:  841:        {
    #####:  842:          if (r1.i == i)
    #####:  843:            r3.i = match->match_length;
        -:  844:
    #####:  845:          i++;
    #####:  846:          match = match->next;
        -:  847:        }
        -:  848:
    #####:  849:        push(r3);
    #####:  850:        break;
        -:  851:
    #####:  852:      case OP_OF:
    #####:  853:        found = 0;
    #####:  854:        count = 0;
    #####:  855:        pop(r1);
        -:  856:
    #####:  857:        while (!is_undef(r1))
        -:  858:        {
    #####:  859:          if (r1.s->matches[tidx].tail != NULL)
    #####:  860:            found++;
    #####:  861:          count++;
    #####:  862:          pop(r1);
        -:  863:        }
        -:  864:
    #####:  865:        pop(r2);
        -:  866:
    #####:  867:        if (is_undef(r2))
    #####:  868:          r1.i = found >= count ? 1 : 0;
        -:  869:        else
    #####:  870:          r1.i = found >= r2.i ? 1 : 0;
        -:  871:
    #####:  872:        push(r1);
    #####:  873:        break;
        -:  874:
    #####:  875:      case OP_FILESIZE:
    #####:  876:        r1.i = context->file_size;
    #####:  877:        push(r1);
    #####:  878:        break;
        -:  879:
    #####:  880:      case OP_ENTRYPOINT:
    #####:  881:        r1.i = context->entry_point;
    #####:  882:        push(r1);
    #####:  883:        break;
        -:  884:
    #####:  885:      case OP_INT8:
    #####:  886:        pop(r1);
    #####:  887:        r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  888:        push(r1);
    #####:  889:        break;
        -:  890:
    #####:  891:      case OP_INT16:
    #####:  892:        pop(r1);
    #####:  893:        r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  894:        push(r1);
    #####:  895:        break;
        -:  896:
    #####:  897:      case OP_INT32:
    #####:  898:        pop(r1);
    #####:  899:        r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  900:        push(r1);
    #####:  901:        break;
        -:  902:
    #####:  903:      case OP_UINT8:
    #####:  904:        pop(r1);
    #####:  905:        r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  906:        push(r1);
    #####:  907:        break;
        -:  908:
    #####:  909:      case OP_UINT16:
    #####:  910:        pop(r1);
    #####:  911:        r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  912:        push(r1);
    #####:  913:        break;
        -:  914:
    #####:  915:      case OP_UINT32:
    #####:  916:        pop(r1);
    #####:  917:        r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  918:        push(r1);
    #####:  919:        break;
        -:  920:
    #####:  921:      case OP_INT8BE:
    #####:  922:        pop(r1);
    #####:  923:        r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  924:        push(r1);
    #####:  925:        break;
        -:  926:
    #####:  927:      case OP_INT16BE:
    #####:  928:        pop(r1);
    #####:  929:        r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  930:        push(r1);
    #####:  931:        break;
        -:  932:
    #####:  933:      case OP_INT32BE:
    #####:  934:        pop(r1);
    #####:  935:        r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  936:        push(r1);
    #####:  937:        break;
        -:  938:
    #####:  939:      case OP_UINT8BE:
    #####:  940:        pop(r1);
    #####:  941:        r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  942:        push(r1);
    #####:  943:        break;
        -:  944:
    #####:  945:      case OP_UINT16BE:
    #####:  946:        pop(r1);
    #####:  947:        r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  948:        push(r1);
    #####:  949:        break;
        -:  950:
    #####:  951:      case OP_UINT32BE:
    #####:  952:        pop(r1);
    #####:  953:        r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  954:        push(r1);
    #####:  955:        break;
        -:  956:
    #####:  957:      case OP_CONTAINS:
    #####:  958:        pop(r2);
    #####:  959:        pop(r1);
        -:  960:
    #####:  961:        ensure_defined(r1);
    #####:  962:        ensure_defined(r2);
        -:  963:
    #####:  964:        r1.i = memmem(r1.ss->c_string, r1.ss->length,
    #####:  965:                      r2.ss->c_string, r2.ss->length) != NULL;
    #####:  966:        push(r1);
    #####:  967:        break;
        -:  968:
    #####:  969:      case OP_IMPORT:
    #####:  970:        r1.i = *(uint64_t*)(ip);
    #####:  971:        ip += sizeof(uint64_t);
        -:  972:
    #####:  973:        result = yr_modules_load((char*) r1.p, context);
        -:  974:
    #####:  975:        if (result != ERROR_SUCCESS)
    #####:  976:          stop = true;
        -:  977:
    #####:  978:        break;
        -:  979:
    #####:  980:      case OP_MATCHES:
        -:  981:
    #####:  982:        pop(r2);
    #####:  983:        pop(r1);
        -:  984:
    #####:  985:        ensure_defined(r2);
    #####:  986:        ensure_defined(r1);
        -:  987:
    #####:  988:        if (r1.ss->length == 0)
        -:  989:        {
    #####:  990:          r1.i = false;
    #####:  991:          push(r1);
    #####:  992:          break;
        -:  993:        }
        -:  994:
    #####:  995:        result = yr_re_exec(
        -:  996:          context,
    #####:  997:          (uint8_t*) r2.re->code,
    #####:  998:          (uint8_t*) r1.ss->c_string,
    #####:  999:          r1.ss->length,
        -: 1000:          0,
    #####: 1001:          r2.re->flags | RE_FLAGS_SCAN,
        -: 1002:          NULL,
        -: 1003:          NULL,
        -: 1004:          &found);
        -: 1005:
    #####: 1006:        if (result != ERROR_SUCCESS)
    #####: 1007:          stop = true;
        -: 1008:
    #####: 1009:        r1.i = found >= 0;
    #####: 1010:        push(r1);
    #####: 1011:        break;
        -: 1012:
    #####: 1013:      case OP_INT_TO_DBL:
        -: 1014:
    #####: 1015:        r1.i = *(uint64_t*)(ip);
    #####: 1016:        ip += sizeof(uint64_t);
        -: 1017:
        -: 1018:        #if PARANOID_EXEC
    #####: 1019:        if (r1.i > sp || sp - r1.i >= stack_size)
        -: 1020:        {
    #####: 1021:          stop = true;
    #####: 1022:          result = ERROR_INTERNAL_FATAL_ERROR;
    #####: 1023:          break;
        -: 1024:        }
        -: 1025:        #endif
        -: 1026:
    #####: 1027:        r2 = stack[sp - r1.i];
        -: 1028:
    #####: 1029:        if (is_undef(r2))
    #####: 1030:          stack[sp - r1.i].i = UNDEFINED;
        -: 1031:        else
    #####: 1032:          stack[sp - r1.i].d = (double) r2.i;
    #####: 1033:        break;
        -: 1034:
    #####: 1035:      case OP_STR_TO_BOOL:
    #####: 1036:        pop(r1);
    #####: 1037:        ensure_defined(r1);
    #####: 1038:        r1.i = r1.ss->length > 0;
    #####: 1039:        push(r1);
    #####: 1040:        break;
        -: 1041:
    #####: 1042:      case OP_INT_EQ:
    #####: 1043:        pop(r2);
    #####: 1044:        pop(r1);
    #####: 1045:        ensure_defined(r2);
    #####: 1046:        ensure_defined(r1);
    #####: 1047:        r1.i = r1.i == r2.i;
    #####: 1048:        push(r1);
    #####: 1049:        break;
        -: 1050:
    #####: 1051:      case OP_INT_NEQ:
    #####: 1052:        pop(r2);
    #####: 1053:        pop(r1);
    #####: 1054:        ensure_defined(r2);
    #####: 1055:        ensure_defined(r1);
    #####: 1056:        r1.i = r1.i != r2.i;
    #####: 1057:        push(r1);
    #####: 1058:        break;
        -: 1059:
    #####: 1060:      case OP_INT_LT:
    #####: 1061:        pop(r2);
    #####: 1062:        pop(r1);
    #####: 1063:        ensure_defined(r2);
    #####: 1064:        ensure_defined(r1);
    #####: 1065:        r1.i = r1.i < r2.i;
    #####: 1066:        push(r1);
    #####: 1067:        break;
        -: 1068:
    #####: 1069:      case OP_INT_GT:
    #####: 1070:        pop(r2);
    #####: 1071:        pop(r1);
    #####: 1072:        ensure_defined(r2);
    #####: 1073:        ensure_defined(r1);
    #####: 1074:        r1.i = r1.i > r2.i;
    #####: 1075:        push(r1);
    #####: 1076:        break;
        -: 1077:
    #####: 1078:      case OP_INT_LE:
    #####: 1079:        pop(r2);
    #####: 1080:        pop(r1);
    #####: 1081:        ensure_defined(r2);
    #####: 1082:        ensure_defined(r1);
    #####: 1083:        r1.i = r1.i <= r2.i;
    #####: 1084:        push(r1);
    #####: 1085:        break;
        -: 1086:
    #####: 1087:      case OP_INT_GE:
    #####: 1088:        pop(r2);
    #####: 1089:        pop(r1);
    #####: 1090:        ensure_defined(r2);
    #####: 1091:        ensure_defined(r1);
    #####: 1092:        r1.i = r1.i >= r2.i;
    #####: 1093:        push(r1);
    #####: 1094:        break;
        -: 1095:
    #####: 1096:      case OP_INT_ADD:
    #####: 1097:        pop(r2);
    #####: 1098:        pop(r1);
    #####: 1099:        ensure_defined(r2);
    #####: 1100:        ensure_defined(r1);
    #####: 1101:        r1.i = r1.i + r2.i;
    #####: 1102:        push(r1);
    #####: 1103:        break;
        -: 1104:
    #####: 1105:      case OP_INT_SUB:
    #####: 1106:        pop(r2);
    #####: 1107:        pop(r1);
    #####: 1108:        ensure_defined(r2);
    #####: 1109:        ensure_defined(r1);
    #####: 1110:        r1.i = r1.i - r2.i;
    #####: 1111:        push(r1);
    #####: 1112:        break;
        -: 1113:
    #####: 1114:      case OP_INT_MUL:
    #####: 1115:        pop(r2);
    #####: 1116:        pop(r1);
    #####: 1117:        ensure_defined(r2);
    #####: 1118:        ensure_defined(r1);
    #####: 1119:        r1.i = r1.i * r2.i;
    #####: 1120:        push(r1);
    #####: 1121:        break;
        -: 1122:
    #####: 1123:      case OP_INT_DIV:
    #####: 1124:        pop(r2);
    #####: 1125:        pop(r1);
    #####: 1126:        ensure_defined(r2);
    #####: 1127:        ensure_defined(r1);
    #####: 1128:        if (r2.i != 0)
    #####: 1129:          r1.i = r1.i / r2.i;
        -: 1130:        else
    #####: 1131:          r1.i = UNDEFINED;
    #####: 1132:        push(r1);
    #####: 1133:        break;
        -: 1134:
    #####: 1135:      case OP_INT_MINUS:
    #####: 1136:        pop(r1);
    #####: 1137:        ensure_defined(r1);
    #####: 1138:        r1.i = -r1.i;
    #####: 1139:        push(r1);
    #####: 1140:        break;
        -: 1141:
    #####: 1142:      case OP_DBL_LT:
    #####: 1143:        pop(r2);
    #####: 1144:        pop(r1);
    #####: 1145:        ensure_defined(r2);
    #####: 1146:        ensure_defined(r1);
    #####: 1147:        r1.i = r1.d < r2.d;
    #####: 1148:        push(r1);
    #####: 1149:        break;
        -: 1150:
    #####: 1151:      case OP_DBL_GT:
    #####: 1152:        pop(r2);
    #####: 1153:        pop(r1);
    #####: 1154:        ensure_defined(r2);
    #####: 1155:        ensure_defined(r1);
    #####: 1156:        r1.i = r1.d > r2.d;
    #####: 1157:        push(r1);
    #####: 1158:        break;
        -: 1159:
    #####: 1160:      case OP_DBL_LE:
    #####: 1161:        pop(r2);
    #####: 1162:        pop(r1);
    #####: 1163:        ensure_defined(r2);
    #####: 1164:        ensure_defined(r1);
    #####: 1165:        r1.i = r1.d <= r2.d;
    #####: 1166:        push(r1);
    #####: 1167:        break;
        -: 1168:
    #####: 1169:      case OP_DBL_GE:
    #####: 1170:        pop(r2);
    #####: 1171:        pop(r1);
    #####: 1172:        ensure_defined(r2);
    #####: 1173:        ensure_defined(r1);
    #####: 1174:        r1.i = r1.d >= r2.d;
    #####: 1175:        push(r1);
    #####: 1176:        break;
        -: 1177:
    #####: 1178:      case OP_DBL_EQ:
    #####: 1179:        pop(r2);
    #####: 1180:        pop(r1);
    #####: 1181:        ensure_defined(r2);
    #####: 1182:        ensure_defined(r1);
    #####: 1183:        r1.i = fabs(r1.d - r2.d) < DBL_EPSILON;
    #####: 1184:        push(r1);
    #####: 1185:        break;
        -: 1186:
    #####: 1187:      case OP_DBL_NEQ:
    #####: 1188:        pop(r2);
    #####: 1189:        pop(r1);
    #####: 1190:        ensure_defined(r2);
    #####: 1191:        ensure_defined(r1);
    #####: 1192:        r1.i = fabs(r1.d - r2.d) >= DBL_EPSILON;
    #####: 1193:        push(r1);
    #####: 1194:        break;
        -: 1195:
    #####: 1196:      case OP_DBL_ADD:
    #####: 1197:        pop(r2);
    #####: 1198:        pop(r1);
    #####: 1199:        ensure_defined(r2);
    #####: 1200:        ensure_defined(r1);
    #####: 1201:        r1.d = r1.d + r2.d;
    #####: 1202:        push(r1);
    #####: 1203:        break;
        -: 1204:
    #####: 1205:      case OP_DBL_SUB:
    #####: 1206:        pop(r2);
    #####: 1207:        pop(r1);
    #####: 1208:        ensure_defined(r2);
    #####: 1209:        ensure_defined(r1);
    #####: 1210:        r1.d = r1.d - r2.d;
    #####: 1211:        push(r1);
    #####: 1212:        break;
        -: 1213:
    #####: 1214:      case OP_DBL_MUL:
    #####: 1215:        pop(r2);
    #####: 1216:        pop(r1);
    #####: 1217:        ensure_defined(r2);
    #####: 1218:        ensure_defined(r1);
    #####: 1219:        r1.d = r1.d * r2.d;
    #####: 1220:        push(r1);
    #####: 1221:        break;
        -: 1222:
    #####: 1223:      case OP_DBL_DIV:
    #####: 1224:        pop(r2);
    #####: 1225:        pop(r1);
    #####: 1226:        ensure_defined(r2);
    #####: 1227:        ensure_defined(r1);
    #####: 1228:        r1.d = r1.d / r2.d;
    #####: 1229:        push(r1);
    #####: 1230:        break;
        -: 1231:
    #####: 1232:      case OP_DBL_MINUS:
    #####: 1233:        pop(r1);
    #####: 1234:        ensure_defined(r1);
    #####: 1235:        r1.d = -r1.d;
    #####: 1236:        push(r1);
    #####: 1237:        break;
        -: 1238:
    #####: 1239:      case OP_STR_EQ:
        -: 1240:      case OP_STR_NEQ:
        -: 1241:      case OP_STR_LT:
        -: 1242:      case OP_STR_LE:
        -: 1243:      case OP_STR_GT:
        -: 1244:      case OP_STR_GE:
        -: 1245:
    #####: 1246:        pop(r2);
    #####: 1247:        pop(r1);
        -: 1248:
    #####: 1249:        ensure_defined(r1);
    #####: 1250:        ensure_defined(r2);
        -: 1251:
    #####: 1252:        switch(opcode)
        -: 1253:        {
    #####: 1254:          case OP_STR_EQ:
    #####: 1255:            r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);
    #####: 1256:            break;
    #####: 1257:          case OP_STR_NEQ:
    #####: 1258:            r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);
    #####: 1259:            break;
    #####: 1260:          case OP_STR_LT:
    #####: 1261:            r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);
    #####: 1262:            break;
    #####: 1263:          case OP_STR_LE:
    #####: 1264:            r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);
    #####: 1265:            break;
    #####: 1266:          case OP_STR_GT:
    #####: 1267:            r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);
    #####: 1268:            break;
    #####: 1269:          case OP_STR_GE:
    #####: 1270:            r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);
    #####: 1271:            break;
        -: 1272:        }
        -: 1273:
    #####: 1274:        push(r1);
    #####: 1275:        break;
        -: 1276:
    #####: 1277:      default:
        -: 1278:        // Unknown instruction, this shouldn't happen.
    #####: 1279:        assert(false);
        -: 1280:    }
        -: 1281:
        -: 1282:    // Check for timeout every 10 instruction cycles. If timeout == 0 it means
        -: 1283:    // no timeout at all.
        -: 1284:
    #####: 1285:    if (context->timeout > 0L && ++cycle == 10)
        -: 1286:    {
    #####: 1287:      elapsed_time = yr_stopwatch_elapsed_us(&context->stopwatch);
        -: 1288:
    #####: 1289:      if (elapsed_time > context->timeout)
        -: 1290:      {
        -: 1291:        #ifdef PROFILING_ENABLED
        -: 1292:        assert(current_rule != NULL);
        -: 1293:        current_rule->time_cost_per_thread[tidx] += elapsed_time - start_time;
        -: 1294:        #endif
    #####: 1295:        result = ERROR_SCAN_TIMEOUT;
    #####: 1296:        stop = true;
        -: 1297:      }
        -: 1298:
    #####: 1299:      cycle = 0;
        -: 1300:    }
        -: 1301:  }
        -: 1302:
    #####: 1303:  obj_ptr = (YR_OBJECT**) yr_arena_base_address(obj_arena);
        -: 1304:
    #####: 1305:  while (obj_ptr != NULL)
        -: 1306:  {
    #####: 1307:    yr_object_destroy(*obj_ptr);
        -: 1308:
    #####: 1309:    obj_ptr = (YR_OBJECT**) yr_arena_next_address(
        -: 1310:        obj_arena, obj_ptr, sizeof(YR_OBJECT*));
        -: 1311:  }
        -: 1312:
    #####: 1313:  yr_arena_destroy(obj_arena);
    #####: 1314:  yr_modules_unload_all(context);
    #####: 1315:  yr_free(stack);
        -: 1316:
    #####: 1317:  return result;
        -: 1318:}
