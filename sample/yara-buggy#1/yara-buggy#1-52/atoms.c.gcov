        -:    0:Source:atoms.c
        -:    0:Graph:/home/workspace/libyara/.libs/atoms.gcno
        -:    0:Data:/home/workspace/libyara/.libs/atoms.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:Copyright (c) 2013-2018. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/*
        -:   31:
        -:   32:This module handles atom extraction from regexps and hex strings. Atoms are
        -:   33:undivided substrings found in a regexps and hex strings. Let's consider this
        -:   34:hex string:
        -:   35:
        -:   36:{ 01 02 03 04 05 ?? 06 07 08 [1-2] 09 0A }
        -:   37:
        -:   38:In the above string, byte sequences 0102030405, 060708 and 090A are atoms.
        -:   39:Similarly, in this regexp:
        -:   40:
        -:   41:/abc.*ed[0-9]+fgh/
        -:   42:
        -:   43:The strings "abc", "ed" and "fgh" are atoms.
        -:   44:
        -:   45:When searching for regexps/hex strings matching a file, YARA uses these
        -:   46:atoms to find locations inside the file where the regexp/hex string could
        -:   47:match. If the atom "abc" is found somewhere inside the file, there is a chance
        -:   48:for /abc.*ed[0-9]+fgh/ to match the file, if "abc" doesn't appear in the file
        -:   49:there's no chance for the regexp to match. When the atom is found in the file
        -:   50:YARA proceeds to fully evaluate the regexp/hex string to determine if it's
        -:   51:actually a match.
        -:   52:
        -:   53:For each regexp/hex string YARA extracts one or more atoms. Sometimes a
        -:   54:single atom is enough (like in the previous example "abc" is enough for finding
        -:   55:/abc.*ed[0-9]+fgh/), but sometimes a single atom isn't enough like in the
        -:   56:regexp /(abc|efg)/. In this case YARA must search for both "abc" AND "efg" and
        -:   57:fully evaluate the regexp whenever one of these atoms is found.
        -:   58:
        -:   59:In the regexp /Look(at|into)this/ YARA can search for "Look", or search for
        -:   60:"this", or search for both "at" and "into". This is what we call an atoms tree,
        -:   61:because it can be represented by the following tree structure:
        -:   62:
        -:   63:-OR
        -:   64:  |- "Look"
        -:   65:  |
        -:   66:  |- AND
        -:   67:  |   |
        -:   68:  |   |- "at"
        -:   69:  |    - "into"
        -:   70:  |
        -:   71:   - "this"
        -:   72:
        -:   73:From an atom tree YARA chooses the best combination, trying to minimize the
        -:   74:number of required atoms, but also using high quality atoms (long atoms with
        -:   75:not too many zeroes and a bit of byte diversity). In the previous example YARA
        -:   76:will end up using the "Look" atom alone, but in /a(bcd|efg)h/ atoms "bcd" and
        -:   77:"efg" will be used because "a" and "h" are too short.
        -:   78:
        -:   79:*/
        -:   80:
        -:   81:#include <assert.h>
        -:   82:#include <stdbool.h>
        -:   83:#include <string.h>
        -:   84:
        -:   85:#include <yara/utils.h>
        -:   86:#include <yara/atoms.h>
        -:   87:#include <yara/limits.h>
        -:   88:#include <yara/mem.h>
        -:   89:#include <yara/error.h>
        -:   90:#include <yara/types.h>
        -:   91:
        -:   92:
        -:   93:#define append_current_leaf_to_node(node) \
        -:   94:    if (atom_tree->current_leaf != NULL) \
        -:   95:    { \
        -:   96:      _yr_atoms_tree_node_append(node, atom_tree->current_leaf); \
        -:   97:      atom_tree->current_leaf = NULL; \
        -:   98:    } \
        -:   99:
        -:  100:
        -:  101://
        -:  102:// yr_atoms_heuristic_quality
        -:  103://
        -:  104:// Returns a numeric value indicating the quality of an atom. The quality
        -:  105:// depends on some characteristics of the atom, including its length, number
        -:  106:// of very common bytes like 00 and FF and number of unique distinct bytes.
        -:  107:// Atom 00 00 has a very low quality, because it's only two bytes long and
        -:  108:// both bytes are zeroes. Atom 01 01 01 01 is better but still not optimal,
        -:  109:// because the same byte is repeated. Atom 01 02 03 04 is an optimal one.
        -:  110://
        -:  111:// Args:
        -:  112://    YR_ATOMS_CONFIG* config   - Pointer to YR_ATOMS_CONFIG struct.
        -:  113://    uint8_t* atom             - Pointer to the atom's bytes.
        -:  114://    int atom_length           - Atom's length.
        -:  115://
        -:  116:// Returns:
        -:  117://    An integer indicating the atom's quality
        -:  118://
        -:  119:
function yr_atoms_heuristic_quality called 0 returned 0% blocks executed 0%
    #####:  120:int yr_atoms_heuristic_quality(
        -:  121:    YR_ATOMS_CONFIG* config,
        -:  122:    uint8_t* atom,
        -:  123:    int atom_length)
        -:  124:{
        -:  125:  int penalty = 0;
        -:  126:  int unique_bytes = 0;
        -:  127:  int i, j;
        -:  128:  bool is_unique;
        -:  129:
    #####:  130:  for (i = 0; i < atom_length; i++)
branch  0 never executed
branch  1 never executed
        -:  131:  {
    #####:  132:    if (atom[i] == 0x00 || atom[i] == 0xFF || atom[i] == 0x20 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  133:        atom[i] == 0x0A || atom[i] == 0x0D)
branch  0 never executed
branch  1 never executed
        -:  134:    {
        -:  135:      // Penalize common bytes, specially if they are in the first two positions.
        -:  136:
    #####:  137:      switch(i)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:  138:      {
    #####:  139:        case 0:
    #####:  140:          penalty += 3;
    #####:  141:          break;
    #####:  142:        case 1:
    #####:  143:          penalty += 2;
    #####:  144:          break;
    #####:  145:        default:
    #####:  146:          penalty += 1;
    #####:  147:          break;
        -:  148:      }
    #####:  149:    }
        -:  150:
        -:  151:    is_unique = true;
        -:  152:
    #####:  153:    for (j = i + 1; j < atom_length; j++)
branch  0 never executed
branch  1 never executed
    #####:  154:      if (atom[i] == atom[j])
branch  0 never executed
branch  1 never executed
        -:  155:      {
        -:  156:        is_unique = false;
        -:  157:        break;
        -:  158:      }
        -:  159:
    #####:  160:    if (is_unique)
branch  0 never executed
branch  1 never executed
    #####:  161:      unique_bytes += 1;
        -:  162:  }
        -:  163:
        -:  164:  // (atom_length + unique_bytes - penalty + 2) is within the range
        -:  165:  // [0 - 2 * YR_MAX_ATOM_LENGTH], which means that the function returns a value
        -:  166:  // in [YR_MAX_ATOM_QUALITY - 2 * YR_MAX_ATOM_LENGTH, YR_MAX_ATOM_QUALITY]
        -:  167:
    #####:  168:  return YR_MAX_ATOM_QUALITY - 2 * YR_MAX_ATOM_LENGTH +
    #####:  169:          (atom_length + unique_bytes - penalty + 2);
        -:  170:}
        -:  171:
        -:  172://
        -:  173:// yr_atoms_table_quality
        -:  174://
        -:  175:// Returns a numeric value indicating the quality of an atom. The quality is
        -:  176:// based in the atom quality table passed in "config". Very common atoms
        -:  177:// (i.e: those with greater quality) have lower quality than those that are
        -:  178:// uncommon. See the comment for yr_compiler_set_atom_quality_table for
        -:  179:// details about the quality table's format.
        -:  180://
        -:  181:// Args:
        -:  182://    YR_ATOMS_CONFIG* config   - Pointer to YR_ATOMS_CONFIG struct.
        -:  183://    uint8_t* atom             - Pointer to the atom's bytes.
        -:  184://    int atom_length           - Atom's length.
        -:  185://
        -:  186:// Returns:
        -:  187://    An integer indicating the atom's quality
        -:  188://
        -:  189:
function yr_atoms_table_quality called 0 returned 0% blocks executed 0%
    #####:  190:int yr_atoms_table_quality(
        -:  191:    YR_ATOMS_CONFIG* config,
        -:  192:    uint8_t* atom,
        -:  193:    int atom_length)
        -:  194:{
    #####:  195:  YR_ATOM_QUALITY_TABLE_ENTRY* table = config->quality_table;
        -:  196:
        -:  197:  int begin = 0;
    #####:  198:  int end = config->quality_table_entries;
        -:  199:
    #####:  200:  while (end > begin)
branch  0 never executed
branch  1 never executed
        -:  201:  {
    #####:  202:    int middle = begin + (end - begin) / 2;
    #####:  203:    int c = memcmp(table[middle].atom, atom, atom_length);
        -:  204:
    #####:  205:    if (c < 0)
branch  0 never executed
branch  1 never executed
        -:  206:    {
    #####:  207:      begin = middle + 1;
        -:  208:    }
    #####:  209:    else if (c > 0)
branch  0 never executed
branch  1 never executed
        -:  210:    {
        -:  211:      end = middle;
        -:  212:    }
        -:  213:    else
        -:  214:    {
    #####:  215:      if (atom_length == YR_MAX_ATOM_LENGTH)
branch  0 never executed
branch  1 never executed
    #####:  216:        return table[middle].quality;
        -:  217:
    #####:  218:      int i = middle + 1;
    #####:  219:      int quality = table[middle].quality;
        -:  220:      int min_quality = quality;
        -:  221:
    #####:  222:      while (i < end && memcmp(table[i].atom, atom, atom_length) == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  223:      {
    #####:  224:        if (min_quality > table[i].quality)
branch  0 never executed
branch  1 never executed
        -:  225:          min_quality = table[i].quality;
        -:  226:
    #####:  227:        i++;
        -:  228:      }
        -:  229:
    #####:  230:      i = middle - 1;
        -:  231:
    #####:  232:      while (i >= begin && memcmp(table[i].atom, atom, atom_length) == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  233:      {
    #####:  234:        if (min_quality > table[i].quality)
branch  0 never executed
branch  1 never executed
        -:  235:          min_quality = table[i].quality;
        -:  236:
    #####:  237:        i--;
        -:  238:      }
        -:  239:
    #####:  240:      return min_quality >> (YR_MAX_ATOM_LENGTH - atom_length);
        -:  241:    }
        -:  242:  }
        -:  243:
        -:  244:  return YR_MAX_ATOM_QUALITY;
        -:  245:}
        -:  246:
        -:  247:
        -:  248://
        -:  249:// yr_atoms_min_quality
        -:  250://
        -:  251:// Returns the quality for the worst quality atom in a list.
        -:  252://
        -:  253:
function yr_atoms_min_quality called 0 returned 0% blocks executed 0%
    #####:  254:int yr_atoms_min_quality(
        -:  255:    YR_ATOMS_CONFIG* config,
        -:  256:    YR_ATOM_LIST_ITEM* atom_list)
        -:  257:{
        -:  258:  YR_ATOM_LIST_ITEM* atom;
        -:  259:
        -:  260:  int quality;
        -:  261:  int min_quality = YR_MAX_ATOM_QUALITY;
        -:  262:
    #####:  263:  if (atom_list == NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  264:    return YR_MIN_ATOM_QUALITY;
        -:  265:
        -:  266:  atom = atom_list;
        -:  267:
    #####:  268:  while (atom != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  269:  {
    #####:  270:    quality = config->get_atom_quality(config, atom->atom, atom->atom_length);
call    0 never executed
call    1 never executed
        -:  271:
    #####:  272:    if (quality < min_quality)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  273:      min_quality = quality;
        -:  274:
    #####:  275:    atom = atom->next;
        -:  276:  }
        -:  277:
        -:  278:  return min_quality;
        -:  279:}
        -:  280:
        -:  281:
        -:  282://
        -:  283:// _yr_atoms_tree_node_create
        -:  284://
        -:  285:// Creates a new node for an atoms tree.
        -:  286://
        -:  287:
function _yr_atoms_tree_node_create called 0 returned 0% blocks executed 0%
    #####:  288:static ATOM_TREE_NODE* _yr_atoms_tree_node_create(
        -:  289:    uint8_t type)
        -:  290:{
    #####:  291:  ATOM_TREE_NODE* new_node = (ATOM_TREE_NODE*) \
call    0 never executed
        -:  292:      yr_malloc(sizeof(ATOM_TREE_NODE));
        -:  293:
    #####:  294:  if (new_node != NULL)
branch  0 never executed
branch  1 never executed
        -:  295:  {
    #####:  296:    new_node->type = type;
    #####:  297:    new_node->atom_length = 0;
    #####:  298:    new_node->next_sibling = NULL;
    #####:  299:    new_node->children_head = NULL;
    #####:  300:    new_node->children_tail = NULL;
    #####:  301:    new_node->forward_code = NULL;
    #####:  302:    new_node->backward_code = NULL;
        -:  303:  }
        -:  304:
    #####:  305:  return new_node;
        -:  306:}
        -:  307:
        -:  308:
        -:  309://
        -:  310:// _yr_atoms_tree_node_destroy
        -:  311://
        -:  312:// Destroys a node from an atoms tree.
        -:  313://
        -:  314:
function _yr_atoms_tree_node_destroy called 0 returned 0% blocks executed 0%
    #####:  315:static void _yr_atoms_tree_node_destroy(
        -:  316:    ATOM_TREE_NODE* node)
        -:  317:{
        -:  318:  ATOM_TREE_NODE* child;
        -:  319:  ATOM_TREE_NODE* next_child;
        -:  320:
    #####:  321:  if (node == NULL)
branch  0 never executed
branch  1 never executed
        -:  322:    return;
        -:  323:
    #####:  324:  if (node->type == ATOM_TREE_OR || node->type == ATOM_TREE_AND)
branch  0 never executed
branch  1 never executed
        -:  325:  {
    #####:  326:    child = node->children_head;
        -:  327:
    #####:  328:    while (child != NULL)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      next_child = child->next_sibling;
    #####:  331:      _yr_atoms_tree_node_destroy(child);
call    0 never executed
        -:  332:      child = next_child;
        -:  333:    }
        -:  334:  }
        -:  335:
    #####:  336:  yr_free(node);
call    0 never executed
        -:  337:}
        -:  338:
        -:  339:
        -:  340://
        -:  341:// _yr_atoms_tree_node_append
        -:  342://
        -:  343:// Appends a new child node to another atoms tree node.
        -:  344://
        -:  345:
        -:  346:static void _yr_atoms_tree_node_append(
        -:  347:    ATOM_TREE_NODE* dest,
        -:  348:    ATOM_TREE_NODE* node)
        -:  349:{
    #####:  350:  if (dest->children_head == NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
    #####:  351:    dest->children_head = node;
        -:  352:
    #####:  353:  if (dest->children_tail != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
    #####:  354:    dest->children_tail->next_sibling = node;
        -:  355:
    #####:  356:  dest->children_tail = node;
        -:  357:}
        -:  358:
        -:  359:
        -:  360://
        -:  361:// _yr_atoms_tree_destroy
        -:  362://
        -:  363:// Destroys an atoms tree.
        -:  364://
        -:  365:
        -:  366:static void _yr_atoms_tree_destroy(
        -:  367:    ATOM_TREE* atom_tree)
        -:  368:{
    #####:  369:  _yr_atoms_tree_node_destroy(atom_tree->root_node);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  370:  yr_free(atom_tree);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  371:}
        -:  372:
        -:  373:
        -:  374://
        -:  375:// yr_atoms_list_destroy
        -:  376://
        -:  377:// Destroys an atoms list.
        -:  378://
        -:  379:
function yr_atoms_list_destroy called 0 returned 0% blocks executed 0%
    #####:  380:void yr_atoms_list_destroy(
        -:  381:    YR_ATOM_LIST_ITEM* list_head)
        -:  382:{
        -:  383:  YR_ATOM_LIST_ITEM* item = list_head;
        -:  384:  YR_ATOM_LIST_ITEM* next;
        -:  385:
    #####:  386:  while (item != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
        -:  387:  {
    #####:  388:    next = item->next;
    #####:  389:    yr_free(item);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
        -:  390:    item = next;
        -:  391:  }
    #####:  392:}
        -:  393:
        -:  394:
        -:  395://
        -:  396:// yr_atoms_list_destroy
        -:  397://
        -:  398:// Concats two atoms lists.
        -:  399://
        -:  400:
        -:  401:static YR_ATOM_LIST_ITEM* _yr_atoms_list_concat(
        -:  402:    YR_ATOM_LIST_ITEM* list1,
        -:  403:    YR_ATOM_LIST_ITEM* list2)
        -:  404:{
        -:  405:  YR_ATOM_LIST_ITEM* item;
        -:  406:
    #####:  407:  if (list1 == NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:  408:    return list2;
        -:  409:
        -:  410:  item = list1;
        -:  411:
    #####:  412:  while (item->next != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:  413:  {
        -:  414:    item = item->next;
        -:  415:  }
        -:  416:
    #####:  417:  item->next = list2;
        -:  418:  return list1;
        -:  419:}
        -:  420:
        -:  421:
        -:  422://
        -:  423:// _yr_atoms_choose
        -:  424://
        -:  425:// Chooses which atoms from an atoms tree will be used to feed the
        -:  426:// Aho-Corasick automaton, and puts them in a list.
        -:  427://
        -:  428:
function _yr_atoms_choose called 0 returned 0% blocks executed 0%
    #####:  429:static int _yr_atoms_choose(
        -:  430:    YR_ATOMS_CONFIG* config,
        -:  431:    ATOM_TREE_NODE* node,
        -:  432:    YR_ATOM_LIST_ITEM** chosen_atoms,
        -:  433:    int* atoms_quality)
        -:  434:{
        -:  435:  ATOM_TREE_NODE* child;
        -:  436:  YR_ATOM_LIST_ITEM* item;
        -:  437:  YR_ATOM_LIST_ITEM* tail;
        -:  438:
        -:  439:  int i, quality;
        -:  440:  int max_quality = YR_MIN_ATOM_QUALITY;
        -:  441:  int min_quality = YR_MAX_ATOM_QUALITY;
        -:  442:
    #####:  443:  *chosen_atoms = NULL;
        -:  444:
    #####:  445:  switch (node->type)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  446:  {
    #####:  447:  case ATOM_TREE_LEAF:
        -:  448:
    #####:  449:    item = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
call    0 never executed
        -:  450:
    #####:  451:    if (item == NULL)
branch  0 never executed
branch  1 never executed
        -:  452:      return ERROR_INSUFFICIENT_MEMORY;
        -:  453:
    #####:  454:    for (i = 0; i < node->atom_length; i++)
branch  0 never executed
branch  1 never executed
    #####:  455:      item->atom[i] = node->atom[i];
        -:  456:
    #####:  457:    item->atom_length = node->atom_length;
    #####:  458:    item->forward_code = node->forward_code;
    #####:  459:    item->backward_code = node->backward_code;
    #####:  460:    item->backtrack = 0;
    #####:  461:    item->next = NULL;
        -:  462:
    #####:  463:    *chosen_atoms = item;
    #####:  464:    *atoms_quality = config->get_atom_quality(
call    0 never executed
    #####:  465:        config, node->atom, node->atom_length);
    #####:  466:    break;
        -:  467:
    #####:  468:  case ATOM_TREE_OR:
        -:  469:
    #####:  470:    child = node->children_head;
        -:  471:
    #####:  472:    while (child != NULL)
branch  0 never executed
branch  1 never executed
        -:  473:    {
    #####:  474:      FAIL_ON_ERROR(_yr_atoms_choose(config, child, &item, &quality));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  475:
    #####:  476:      if (quality > max_quality)
branch  0 never executed
branch  1 never executed
        -:  477:      {
        -:  478:        max_quality = quality;
    #####:  479:        yr_atoms_list_destroy(*chosen_atoms);
    #####:  480:        *chosen_atoms = item;
        -:  481:      }
        -:  482:      else
        -:  483:      {
    #####:  484:        yr_atoms_list_destroy(item);
        -:  485:      }
        -:  486:
    #####:  487:      if (max_quality == YR_MAX_ATOM_QUALITY)
branch  0 never executed
branch  1 never executed
        -:  488:        break;
        -:  489:
    #####:  490:      child = child->next_sibling;
        -:  491:    }
        -:  492:
    #####:  493:    *atoms_quality = max_quality;
    #####:  494:    break;
        -:  495:
    #####:  496:  case ATOM_TREE_AND:
        -:  497:
    #####:  498:    child = node->children_head;
        -:  499:
    #####:  500:    while (child != NULL)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      FAIL_ON_ERROR(_yr_atoms_choose(config, child, &item, &quality));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  503:
    #####:  504:      if (quality < min_quality)
branch  0 never executed
branch  1 never executed
        -:  505:        min_quality = quality;
        -:  506:
    #####:  507:      if (item != NULL)
branch  0 never executed
branch  1 never executed
        -:  508:      {
        -:  509:        tail = item;
    #####:  510:        while (tail->next != NULL)
branch  0 never executed
branch  1 never executed
        -:  511:          tail = tail->next;
        -:  512:
    #####:  513:        tail->next = *chosen_atoms;
    #####:  514:        *chosen_atoms = item;
        -:  515:      }
        -:  516:
    #####:  517:      child = child->next_sibling;
        -:  518:    }
        -:  519:
    #####:  520:    *atoms_quality = min_quality;
    #####:  521:    break;
        -:  522:  }
        -:  523:
        -:  524:  return ERROR_SUCCESS;
        -:  525:}
        -:  526:
        -:  527:
        -:  528://
        -:  529:// _yr_atoms_case_combinations
        -:  530://
        -:  531:// Returns all combinations of lower and upper cases for a given atom. For
        -:  532:// atom "abc" the output would be "abc" "abC" "aBC" and so on. Resulting
        -:  533:// atoms are written into the output buffer in this format:
        -:  534://
        -:  535://  [size of atom 1] [atom 1]  ... [size of atom N] [atom N] [0]
        -:  536://
        -:  537:// Notice the zero at the end to indicate where the output ends.
        -:  538://
        -:  539:// The caller is responsible of providing a buffer large enough to hold the
        -:  540:// returned atoms.
        -:  541://
        -:  542:
function _yr_atoms_case_combinations called 0 returned 0% blocks executed 0%
    #####:  543:static uint8_t* _yr_atoms_case_combinations(
        -:  544:    uint8_t* atom,
        -:  545:    int atom_length,
        -:  546:    int atom_offset,
        -:  547:    uint8_t* output_buffer)
        -:  548:{
        -:  549:  uint8_t c;
        -:  550:  uint8_t* new_atom;
        -:  551:
    #####:  552:  if (atom_offset + 1 < atom_length)
branch  0 never executed
branch  1 never executed
    #####:  553:    output_buffer = _yr_atoms_case_combinations(
call    0 never executed
        -:  554:        atom,
        -:  555:        atom_length,
        -:  556:        atom_offset + 1,
        -:  557:        output_buffer);
        -:  558:
    #####:  559:  c = atom[atom_offset];
        -:  560:
    #####:  561:  if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
branch  0 never executed
branch  1 never executed
        -:  562:  {
        -:  563:    // Write atom length.
    #####:  564:    *output_buffer = atom_length;
    #####:  565:    output_buffer++;
        -:  566:
    #####:  567:    memcpy(output_buffer, atom, atom_length);
        -:  568:
        -:  569:    new_atom = output_buffer;
    #####:  570:    output_buffer += atom_length;
        -:  571:
        -:  572:    // Swap character case.
    #####:  573:    if (c >= 'a' && c <= 'z')
branch  0 never executed
branch  1 never executed
    #####:  574:      new_atom[atom_offset] -= 32;
        -:  575:    else
    #####:  576:      new_atom[atom_offset] += 32;
        -:  577:
    #####:  578:    if (atom_offset + 1 < atom_length)
branch  0 never executed
branch  1 never executed
    #####:  579:      output_buffer = _yr_atoms_case_combinations(
call    0 never executed
        -:  580:          new_atom,
        -:  581:          atom_length,
        -:  582:          atom_offset + 1,
        -:  583:          output_buffer);
        -:  584:  }
        -:  585:
    #####:  586:  if (atom_offset == 0)
branch  0 never executed
branch  1 never executed
    #####:  587:    *output_buffer = 0;
        -:  588:
    #####:  589:  return output_buffer;
        -:  590:}
        -:  591:
        -:  592:// Size of buffer used in _yr_atoms_case_insensitive for storing the all
        -:  593:// the possible combinations for an atom. Each atom has up to YR_MAX_ATOM_LENGTH
        -:  594:// characters and each character has two possible values (upper and lower case).
        -:  595:// That means 2 ^ YR_MAX_ATOM_LENGTH combinations for an atom, where each atom
        -:  596:// occupies YR_MAX_ATOM_LENGTH + 1 bytes (the atom itself +1 byte for its length)
        -:  597:// One extra bytes is allocated for the zero value indicating the end.
        -:  598:
        -:  599:#define CASE_COMBINATIONS_BUFFER_SIZE \
        -:  600:    (1 << YR_MAX_ATOM_LENGTH) * (YR_MAX_ATOM_LENGTH + 1) + 1
        -:  601:
        -:  602://
        -:  603:// _yr_atoms_case_insensitive
        -:  604://
        -:  605:// For a given list of atoms returns another list of atoms
        -:  606:// with every case combination.
        -:  607://
        -:  608:
function _yr_atoms_case_insensitive called 0 returned 0% blocks executed 0%
    #####:  609:static int _yr_atoms_case_insensitive(
        -:  610:    YR_ATOM_LIST_ITEM* atoms,
        -:  611:    YR_ATOM_LIST_ITEM** case_insensitive_atoms)
        -:  612:{
        -:  613:  YR_ATOM_LIST_ITEM* atom;
        -:  614:  YR_ATOM_LIST_ITEM* new_atom;
        -:  615:
        -:  616:  uint8_t buffer[CASE_COMBINATIONS_BUFFER_SIZE];
        -:  617:  uint8_t atom_length;
        -:  618:  uint8_t* atoms_cursor;
        -:  619:
        -:  620:  int i;
        -:  621:
    #####:  622:  *case_insensitive_atoms = NULL;
        -:  623:  atom = atoms;
        -:  624:
    #####:  625:  while (atom != NULL)
branch  0 never executed
branch  1 never executed
        -:  626:  {
    #####:  627:    _yr_atoms_case_combinations(
call    0 never executed
    #####:  628:        atom->atom,
    #####:  629:        atom->atom_length,
        -:  630:        0,
        -:  631:        buffer);
        -:  632:
        -:  633:    atoms_cursor = buffer;
    #####:  634:    atom_length = *atoms_cursor;
        -:  635:    atoms_cursor++;
        -:  636:
    #####:  637:    while (atom_length != 0)
branch  0 never executed
branch  1 never executed
        -:  638:    {
    #####:  639:      new_atom = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
call    0 never executed
        -:  640:
    #####:  641:      if (new_atom == NULL)
branch  0 never executed
branch  1 never executed
        -:  642:        return ERROR_INSUFFICIENT_MEMORY;
        -:  643:
    #####:  644:      for (i = 0; i < atom_length; i++)
branch  0 never executed
branch  1 never executed
    #####:  645:        new_atom->atom[i] = atoms_cursor[i];
        -:  646:
    #####:  647:      new_atom->atom_length = atom_length;
    #####:  648:      new_atom->forward_code = atom->forward_code;
    #####:  649:      new_atom->backward_code = atom->backward_code;
    #####:  650:      new_atom->backtrack = atom->backtrack;
    #####:  651:      new_atom->next = *case_insensitive_atoms;
        -:  652:
    #####:  653:      *case_insensitive_atoms = new_atom;
        -:  654:
    #####:  655:      atoms_cursor += atom_length;
    #####:  656:      atom_length = *atoms_cursor;
    #####:  657:      atoms_cursor++;
        -:  658:    }
        -:  659:
    #####:  660:    atom = atom->next;
        -:  661:  }
        -:  662:
        -:  663:  return ERROR_SUCCESS;
        -:  664:}
        -:  665:
        -:  666:
        -:  667://
        -:  668:// _yr_atoms_xor
        -:  669://
        -:  670:// For a given list of atoms returns another list after a single byte xor
        -:  671:// has been applied to it.
        -:  672://
function _yr_atoms_xor called 0 returned 0% blocks executed 0%
    #####:  673:static int _yr_atoms_xor(
        -:  674:    YR_ATOM_LIST_ITEM* atoms,
        -:  675:    YR_ATOM_LIST_ITEM** xor_atoms)
        -:  676:{
        -:  677:  YR_ATOM_LIST_ITEM* atom;
        -:  678:  YR_ATOM_LIST_ITEM* new_atom;
        -:  679:
        -:  680:  int i, j;
    #####:  681:  *xor_atoms = NULL;
        -:  682:  atom = atoms;
        -:  683:
    #####:  684:  while (atom != NULL)
branch  0 never executed
branch  1 never executed
        -:  685:  {
    #####:  686:    for (j = 1; j <= 255; j++)
branch  0 never executed
branch  1 never executed
        -:  687:    {
    #####:  688:      new_atom = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
call    0 never executed
        -:  689:
    #####:  690:      if (new_atom == NULL)
branch  0 never executed
branch  1 never executed
        -:  691:        return ERROR_INSUFFICIENT_MEMORY;
        -:  692:
    #####:  693:      for (i = 0; i < atom->atom_length; i++)
branch  0 never executed
branch  1 never executed
    #####:  694:        new_atom->atom[i] = atom->atom[i] ^ j;
        -:  695:
    #####:  696:      new_atom->atom_length = yr_min(atom->atom_length, YR_MAX_ATOM_LENGTH);
    #####:  697:      new_atom->forward_code = atom->forward_code;
    #####:  698:      new_atom->backward_code = atom->backward_code;
    #####:  699:      new_atom->backtrack = atom->backtrack;
    #####:  700:      new_atom->next = *xor_atoms;
        -:  701:
    #####:  702:      *xor_atoms = new_atom;
        -:  703:    }
        -:  704:
    #####:  705:    atom = atom->next;
        -:  706:  }
        -:  707:  return ERROR_SUCCESS;
        -:  708:}
        -:  709://
        -:  710:// _yr_atoms_wide
        -:  711://
        -:  712:// For a given list of atoms returns another list with the corresponding
        -:  713:// wide atoms. Wide atoms are just the original atoms with interleaved zeroes,
        -:  714:// for example: 01 02 -> 01 00 02 00
        -:  715://
        -:  716:
function _yr_atoms_wide called 0 returned 0% blocks executed 0%
    #####:  717:static int _yr_atoms_wide(
        -:  718:    YR_ATOM_LIST_ITEM* atoms,
        -:  719:    YR_ATOM_LIST_ITEM** wide_atoms)
        -:  720:{
        -:  721:  YR_ATOM_LIST_ITEM* atom;
        -:  722:  YR_ATOM_LIST_ITEM* new_atom;
        -:  723:
        -:  724:  int i;
        -:  725:
    #####:  726:  *wide_atoms = NULL;
        -:  727:  atom = atoms;
        -:  728:
    #####:  729:  while (atom != NULL)
branch  0 never executed
branch  1 never executed
        -:  730:  {
    #####:  731:    new_atom = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
call    0 never executed
        -:  732:
    #####:  733:    if (new_atom == NULL)
branch  0 never executed
branch  1 never executed
        -:  734:      return ERROR_INSUFFICIENT_MEMORY;
        -:  735:
    #####:  736:    for (i = 0; i < YR_MAX_ATOM_LENGTH; i++)
branch  0 never executed
branch  1 never executed
    #####:  737:      new_atom->atom[i] = 0;
        -:  738:
    #####:  739:    for (i = 0; i < atom->atom_length; i++)
branch  0 never executed
branch  1 never executed
        -:  740:    {
    #####:  741:      if (i * 2 < YR_MAX_ATOM_LENGTH)
branch  0 never executed
branch  1 never executed
    #####:  742:        new_atom->atom[i * 2] = atom->atom[i];
        -:  743:      else
        -:  744:        break;
        -:  745:    }
        -:  746:
    #####:  747:    new_atom->atom_length = yr_min(atom->atom_length * 2, YR_MAX_ATOM_LENGTH);
    #####:  748:    new_atom->forward_code = atom->forward_code;
    #####:  749:    new_atom->backward_code = atom->backward_code;
    #####:  750:    new_atom->backtrack = atom->backtrack * 2;
    #####:  751:    new_atom->next = *wide_atoms;
        -:  752:
    #####:  753:    *wide_atoms = new_atom;
        -:  754:
    #####:  755:    atom = atom->next;
        -:  756:  }
        -:  757:
        -:  758:  return ERROR_SUCCESS;
        -:  759:}
        -:  760:
        -:  761:
        -:  762://
        -:  763:// _yr_atoms_extract_from_re_node
        -:  764://
        -:  765:// Extract atoms from a regular expression node. See description for
        -:  766:// _yr_atoms_extract_from_re for more details.
        -:  767://
        -:  768:
function _yr_atoms_extract_from_re_node called 0 returned 0% blocks executed 0%
    #####:  769:static ATOM_TREE_NODE* _yr_atoms_extract_from_re_node(
        -:  770:    YR_ATOMS_CONFIG* config,
        -:  771:    RE_NODE* re_node,
        -:  772:    ATOM_TREE* atom_tree,
        -:  773:    ATOM_TREE_NODE* current_node)
        -:  774:{
        -:  775:  ATOM_TREE_NODE* left_node;
        -:  776:  ATOM_TREE_NODE* right_node;
        -:  777:  ATOM_TREE_NODE* and_node;
        -:  778:  ATOM_TREE_NODE* current_leaf;
        -:  779:  ATOM_TREE_NODE* temp;
        -:  780:
        -:  781:  int quality;
        -:  782:  int new_quality;
        -:  783:  int i;
        -:  784:
        -:  785:  uint8_t new_atom[YR_MAX_ATOM_LENGTH];
        -:  786:
    #####:  787:  switch(re_node->type)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  788:  {
    #####:  789:    case RE_NODE_LITERAL:
        -:  790:
    #####:  791:      if (atom_tree->current_leaf == NULL)
branch  0 never executed
branch  1 never executed
        -:  792:      {
    #####:  793:        atom_tree->current_leaf = _yr_atoms_tree_node_create(ATOM_TREE_LEAF);
call    0 never executed
        -:  794:
    #####:  795:        if (atom_tree->current_leaf == NULL)
branch  0 never executed
branch  1 never executed
        -:  796:          return NULL;
        -:  797:
    #####:  798:        atom_tree->current_leaf->forward_code = re_node->forward_code;
    #####:  799:        atom_tree->current_leaf->backward_code = re_node->backward_code;
        -:  800:
    #####:  801:        assert(atom_tree->current_leaf->forward_code != NULL);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  802:        assert(atom_tree->current_leaf->backward_code != NULL);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  803:      }
        -:  804:
    #####:  805:      current_leaf = atom_tree->current_leaf;
        -:  806:
    #####:  807:      if (current_leaf->atom_length < YR_MAX_ATOM_LENGTH)
branch  0 never executed
branch  1 never executed
        -:  808:      {
    #####:  809:        current_leaf->atom[current_leaf->atom_length] =
    #####:  810:            (uint8_t) re_node->value;
    #####:  811:        current_leaf->recent_nodes[current_leaf->atom_length] = re_node;
    #####:  812:        current_leaf->atom_length++;
        -:  813:      }
        -:  814:      else
        -:  815:      {
    #####:  816:        quality = config->get_atom_quality(
call    0 never executed
    #####:  817:            config, current_leaf->atom, YR_MAX_ATOM_LENGTH);
        -:  818:
    #####:  819:        if (quality < YR_MAX_ATOM_QUALITY)
branch  0 never executed
branch  1 never executed
        -:  820:        {
    #####:  821:          for (i = 1; i < YR_MAX_ATOM_LENGTH; i++)
branch  0 never executed
branch  1 never executed
    #####:  822:            current_leaf->recent_nodes[i - 1] = current_leaf->recent_nodes[i];
        -:  823:
    #####:  824:          current_leaf->recent_nodes[YR_MAX_ATOM_LENGTH - 1] = re_node;
        -:  825:
    #####:  826:          for (i = 0; i < YR_MAX_ATOM_LENGTH; i++)
branch  0 never executed
branch  1 never executed
    #####:  827:            new_atom[i] = (uint8_t) current_leaf->recent_nodes[i]->value;
        -:  828:
    #####:  829:          new_quality = config->get_atom_quality(
call    0 never executed
        -:  830:              config, new_atom, YR_MAX_ATOM_LENGTH);
        -:  831:
    #####:  832:          if (new_quality > quality)
branch  0 never executed
branch  1 never executed
        -:  833:          {
    #####:  834:            for (i = 0; i < YR_MAX_ATOM_LENGTH; i++)
branch  0 never executed
branch  1 never executed
    #####:  835:              current_leaf->atom[i] = new_atom[i];
        -:  836:
    #####:  837:            current_leaf->forward_code = \
    #####:  838:                current_leaf->recent_nodes[0]->forward_code;
        -:  839:
    #####:  840:            current_leaf->backward_code = \
    #####:  841:                current_leaf->recent_nodes[0]->backward_code;
        -:  842:
    #####:  843:            assert(current_leaf->forward_code != NULL);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  844:            assert(current_leaf->backward_code != NULL);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  845:          }
        -:  846:        }
        -:  847:      }
        -:  848:
        -:  849:      return current_node;
        -:  850:
    #####:  851:    case RE_NODE_CONCAT:
        -:  852:
    #####:  853:      current_node = _yr_atoms_extract_from_re_node(
call    0 never executed
        -:  854:          config, re_node->left, atom_tree, current_node);
        -:  855:
    #####:  856:      if (current_node == NULL)
branch  0 never executed
branch  1 never executed
        -:  857:        return NULL;
        -:  858:
    #####:  859:      current_node = _yr_atoms_extract_from_re_node(
call    0 never executed
        -:  860:          config, re_node->right, atom_tree, current_node);
        -:  861:
    #####:  862:      return current_node;
        -:  863:
    #####:  864:    case RE_NODE_ALT:
        -:  865:
    #####:  866:      append_current_leaf_to_node(current_node);
branch  0 never executed
branch  1 never executed
        -:  867:
    #####:  868:      left_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);
call    0 never executed
        -:  869:
    #####:  870:      if (left_node == NULL)
branch  0 never executed
branch  1 never executed
        -:  871:        return NULL;
        -:  872:
    #####:  873:      left_node = _yr_atoms_extract_from_re_node(
call    0 never executed
        -:  874:          config, re_node->left, atom_tree, left_node);
        -:  875:
    #####:  876:      if (left_node == NULL)
branch  0 never executed
branch  1 never executed
        -:  877:        return NULL;
        -:  878:
    #####:  879:      append_current_leaf_to_node(left_node);
branch  0 never executed
branch  1 never executed
        -:  880:
    #####:  881:      if (left_node->children_head == NULL)
branch  0 never executed
branch  1 never executed
        -:  882:      {
    #####:  883:        _yr_atoms_tree_node_destroy(left_node);
call    0 never executed
    #####:  884:        return current_node;
        -:  885:      }
        -:  886:
    #####:  887:      if (left_node->children_head == left_node->children_tail)
branch  0 never executed
branch  1 never executed
        -:  888:      {
        -:  889:        temp = left_node;
        -:  890:        left_node = left_node->children_head;
    #####:  891:        yr_free(temp);
call    0 never executed
        -:  892:      }
        -:  893:
    #####:  894:      right_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);
call    0 never executed
        -:  895:
    #####:  896:      if (right_node == NULL)
branch  0 never executed
branch  1 never executed
        -:  897:        return NULL;
        -:  898:
    #####:  899:      right_node = _yr_atoms_extract_from_re_node(
call    0 never executed
        -:  900:          config, re_node->right, atom_tree, right_node);
        -:  901:
    #####:  902:      if (right_node == NULL)
branch  0 never executed
branch  1 never executed
        -:  903:        return NULL;
        -:  904:
    #####:  905:      append_current_leaf_to_node(right_node);
branch  0 never executed
branch  1 never executed
        -:  906:
    #####:  907:      if (right_node->children_head == NULL)
branch  0 never executed
branch  1 never executed
        -:  908:      {
    #####:  909:        _yr_atoms_tree_node_destroy(left_node);
call    0 never executed
    #####:  910:        _yr_atoms_tree_node_destroy(right_node);
call    0 never executed
    #####:  911:        return current_node;
        -:  912:      }
        -:  913:
    #####:  914:      if (right_node->children_head == right_node->children_tail)
branch  0 never executed
branch  1 never executed
        -:  915:      {
        -:  916:        temp = right_node;
        -:  917:        right_node = right_node->children_head;
    #####:  918:        yr_free(temp);
call    0 never executed
        -:  919:      }
        -:  920:
    #####:  921:      and_node = _yr_atoms_tree_node_create(ATOM_TREE_AND);
call    0 never executed
        -:  922:
    #####:  923:      if (and_node == NULL)
branch  0 never executed
branch  1 never executed
        -:  924:        return NULL;
        -:  925:
    #####:  926:      and_node->children_head = left_node;
    #####:  927:      and_node->children_tail = right_node;
    #####:  928:      left_node->next_sibling = right_node;
        -:  929:
        -:  930:      _yr_atoms_tree_node_append(current_node, and_node);
        -:  931:
    #####:  932:      return current_node;
        -:  933:
    #####:  934:    case RE_NODE_RANGE:
        -:  935:
    #####:  936:      if (re_node->start == 0)
branch  0 never executed
branch  1 never executed
    #####:  937:        append_current_leaf_to_node(current_node);
branch  0 never executed
branch  1 never executed
        -:  938:
        -:  939:      // In a regexp like /a{10,20}/ the optimal atom is 'aaaa' (assuming that
        -:  940:      // YR_MAX_ATOM_LENGTH = 4) because the 'a' character must appear at least
        -:  941:      // 10 times in the matching string. Each call in the loop will append
        -:  942:      // one 'a' to the atom, so YR_MAX_ATOM_LENGTH iterations are enough.
        -:  943:
    #####:  944:      for (i = 0; i < yr_min(re_node->start, YR_MAX_ATOM_LENGTH); i++)
branch  0 never executed
branch  1 never executed
        -:  945:      {
    #####:  946:        current_node = _yr_atoms_extract_from_re_node(
call    0 never executed
        -:  947:            config, re_node->left, atom_tree, current_node);
        -:  948:
    #####:  949:        if (current_node == NULL)
branch  0 never executed
branch  1 never executed
        -:  950:          return NULL;
        -:  951:      }
        -:  952:
    #####:  953:      if (re_node->start != re_node->end)
branch  0 never executed
branch  1 never executed
    #####:  954:        append_current_leaf_to_node(current_node);
branch  0 never executed
branch  1 never executed
        -:  955:
        -:  956:      return current_node;
        -:  957:
    #####:  958:    case RE_NODE_PLUS:
        -:  959:
    #####:  960:      current_node = _yr_atoms_extract_from_re_node(
call    0 never executed
        -:  961:          config, re_node->left, atom_tree, current_node);
        -:  962:
    #####:  963:      if (current_node == NULL)
branch  0 never executed
branch  1 never executed
        -:  964:        return NULL;
        -:  965:
    #####:  966:      append_current_leaf_to_node(current_node);
branch  0 never executed
branch  1 never executed
        -:  967:      return current_node;
        -:  968:
    #####:  969:    case RE_NODE_ANY:
        -:  970:    case RE_NODE_RANGE_ANY:
        -:  971:    case RE_NODE_STAR:
        -:  972:    case RE_NODE_CLASS:
        -:  973:    case RE_NODE_MASKED_LITERAL:
        -:  974:    case RE_NODE_WORD_CHAR:
        -:  975:    case RE_NODE_NON_WORD_CHAR:
        -:  976:    case RE_NODE_SPACE:
        -:  977:    case RE_NODE_NON_SPACE:
        -:  978:    case RE_NODE_DIGIT:
        -:  979:    case RE_NODE_NON_DIGIT:
        -:  980:    case RE_NODE_EMPTY:
        -:  981:    case RE_NODE_ANCHOR_START:
        -:  982:    case RE_NODE_ANCHOR_END:
        -:  983:    case RE_NODE_WORD_BOUNDARY:
        -:  984:    case RE_NODE_NON_WORD_BOUNDARY:
        -:  985:
    #####:  986:      append_current_leaf_to_node(current_node);
branch  0 never executed
branch  1 never executed
        -:  987:      return current_node;
        -:  988:
        -:  989:    default:
    #####:  990:      assert(false);
call    0 never executed
        -:  991:  }
        -:  992:
        -:  993:  return NULL;
        -:  994:}
        -:  995:
        -:  996://
        -:  997:// yr_atoms_extract_triplets
        -:  998://
        -:  999:// On certain cases YARA can not extract long enough atoms from a regexp, but
        -: 1000:// can infer them. For example, in the hex string { 01 ?? 02 } the only explicit
        -: 1001:// atoms are 01 and 02, and both of them are too short to be efficiently used.
        -: 1002:// However YARA can use simultaneously atoms 01 00 02, 01 01 02, 01 02 02,
        -: 1003:// 01 03 02, and so on up to 01 FF 02. Searching for 256 three-bytes atoms is
        -: 1004:// faster than searching for a single one-byte atom.
        -: 1005://
        -: 1006:// This function extracts these three-bytes atoms from a regexp node if
        -: 1007:// possible.
        -: 1008://
        -: 1009:
function yr_atoms_extract_triplets called 0 returned 0% blocks executed 0%
    #####: 1010:int yr_atoms_extract_triplets(
        -: 1011:    RE_NODE* re_node,
        -: 1012:    YR_ATOM_LIST_ITEM** atoms)
        -: 1013: {
        -: 1014:    RE_NODE* left_child;
        -: 1015:    RE_NODE* left_grand_child;
        -: 1016:
        -: 1017:    int i;
        -: 1018:    int shift;
        -: 1019:
    #####: 1020:    *atoms = NULL;
        -: 1021:
    #####: 1022:    if (re_node->type == RE_NODE_CONCAT)
branch  0 never executed
branch  1 never executed
    #####: 1023:      left_child = re_node->left;
        -: 1024:    else
        -: 1025:      return ERROR_SUCCESS;
        -: 1026:
    #####: 1027:    if (left_child->type == RE_NODE_CONCAT)
branch  0 never executed
branch  1 never executed
    #####: 1028:      left_grand_child = left_child->left;
        -: 1029:    else
        -: 1030:      return ERROR_SUCCESS;
        -: 1031:
    #####: 1032:    if (re_node->right->type != RE_NODE_LITERAL)
branch  0 never executed
branch  1 never executed
        -: 1033:      return yr_atoms_extract_triplets(left_child, atoms);
        -: 1034:
    #####: 1035:    if (left_child->left->type == RE_NODE_LITERAL &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1036:        (left_child->right->type == RE_NODE_ANY))
        -: 1037:    {
    #####: 1038:      for (i = 0; i < 256; i++)
branch  0 never executed
branch  1 never executed
        -: 1039:      {
    #####: 1040:        YR_ATOM_LIST_ITEM* atom = (YR_ATOM_LIST_ITEM*)
call    0 never executed
        -: 1041:            yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -: 1042:
    #####: 1043:        if (atom == NULL)
branch  0 never executed
branch  1 never executed
        -: 1044:          return ERROR_INSUFFICIENT_MEMORY;
        -: 1045:
    #####: 1046:        atom->atom[0] = (uint8_t) left_child->left->value;
    #####: 1047:        atom->atom[1] = (uint8_t) i;
    #####: 1048:        atom->atom[2] = (uint8_t) re_node->right->value;
        -: 1049:
    #####: 1050:        atom->atom_length = 3;
    #####: 1051:        atom->forward_code = left_child->left->forward_code;
    #####: 1052:        atom->backward_code = left_child->left->backward_code;
    #####: 1053:        atom->backtrack = 0;
    #####: 1054:        atom->next = *atoms;
        -: 1055:
    #####: 1056:        *atoms = atom;
        -: 1057:      }
        -: 1058:
        -: 1059:      return ERROR_SUCCESS;
        -: 1060:    }
        -: 1061:
    #####: 1062:    if (left_child->left->type == RE_NODE_LITERAL &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1063:        (left_child->right->type == RE_NODE_MASKED_LITERAL))
        -: 1064:    {
    #####: 1065:      for (i = 0; i < 16; i++)
branch  0 never executed
branch  1 never executed
        -: 1066:      {
    #####: 1067:        YR_ATOM_LIST_ITEM* atom = (YR_ATOM_LIST_ITEM*)
call    0 never executed
        -: 1068:            yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -: 1069:
    #####: 1070:        if (atom == NULL)
branch  0 never executed
branch  1 never executed
        -: 1071:          return ERROR_INSUFFICIENT_MEMORY;
        -: 1072:
    #####: 1073:        if (left_child->right->mask == 0xF0)
branch  0 never executed
branch  1 never executed
        -: 1074:          shift = 0;
        -: 1075:        else
        -: 1076:          shift = 4;
        -: 1077:
    #####: 1078:        atom->atom[0] = (uint8_t) left_child->left->value;
    #####: 1079:        atom->atom[1] = (uint8_t)(left_child->right->value | (i << shift));
    #####: 1080:        atom->atom[2] = (uint8_t) re_node->right->value;
        -: 1081:
    #####: 1082:        atom->atom_length = 3;
    #####: 1083:        atom->forward_code = left_child->left->forward_code;
    #####: 1084:        atom->backward_code = left_child->left->backward_code;
    #####: 1085:        atom->backtrack = 0;
    #####: 1086:        atom->next = *atoms;
        -: 1087:
    #####: 1088:        *atoms = atom;
        -: 1089:      }
        -: 1090:
        -: 1091:      return ERROR_SUCCESS;
        -: 1092:    }
        -: 1093:
    #####: 1094:    if (left_grand_child->type == RE_NODE_CONCAT &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1095:        left_grand_child->right->type == RE_NODE_LITERAL &&
branch  0 never executed
branch  1 never executed
    #####: 1096:        (left_child->right->type == RE_NODE_ANY))
        -: 1097:    {
    #####: 1098:      for (i = 0; i < 256; i++)
branch  0 never executed
branch  1 never executed
        -: 1099:      {
    #####: 1100:        YR_ATOM_LIST_ITEM* atom = (YR_ATOM_LIST_ITEM*)
call    0 never executed
        -: 1101:            yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -: 1102:
    #####: 1103:        if (atom == NULL)
branch  0 never executed
branch  1 never executed
        -: 1104:          return ERROR_INSUFFICIENT_MEMORY;
        -: 1105:
    #####: 1106:        atom->atom[0] = (uint8_t) left_grand_child->right->value;
    #####: 1107:        atom->atom[1] = (uint8_t) i;
    #####: 1108:        atom->atom[2] = (uint8_t) re_node->right->value;
        -: 1109:
    #####: 1110:        atom->atom_length = 3;
    #####: 1111:        atom->forward_code = left_grand_child->right->forward_code;
    #####: 1112:        atom->backward_code = left_grand_child->right->backward_code;
    #####: 1113:        atom->backtrack = 0;
    #####: 1114:        atom->next = *atoms;
        -: 1115:
    #####: 1116:        *atoms = atom;
        -: 1117:      }
        -: 1118:
        -: 1119:      return ERROR_SUCCESS;
        -: 1120:    }
        -: 1121:
    #####: 1122:    if (left_grand_child->type == RE_NODE_CONCAT &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1123:        left_grand_child->right->type == RE_NODE_LITERAL &&
branch  0 never executed
branch  1 never executed
    #####: 1124:        (left_child->right->type == RE_NODE_MASKED_LITERAL))
        -: 1125:    {
    #####: 1126:      for (i = 0; i < 16; i++)
branch  0 never executed
branch  1 never executed
        -: 1127:      {
    #####: 1128:        YR_ATOM_LIST_ITEM* atom = (YR_ATOM_LIST_ITEM*)
call    0 never executed
        -: 1129:            yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -: 1130:
    #####: 1131:        if (atom == NULL)
branch  0 never executed
branch  1 never executed
        -: 1132:          return ERROR_INSUFFICIENT_MEMORY;
        -: 1133:
    #####: 1134:        if (left_child->right->mask == 0xF0)
branch  0 never executed
branch  1 never executed
        -: 1135:          shift = 0;
        -: 1136:        else
        -: 1137:          shift = 4;
        -: 1138:
    #####: 1139:        atom->atom[0] = (uint8_t) left_grand_child->right->value;
    #####: 1140:        atom->atom[1] = (uint8_t)(left_child->right->value | (i << shift));
    #####: 1141:        atom->atom[2] = (uint8_t) re_node->right->value;
        -: 1142:
    #####: 1143:        atom->atom_length = 3;
    #####: 1144:        atom->forward_code = left_grand_child->right->forward_code;
    #####: 1145:        atom->backward_code = left_grand_child->right->backward_code;
    #####: 1146:        atom->backtrack = 0;
    #####: 1147:        atom->next = *atoms;
        -: 1148:
    #####: 1149:        *atoms = atom;
        -: 1150:      }
        -: 1151:
        -: 1152:      return ERROR_SUCCESS;
        -: 1153:    }
        -: 1154:
        -: 1155:    return yr_atoms_extract_triplets(left_child, atoms);;
        -: 1156: }
        -: 1157:
        -: 1158://
        -: 1159:// _yr_atoms_extract_from_re
        -: 1160://
        -: 1161:// Extract atoms from a regular expression.
        -: 1162://
        -: 1163:
function yr_atoms_extract_from_re called 0 returned 0% blocks executed 0%
    #####: 1164:int yr_atoms_extract_from_re(
        -: 1165:    YR_ATOMS_CONFIG* config,
        -: 1166:    RE_AST* re_ast,
        -: 1167:    int flags,
        -: 1168:    YR_ATOM_LIST_ITEM** atoms)
        -: 1169:{
    #####: 1170:  ATOM_TREE* atom_tree = (ATOM_TREE*) yr_malloc(sizeof(ATOM_TREE));
call    0 never executed
        -: 1171:  ATOM_TREE_NODE* temp;
        -: 1172:  YR_ATOM_LIST_ITEM* wide_atoms;
        -: 1173:  YR_ATOM_LIST_ITEM* case_insensitive_atoms;
        -: 1174:  YR_ATOM_LIST_ITEM* triplet_atoms;
        -: 1175:
    #####: 1176:  int min_atom_quality = YR_MIN_ATOM_QUALITY;
        -: 1177:
    #####: 1178:  if (atom_tree == NULL)
branch  0 never executed
branch  1 never executed
        -: 1179:    return ERROR_INSUFFICIENT_MEMORY;
        -: 1180:
    #####: 1181:  atom_tree->root_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);
call    0 never executed
        -: 1182:
    #####: 1183:  if (atom_tree->root_node == NULL)
branch  0 never executed
branch  1 never executed
        -: 1184:  {
        -: 1185:    _yr_atoms_tree_destroy(atom_tree);
    #####: 1186:    return ERROR_INSUFFICIENT_MEMORY;
        -: 1187:  }
        -: 1188:
    #####: 1189:  atom_tree->current_leaf = NULL;
        -: 1190:
    #####: 1191:  atom_tree->root_node = _yr_atoms_extract_from_re_node(
call    0 never executed
        -: 1192:      config, re_ast->root_node, atom_tree, atom_tree->root_node);
        -: 1193:
    #####: 1194:  if (atom_tree->root_node == NULL)
branch  0 never executed
branch  1 never executed
        -: 1195:  {
        -: 1196:    _yr_atoms_tree_destroy(atom_tree);
    #####: 1197:    return ERROR_INSUFFICIENT_MEMORY;
        -: 1198:  }
        -: 1199:
    #####: 1200:  if (atom_tree->current_leaf != NULL)
branch  0 never executed
branch  1 never executed
        -: 1201:    _yr_atoms_tree_node_append(atom_tree->root_node, atom_tree->current_leaf);
        -: 1202:
    #####: 1203:  if (atom_tree->root_node->children_head ==
branch  0 never executed
branch  1 never executed
    #####: 1204:      atom_tree->root_node->children_tail)
        -: 1205:  {
        -: 1206:    // The root OR node has a single child, there's no need for the OR node so
        -: 1207:    // we proceed to destroy it and use its child as root.
        -: 1208:
        -: 1209:    temp = atom_tree->root_node;
    #####: 1210:    atom_tree->root_node = atom_tree->root_node->children_head;
    #####: 1211:    yr_free(temp);
call    0 never executed
        -: 1212:  }
        -: 1213:
        -: 1214:  // Initialize atom list
    #####: 1215:  *atoms = NULL;
        -: 1216:
    #####: 1217:  if (atom_tree->root_node != NULL)
branch  0 never executed
branch  1 never executed
        -: 1218:  {
        -: 1219:    // Choose the atoms that will be used.
    #####: 1220:    FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1221:        _yr_atoms_choose(
        -: 1222:            config, atom_tree->root_node, atoms, &min_atom_quality),
        -: 1223:        _yr_atoms_tree_destroy(atom_tree));
        -: 1224:  }
        -: 1225:
        -: 1226:  _yr_atoms_tree_destroy(atom_tree);
        -: 1227:
    #####: 1228:  FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1229:      yr_atoms_extract_triplets(re_ast->root_node, &triplet_atoms),
        -: 1230:      {
        -: 1231:        yr_atoms_list_destroy(*atoms);
        -: 1232:        yr_atoms_list_destroy(triplet_atoms);
        -: 1233:        *atoms = NULL;
        -: 1234:      });
        -: 1235:
    #####: 1236:  if (min_atom_quality < (yr_atoms_min_quality(config, triplet_atoms) >> 1))
branch  0 never executed
branch  1 never executed
        -: 1237:  {
    #####: 1238:    yr_atoms_list_destroy(*atoms);
    #####: 1239:    *atoms = triplet_atoms;
        -: 1240:  }
        -: 1241:  else
        -: 1242:  {
    #####: 1243:    yr_atoms_list_destroy(triplet_atoms);
        -: 1244:  }
        -: 1245:
    #####: 1246:  if (flags & STRING_GFLAGS_WIDE)
branch  0 never executed
branch  1 never executed
        -: 1247:  {
    #####: 1248:    FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1249:        _yr_atoms_wide(*atoms, &wide_atoms),
        -: 1250:        {
        -: 1251:          yr_atoms_list_destroy(*atoms);
        -: 1252:          yr_atoms_list_destroy(wide_atoms);
        -: 1253:          *atoms = NULL;
        -: 1254:        });
        -: 1255:
    #####: 1256:    if (flags & STRING_GFLAGS_ASCII)
branch  0 never executed
branch  1 never executed
        -: 1257:    {
    #####: 1258:      *atoms = _yr_atoms_list_concat(*atoms, wide_atoms);
        -: 1259:    }
        -: 1260:    else
        -: 1261:    {
    #####: 1262:      yr_atoms_list_destroy(*atoms);
    #####: 1263:      *atoms = wide_atoms;
        -: 1264:    }
        -: 1265:  }
        -: 1266:
    #####: 1267:  if (flags & STRING_GFLAGS_NO_CASE)
branch  0 never executed
branch  1 never executed
        -: 1268:  {
    #####: 1269:    FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1270:        _yr_atoms_case_insensitive(*atoms, &case_insensitive_atoms),
        -: 1271:        {
        -: 1272:          yr_atoms_list_destroy(*atoms);
        -: 1273:          yr_atoms_list_destroy(case_insensitive_atoms);
        -: 1274:          *atoms = NULL;
        -: 1275:        });
        -: 1276:
    #####: 1277:    *atoms = _yr_atoms_list_concat(*atoms, case_insensitive_atoms);
        -: 1278:  }
        -: 1279:
        -: 1280:  // No atoms has been extracted, let's add a zero-length atom.
        -: 1281:
    #####: 1282:  if (*atoms == NULL)
branch  0 never executed
branch  1 never executed
        -: 1283:  {
    #####: 1284:    *atoms = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
call    0 never executed
        -: 1285:
    #####: 1286:    if (*atoms == NULL)
branch  0 never executed
branch  1 never executed
        -: 1287:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1288:
    #####: 1289:    (*atoms)->atom_length = 0;
    #####: 1290:    (*atoms)->backtrack = 0;
    #####: 1291:    (*atoms)->forward_code = re_ast->root_node->forward_code;
    #####: 1292:    (*atoms)->backward_code = NULL;
    #####: 1293:    (*atoms)->next = NULL;
        -: 1294:  }
        -: 1295:
        -: 1296:  return ERROR_SUCCESS;
        -: 1297:}
        -: 1298:
        -: 1299:
        -: 1300://
        -: 1301:// yr_atoms_extract_from_string
        -: 1302://
        -: 1303:// Extract atoms from a string.
        -: 1304://
        -: 1305:
function yr_atoms_extract_from_string called 0 returned 0% blocks executed 0%
    #####: 1306:int yr_atoms_extract_from_string(
        -: 1307:    YR_ATOMS_CONFIG* config,
        -: 1308:    uint8_t* string,
        -: 1309:    int32_t string_length,
        -: 1310:    int flags,
        -: 1311:    YR_ATOM_LIST_ITEM** atoms)
        -: 1312:{
        -: 1313:  YR_ATOM_LIST_ITEM* item;
        -: 1314:  YR_ATOM_LIST_ITEM* case_insensitive_atoms;
        -: 1315:  YR_ATOM_LIST_ITEM* xor_atoms;
        -: 1316:  YR_ATOM_LIST_ITEM* wide_atoms;
        -: 1317:
        -: 1318:  int max_quality;
        -: 1319:  int i, j, length;
        -: 1320:
    #####: 1321:  item = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
call    0 never executed
        -: 1322:
    #####: 1323:  if (item == NULL)
branch  0 never executed
branch  1 never executed
        -: 1324:    return ERROR_INSUFFICIENT_MEMORY;
        -: 1325:
    #####: 1326:  item->forward_code = NULL;
    #####: 1327:  item->backward_code = NULL;
    #####: 1328:  item->next = NULL;
    #####: 1329:  item->backtrack = 0;
        -: 1330:
    #####: 1331:  length = yr_min(string_length, YR_MAX_ATOM_LENGTH);
        -: 1332:
    #####: 1333:  for (i = 0; i < length; i++)
branch  0 never executed
branch  1 never executed
    #####: 1334:    item->atom[i] = string[i];
        -: 1335:
    #####: 1336:  item->atom_length = i;
        -: 1337:
    #####: 1338:  max_quality = config->get_atom_quality(config, string, length);
call    0 never executed
        -: 1339:
    #####: 1340:  for (i = YR_MAX_ATOM_LENGTH;
branch  0 never executed
branch  1 never executed
    #####: 1341:       i < string_length && max_quality < YR_MAX_ATOM_QUALITY;
    #####: 1342:       i++)
        -: 1343:  {
    #####: 1344:    int quality = config->get_atom_quality(
call    0 never executed
        -: 1345:        config,
    #####: 1346:        string + i - YR_MAX_ATOM_LENGTH + 1,
        -: 1347:        YR_MAX_ATOM_LENGTH);
        -: 1348:
    #####: 1349:    if (quality > max_quality)
branch  0 never executed
branch  1 never executed
        -: 1350:    {
    #####: 1351:      for (j = 0; j < YR_MAX_ATOM_LENGTH; j++)
branch  0 never executed
branch  1 never executed
    #####: 1352:        item->atom[j] = string[i + j - YR_MAX_ATOM_LENGTH + 1];
        -: 1353:
    #####: 1354:      item->backtrack = i - YR_MAX_ATOM_LENGTH + 1;
        -: 1355:      max_quality = quality;
        -: 1356:    }
        -: 1357:  }
        -: 1358:
    #####: 1359:  *atoms = item;
        -: 1360:
    #####: 1361:  if (flags & STRING_GFLAGS_WIDE)
branch  0 never executed
branch  1 never executed
        -: 1362:  {
    #####: 1363:    FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1364:        _yr_atoms_wide(*atoms, &wide_atoms),
        -: 1365:        {
        -: 1366:          yr_atoms_list_destroy(*atoms);
        -: 1367:          yr_atoms_list_destroy(wide_atoms);
        -: 1368:          *atoms = NULL;
        -: 1369:        });
        -: 1370:
    #####: 1371:    if (flags & STRING_GFLAGS_ASCII)
branch  0 never executed
branch  1 never executed
        -: 1372:    {
    #####: 1373:      *atoms = _yr_atoms_list_concat(*atoms, wide_atoms);
        -: 1374:    }
        -: 1375:    else
        -: 1376:    {
    #####: 1377:      yr_atoms_list_destroy(*atoms);
    #####: 1378:      *atoms = wide_atoms;
        -: 1379:    }
        -: 1380:  }
        -: 1381:
    #####: 1382:  if (flags & STRING_GFLAGS_NO_CASE)
branch  0 never executed
branch  1 never executed
        -: 1383:  {
    #####: 1384:    FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1385:        _yr_atoms_case_insensitive(*atoms, &case_insensitive_atoms),
        -: 1386:        {
        -: 1387:          yr_atoms_list_destroy(*atoms);
        -: 1388:          yr_atoms_list_destroy(case_insensitive_atoms);
        -: 1389:          *atoms = NULL;
        -: 1390:        });
        -: 1391:
    #####: 1392:    *atoms = _yr_atoms_list_concat(*atoms, case_insensitive_atoms);
        -: 1393:  }
        -: 1394:
    #####: 1395:  if (flags & STRING_GFLAGS_XOR)
branch  0 never executed
branch  1 never executed
        -: 1396:  {
    #####: 1397:    FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1398:      _yr_atoms_xor(*atoms, &xor_atoms),
        -: 1399:      {
        -: 1400:        yr_atoms_list_destroy(*atoms);
        -: 1401:        yr_atoms_list_destroy(xor_atoms);
        -: 1402:        *atoms = NULL;
        -: 1403:      });
        -: 1404:
    #####: 1405:    if (flags & STRING_GFLAGS_ASCII ||
branch  0 never executed
branch  1 never executed
    #####: 1406:        flags & STRING_GFLAGS_WIDE ||
        -: 1407:        flags & STRING_GFLAGS_NO_CASE)
        -: 1408:    {
    #####: 1409:      *atoms = _yr_atoms_list_concat(*atoms, xor_atoms);
        -: 1410:    }
        -: 1411:    else
        -: 1412:    {
    #####: 1413:      yr_atoms_list_destroy(*atoms);
    #####: 1414:      *atoms = xor_atoms;
        -: 1415:    }
        -: 1416:
        -: 1417:  }
        -: 1418:
        -: 1419:  return ERROR_SUCCESS;
        -: 1420:}
        -: 1421:
        -: 1422:
        -: 1423://
        -: 1424:// yr_atoms_tree_node_print
        -: 1425://
        -: 1426:// Prints an atom tree node. Used only for debugging purposes.
        -: 1427://
        -: 1428:
function yr_atoms_tree_node_print called 0 returned 0% blocks executed 0%
    #####: 1429:void yr_atoms_tree_node_print(
        -: 1430:    ATOM_TREE_NODE* node)
        -: 1431:{
        -: 1432:  ATOM_TREE_NODE* child;
        -: 1433:  int i;
        -: 1434:
    #####: 1435:  if (node == NULL)
branch  0 never executed
branch  1 never executed
        -: 1436:  {
        -: 1437:    printf("Empty tree node\n");
        -: 1438:    return;
        -: 1439:  }
        -: 1440:
    #####: 1441:  switch(node->type)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 1442:  {
        -: 1443:  case ATOM_TREE_LEAF:
    #####: 1444:    for (i = 0; i < node->atom_length; i++)
branch  0 never executed
branch  1 never executed
    #####: 1445:      printf("%02X", node->atom[i]);
        -: 1446:    break;
        -: 1447:
    #####: 1448:  case ATOM_TREE_AND:
        -: 1449:  case ATOM_TREE_OR:
    #####: 1450:    if (node->type == ATOM_TREE_AND)
branch  0 never executed
branch  1 never executed
        -: 1451:      printf("AND");
        -: 1452:    else
        -: 1453:      printf("OR");
        -: 1454:    printf("(");
    #####: 1455:    child = node->children_head;
    #####: 1456:    while (child != NULL)
branch  0 never executed
branch  1 never executed
        -: 1457:    {
    #####: 1458:      yr_atoms_tree_node_print(child);
call    0 never executed
    #####: 1459:      child = child->next_sibling;
    #####: 1460:      if (child != NULL)
branch  0 never executed
branch  1 never executed
        -: 1461:        printf(",");
        -: 1462:    }
        -: 1463:    printf(")");
        -: 1464:    break;
        -: 1465:  }
        -: 1466:}
