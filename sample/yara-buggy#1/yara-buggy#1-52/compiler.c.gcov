        -:    0:Source:compiler.c
        -:    0:Graph:/home/workspace/libyara/.libs/compiler.gcno
        -:    0:Data:/home/workspace/libyara/.libs/compiler.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:Copyright (c) 2013-2018. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <assert.h>
        -:   31:#include <fcntl.h>
        -:   32:#include <stdbool.h>
        -:   33:#include <stddef.h>
        -:   34:#include <stdio.h>
        -:   35:#include <string.h>
        -:   36:#include <sys/stat.h>
        -:   37:
        -:   38:#ifdef _MSC_VER
        -:   39:#include <io.h>
        -:   40:#include <share.h>
        -:   41:#else
        -:   42:#include <unistd.h>
        -:   43:#endif
        -:   44:
        -:   45:#include <yara/libyara.h>
        -:   46:#include <yara/utils.h>
        -:   47:#include <yara/compiler.h>
        -:   48:#include <yara/exec.h>
        -:   49:#include <yara/error.h>
        -:   50:#include <yara/mem.h>
        -:   51:#include <yara/object.h>
        -:   52:#include <yara/lexer.h>
        -:   53:#include <yara/strutils.h>
        -:   54:
        -:   55:
function _yr_compiler_default_include_free called 0 returned 0% blocks executed 0%
    #####:   56:static void _yr_compiler_default_include_free(
        -:   57:    const char* callback_result_ptr,
        -:   58:    void* user_data)
        -:   59:{
    #####:   60:  if (callback_result_ptr != NULL)
branch  0 never executed
branch  1 never executed
        -:   61:  {
    #####:   62:    yr_free((void*)callback_result_ptr);
call    0 never executed
        -:   63:  }
    #####:   64:}
        -:   65:
        -:   66:
function _yr_compiler_default_include_callback called 0 returned 0% blocks executed 0%
    #####:   67:const char* _yr_compiler_default_include_callback(
        -:   68:    const char* include_name,
        -:   69:    const char* calling_rule_filename,
        -:   70:    const char* calling_rule_namespace,
        -:   71:    void* user_data)
        -:   72:{
        -:   73:  #ifndef _MSC_VER
        -:   74:  struct stat stbuf;
        -:   75:  #endif
        -:   76:
        -:   77:  char* file_buffer;
        -:   78:
        -:   79:  #ifdef _MSC_VER
        -:   80:  long file_size;
        -:   81:  #else
        -:   82:  off_t file_size;
        -:   83:  #endif
        -:   84:
        -:   85:  int fd = -1;
        -:   86:
        -:   87:  #if defined(_MSC_VER)
        -:   88:  _sopen_s(&fd, include_name, _O_RDONLY | _O_BINARY, _SH_DENYRW, _S_IREAD);
        -:   89:  #elif defined(_WIN32) || defined(__CYGWIN__)
        -:   90:  fd = open(include_name, O_RDONLY | O_BINARY);
        -:   91:  #else
        -:   92:  fd = open(include_name, O_RDONLY);
        -:   93:  #endif
        -:   94:
    #####:   95:  if (fd == -1)
branch  0 never executed
branch  1 never executed
        -:   96:    return NULL;
        -:   97:
        -:   98:  #ifdef _MSC_VER
        -:   99:  file_size = _filelength(fd);
        -:  100:  if (file_size == -1)
        -:  101:  {
        -:  102:    _close(fd);
        -:  103:    return NULL;
        -:  104:  }
        -:  105:  #else
    #####:  106:  if ((fstat(fd, &stbuf) != 0) || (!S_ISREG(stbuf.st_mode)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  107:  {
    #####:  108:    close(fd);
call    0 never executed
    #####:  109:    return NULL;
        -:  110:  }
    #####:  111:  file_size = stbuf.st_size;
        -:  112:  #endif
        -:  113:
    #####:  114:  file_buffer = (char*) yr_malloc((size_t) file_size + 1);
call    0 never executed
        -:  115:
    #####:  116:  if (file_buffer == NULL)
branch  0 never executed
branch  1 never executed
        -:  117:  {
        -:  118:    #ifdef _MSC_VER
        -:  119:    _close(fd);
        -:  120:    #else
    #####:  121:    close(fd);
call    0 never executed
        -:  122:    #endif
        -:  123:
    #####:  124:    return NULL;
        -:  125:  }
        -:  126:
    #####:  127:  if (file_size != read(fd, file_buffer, (size_t) file_size))
branch  0 never executed
branch  1 never executed
        -:  128:  {
    #####:  129:    yr_free(file_buffer);
call    0 never executed
        -:  130:
        -:  131:    #ifdef _MSC_VER
        -:  132:    _close(fd);
        -:  133:    #else
    #####:  134:    close(fd);
call    0 never executed
        -:  135:    #endif
        -:  136:
    #####:  137:    return NULL;
        -:  138:  }
        -:  139:  else
        -:  140:  {
    #####:  141:    file_buffer[file_size] = '\0';
        -:  142:  }
        -:  143:
        -:  144:  #ifdef _MSC_VER
        -:  145:  _close(fd);
        -:  146:  #else
    #####:  147:  close(fd);
call    0 never executed
        -:  148:  #endif
        -:  149:
    #####:  150:  return file_buffer;
        -:  151:}
        -:  152:
        -:  153:
function yr_compiler_create called 0 returned 0% blocks executed 0%
    #####:  154:YR_API int yr_compiler_create(
        -:  155:    YR_COMPILER** compiler)
        -:  156:{
        -:  157:  int result;
        -:  158:  YR_COMPILER* new_compiler;
        -:  159:
    #####:  160:  new_compiler = (YR_COMPILER*) yr_calloc(1, sizeof(YR_COMPILER));
call    0 never executed
        -:  161:
    #####:  162:  if (new_compiler == NULL)
branch  0 never executed
branch  1 never executed
        -:  163:    return ERROR_INSUFFICIENT_MEMORY;
        -:  164:
    #####:  165:  new_compiler->errors = 0;
    #####:  166:  new_compiler->callback = NULL;
    #####:  167:  new_compiler->include_callback = _yr_compiler_default_include_callback;
    #####:  168:  new_compiler->incl_clbk_user_data = NULL;
    #####:  169:  new_compiler->include_free = _yr_compiler_default_include_free;
    #####:  170:  new_compiler->re_ast_callback = NULL;
    #####:  171:  new_compiler->re_ast_clbk_user_data = NULL;
    #####:  172:  new_compiler->last_error = ERROR_SUCCESS;
    #####:  173:  new_compiler->last_error_line = 0;
    #####:  174:  new_compiler->current_line = 0;
    #####:  175:  new_compiler->file_name_stack_ptr = 0;
    #####:  176:  new_compiler->fixup_stack_head = NULL;
    #####:  177:  new_compiler->loop_depth = 0;
    #####:  178:  new_compiler->loop_for_of_mem_offset = -1;
    #####:  179:  new_compiler->compiled_rules_arena = NULL;
    #####:  180:  new_compiler->namespaces_count = 0;
    #####:  181:  new_compiler->current_rule = NULL;
    #####:  182:  new_compiler->atoms_config.get_atom_quality = yr_atoms_heuristic_quality;
    #####:  183:  new_compiler->atoms_config.quality_warning_threshold = \
        -:  184:      YR_ATOM_QUALITY_WARNING_THRESHOLD;
        -:  185:
    #####:  186:  result = yr_hash_table_create(10007, &new_compiler->rules_table);
call    0 never executed
        -:  187:
    #####:  188:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  189:    result = yr_hash_table_create(10007, &new_compiler->objects_table);
call    0 never executed
        -:  190:
    #####:  191:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  192:    result = yr_hash_table_create(101, &new_compiler->strings_table);
call    0 never executed
        -:  193:
    #####:  194:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  195:    result = yr_arena_create(
call    0 never executed
        -:  196:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->sz_arena);
        -:  197:
    #####:  198:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  199:    result = yr_arena_create(
call    0 never executed
        -:  200:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->rules_arena);
        -:  201:
    #####:  202:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  203:    result = yr_arena_create(
call    0 never executed
        -:  204:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->strings_arena);
        -:  205:
    #####:  206:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  207:      result = yr_arena_create(
call    0 never executed
        -:  208:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->code_arena);
        -:  209:
    #####:  210:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  211:    result = yr_arena_create(
call    0 never executed
        -:  212:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->re_code_arena);
        -:  213:
    #####:  214:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  215:    result = yr_arena_create(
call    0 never executed
        -:  216:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->externals_arena);
        -:  217:
    #####:  218:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  219:    result = yr_arena_create(
call    0 never executed
        -:  220:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->namespaces_arena);
        -:  221:
    #####:  222:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  223:    result = yr_arena_create(
call    0 never executed
        -:  224:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->metas_arena);
        -:  225:
    #####:  226:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  227:    result = yr_arena_create(
call    0 never executed
        -:  228:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->automaton_arena);
        -:  229:
    #####:  230:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  231:    result = yr_arena_create(
call    0 never executed
        -:  232:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->matches_arena);
        -:  233:
    #####:  234:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  235:    result = yr_ac_automaton_create(&new_compiler->automaton);
call    0 never executed
        -:  236:
    #####:  237:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  238:  {
    #####:  239:    *compiler = new_compiler;
        -:  240:  }
        -:  241:  else  // if error, do cleanup
        -:  242:  {
    #####:  243:    yr_compiler_destroy(new_compiler);
call    0 never executed
        -:  244:  }
        -:  245:
        -:  246:  return result;
        -:  247:}
        -:  248:
        -:  249:
function yr_compiler_destroy called 0 returned 0% blocks executed 0%
    #####:  250:YR_API void yr_compiler_destroy(
        -:  251:    YR_COMPILER* compiler)
        -:  252:{
        -:  253:  YR_FIXUP* fixup;
        -:  254:  int i;
        -:  255:
    #####:  256:  yr_arena_destroy(compiler->compiled_rules_arena);
call    0 never executed
    #####:  257:  yr_arena_destroy(compiler->sz_arena);
call    0 never executed
    #####:  258:  yr_arena_destroy(compiler->rules_arena);
call    0 never executed
    #####:  259:  yr_arena_destroy(compiler->strings_arena);
call    0 never executed
    #####:  260:  yr_arena_destroy(compiler->code_arena);
call    0 never executed
    #####:  261:  yr_arena_destroy(compiler->re_code_arena);
call    0 never executed
    #####:  262:  yr_arena_destroy(compiler->externals_arena);
call    0 never executed
    #####:  263:  yr_arena_destroy(compiler->namespaces_arena);
call    0 never executed
    #####:  264:  yr_arena_destroy(compiler->metas_arena);
call    0 never executed
    #####:  265:  yr_arena_destroy(compiler->automaton_arena);
call    0 never executed
    #####:  266:  yr_arena_destroy(compiler->matches_arena);
call    0 never executed
        -:  267:
    #####:  268:  yr_ac_automaton_destroy(compiler->automaton);
call    0 never executed
        -:  269:
    #####:  270:  yr_hash_table_destroy(
call    0 never executed
        -:  271:      compiler->rules_table,
        -:  272:      NULL);
        -:  273:
    #####:  274:  yr_hash_table_destroy(
call    0 never executed
        -:  275:      compiler->strings_table,
        -:  276:      NULL);
        -:  277:
    #####:  278:  yr_hash_table_destroy(
call    0 never executed
        -:  279:      compiler->objects_table,
        -:  280:      (YR_HASH_TABLE_FREE_VALUE_FUNC) yr_object_destroy);
        -:  281:
    #####:  282:  if (compiler->  atoms_config.free_quality_table)
branch  0 never executed
branch  1 never executed
    #####:  283:    yr_free(compiler->atoms_config.quality_table);
call    0 never executed
        -:  284:
    #####:  285:  for (i = 0; i < compiler->file_name_stack_ptr; i++)
branch  0 never executed
branch  1 never executed
    #####:  286:    yr_free(compiler->file_name_stack[i]);
call    0 never executed
        -:  287:
    #####:  288:  fixup = compiler->fixup_stack_head;
        -:  289:
    #####:  290:  while (fixup != NULL)
branch  0 never executed
branch  1 never executed
        -:  291:  {
    #####:  292:    YR_FIXUP* next_fixup = fixup->next;
    #####:  293:    yr_free(fixup);
call    0 never executed
        -:  294:    fixup = next_fixup;
        -:  295:  }
        -:  296:
    #####:  297:  yr_free(compiler);
call    0 never executed
    #####:  298:}
        -:  299:
        -:  300:
function yr_compiler_set_callback called 0 returned 0% blocks executed 0%
    #####:  301:YR_API void yr_compiler_set_callback(
        -:  302:    YR_COMPILER* compiler,
        -:  303:    YR_COMPILER_CALLBACK_FUNC callback,
        -:  304:    void* user_data)
        -:  305:{
    #####:  306:  compiler->callback = callback;
    #####:  307:  compiler->user_data = user_data;
    #####:  308:}
        -:  309:
        -:  310:
function yr_compiler_set_include_callback called 0 returned 0% blocks executed 0%
    #####:  311:YR_API void yr_compiler_set_include_callback(
        -:  312:    YR_COMPILER* compiler,
        -:  313:    YR_COMPILER_INCLUDE_CALLBACK_FUNC include_callback,
        -:  314:    YR_COMPILER_INCLUDE_FREE_FUNC include_free,
        -:  315:    void* user_data)
        -:  316:{
    #####:  317:  compiler->include_callback = include_callback;
    #####:  318:  compiler->include_free = include_free;
    #####:  319:  compiler->incl_clbk_user_data = user_data;
    #####:  320:}
        -:  321:
        -:  322:
function yr_compiler_set_re_ast_callback called 0 returned 0% blocks executed 0%
    #####:  323:YR_API void yr_compiler_set_re_ast_callback(
        -:  324:    YR_COMPILER* compiler,
        -:  325:    YR_COMPILER_RE_AST_CALLBACK_FUNC re_ast_callback,
        -:  326:    void* user_data)
        -:  327:{
    #####:  328:  compiler->re_ast_callback = re_ast_callback;
    #####:  329:  compiler->re_ast_clbk_user_data = user_data;
    #####:  330:}
        -:  331:
        -:  332:
        -:  333://
        -:  334:// yr_compiler_set_atom_quality_table
        -:  335://
        -:  336:// This function allows to specify an atom quality table to be used by the
        -:  337:// compiler for choosing the best atoms from regular expressions and strings.
        -:  338:// When a quality table is set, the compiler uses yr_atoms_table_quality
        -:  339:// instead of yr_atoms_heuristic_quality for computing atom quality. The table
        -:  340:// has an arbitary number of entries, each composed of YR_MAX_ATOM_LENGTH + 1
        -:  341:// bytes. The first YR_MAX_ATOM_LENGTH bytes from each entry are the atom's
        -:  342:// ones, and the remaining byte is a value in the range 0-255 determining the
        -:  343:// atom's quality. Entries must be lexicografically sorted by atom in ascending
        -:  344:// order.
        -:  345://
        -:  346://  [ atom (YR_MAX_ATOM_LENGTH bytes) ] [ quality (1 byte) ]
        -:  347://
        -:  348://  [ 00 00 .. 00 00 ] [ 00 ]
        -:  349://  [ 00 00 .. 00 01 ] [ 45 ]
        -:  350://  [ 00 00 .. 00 02 ] [ 13 ]
        -:  351://  ...
        -:  352://  [ FF FF .. FF FF ] [ 03 ]
        -:  353://
        -:  354:// The "table" argument must point to a buffer containing the quality in
        -:  355:// the format explained above, and "entries" must contain the number of entries
        -:  356:// in the table. The table can not be freed while the compiler is in use, the
        -:  357:// caller is responsible for freeing the table.
        -:  358://
        -:  359:// The "warning_threshold" argument must be a number between 0 and 255, if some
        -:  360:// atom choosen for a string have a quality below the specified threshold a
        -:  361:// warning like "<string> is slowing down scanning" is shown.
        -:  362:
function yr_compiler_set_atom_quality_table called 0 returned 0% blocks executed 0%
    #####:  363:YR_API void yr_compiler_set_atom_quality_table(
        -:  364:    YR_COMPILER* compiler,
        -:  365:    const void* table,
        -:  366:    int entries,
        -:  367:    unsigned char warning_threshold)
        -:  368:{
    #####:  369:  compiler->atoms_config.free_quality_table = false;
    #####:  370:  compiler->atoms_config.quality_warning_threshold = warning_threshold;
    #####:  371:  compiler->atoms_config.get_atom_quality = yr_atoms_table_quality;
    #####:  372:  compiler->atoms_config.quality_table_entries = entries;
    #####:  373:  compiler->atoms_config.quality_table = \
        -:  374:      (YR_ATOM_QUALITY_TABLE_ENTRY*) table;
    #####:  375:}
        -:  376:
        -:  377://
        -:  378:// yr_compiler_set_atom_quality_table
        -:  379://
        -:  380:// Load an atom quality table from a file. The file's content must have the
        -:  381:// format explained in the decription for yr_compiler_set_atom_quality_table.
        -:  382://
        -:  383:
function yr_compiler_load_atom_quality_table called 0 returned 0% blocks executed 0%
    #####:  384:YR_API int yr_compiler_load_atom_quality_table(
        -:  385:    YR_COMPILER* compiler,
        -:  386:    const char* filename,
        -:  387:    unsigned char warning_threshold)
        -:  388:{
    #####:  389:  FILE* fh = fopen(filename, "rb");
call    0 never executed
        -:  390:
    #####:  391:  if (fh == NULL)
branch  0 never executed
branch  1 never executed
        -:  392:    return ERROR_COULD_NOT_OPEN_FILE;
        -:  393:
    #####:  394:  fseek(fh, 0L, SEEK_END);
call    0 never executed
    #####:  395:  long file_size = ftell(fh);
call    0 never executed
    #####:  396:  fseek(fh, 0L, SEEK_SET);
call    0 never executed
        -:  397:
    #####:  398:  void* table = yr_malloc(file_size);
call    0 never executed
        -:  399:
    #####:  400:  if (table == NULL)
branch  0 never executed
branch  1 never executed
        -:  401:  {
    #####:  402:    fclose(fh);
call    0 never executed
    #####:  403:    return ERROR_INSUFFICIENT_MEMORY;
        -:  404:  }
        -:  405:
    #####:  406:  int entries = file_size / sizeof(YR_ATOM_QUALITY_TABLE_ENTRY);
        -:  407:
    #####:  408:  if (fread(table, sizeof(YR_ATOM_QUALITY_TABLE_ENTRY), entries, fh) != entries)
branch  0 never executed
branch  1 never executed
        -:  409:  {
    #####:  410:    fclose(fh);
call    0 never executed
    #####:  411:    yr_free(table);
call    0 never executed
    #####:  412:    return ERROR_COULD_NOT_READ_FILE;
        -:  413:  }
        -:  414:
    #####:  415:  fclose(fh);
call    0 never executed
        -:  416:
    #####:  417:  yr_compiler_set_atom_quality_table(
call    0 never executed
        -:  418:      compiler, table, entries, warning_threshold);
        -:  419:
    #####:  420:  compiler->atoms_config.free_quality_table = true;
        -:  421:
    #####:  422:  return ERROR_SUCCESS;
        -:  423:}
        -:  424:
        -:  425:
function _yr_compiler_push_file_name called 0 returned 0% blocks executed 0%
    #####:  426:int _yr_compiler_push_file_name(
        -:  427:    YR_COMPILER* compiler,
        -:  428:    const char* file_name)
        -:  429:{
        -:  430:  char* str;
        -:  431:  int i;
        -:  432:
    #####:  433:  for (i = 0; i < compiler->file_name_stack_ptr; i++)
branch  0 never executed
branch  1 never executed
        -:  434:  {
    #####:  435:    if (strcmp(file_name, compiler->file_name_stack[i]) == 0)
branch  0 never executed
branch  1 never executed
        -:  436:      return ERROR_INCLUDES_CIRCULAR_REFERENCE;
        -:  437:  }
        -:  438:
    #####:  439:  if (compiler->file_name_stack_ptr == YR_MAX_INCLUDE_DEPTH)
branch  0 never executed
branch  1 never executed
        -:  440:    return ERROR_INCLUDE_DEPTH_EXCEEDED;
        -:  441:
    #####:  442:  str = yr_strdup(file_name);
call    0 never executed
        -:  443:
    #####:  444:  if (str == NULL)
branch  0 never executed
branch  1 never executed
        -:  445:    return ERROR_INSUFFICIENT_MEMORY;
        -:  446:
    #####:  447:  compiler->file_name_stack[compiler->file_name_stack_ptr] = str;
    #####:  448:  compiler->file_name_stack_ptr++;
        -:  449:
    #####:  450:  return ERROR_SUCCESS;
        -:  451:}
        -:  452:
        -:  453:
function _yr_compiler_pop_file_name called 0 returned 0% blocks executed 0%
    #####:  454:void _yr_compiler_pop_file_name(
        -:  455:    YR_COMPILER* compiler)
        -:  456:{
    #####:  457:  if (compiler->file_name_stack_ptr > 0)
branch  0 never executed
branch  1 never executed
        -:  458:  {
    #####:  459:    compiler->file_name_stack_ptr--;
    #####:  460:    yr_free(compiler->file_name_stack[compiler->file_name_stack_ptr]);
call    0 never executed
    #####:  461:    compiler->file_name_stack[compiler->file_name_stack_ptr] = NULL;
        -:  462:  }
    #####:  463:}
        -:  464:
        -:  465:
function yr_compiler_get_current_file_name called 0 returned 0% blocks executed 0%
    #####:  466:YR_API char* yr_compiler_get_current_file_name(
        -:  467:    YR_COMPILER* compiler)
        -:  468:{
    #####:  469:  if (compiler->file_name_stack_ptr > 0)
branch  0 never executed
branch  1 never executed
        -:  470:  {
    #####:  471:    return compiler->file_name_stack[compiler->file_name_stack_ptr - 1];
        -:  472:  }
        -:  473:  else
        -:  474:  {
        -:  475:    return NULL;
        -:  476:  }
        -:  477:}
        -:  478:
        -:  479:
function _yr_compiler_set_namespace called 0 returned 0% blocks executed 0%
    #####:  480:static int _yr_compiler_set_namespace(
        -:  481:    YR_COMPILER* compiler,
        -:  482:    const char* namespace_)
        -:  483:{
        -:  484:  YR_NAMESPACE* ns;
        -:  485:
        -:  486:  char* ns_name;
        -:  487:  int result;
        -:  488:  int i;
        -:  489:  bool found;
        -:  490:
    #####:  491:  ns = (YR_NAMESPACE*) yr_arena_base_address(compiler->namespaces_arena);
call    0 never executed
        -:  492:  found = false;
        -:  493:
    #####:  494:  for (i = 0; i < compiler->namespaces_count; i++)
branch  0 never executed
branch  1 never executed
        -:  495:  {
    #####:  496:    if (strcmp(ns->name, namespace_) == 0)
branch  0 never executed
branch  1 never executed
        -:  497:    {
        -:  498:      found = true;
        -:  499:      break;
        -:  500:    }
        -:  501:
    #####:  502:    ns = (YR_NAMESPACE*) yr_arena_next_address(
call    0 never executed
        -:  503:        compiler->namespaces_arena,
        -:  504:        ns,
        -:  505:        sizeof(YR_NAMESPACE));
        -:  506:  }
        -:  507:
    #####:  508:  if (!found)
branch  0 never executed
branch  1 never executed
        -:  509:  {
    #####:  510:    result = yr_arena_write_string(
call    0 never executed
        -:  511:        compiler->sz_arena,
        -:  512:        namespace_,
        -:  513:        &ns_name);
        -:  514:
    #####:  515:    if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  516:      result = yr_arena_allocate_struct(
call    0 never executed
        -:  517:          compiler->namespaces_arena,
        -:  518:          sizeof(YR_NAMESPACE),
        -:  519:          (void**) &ns,
        -:  520:          offsetof(YR_NAMESPACE, name),
        -:  521:          EOL);
        -:  522:
    #####:  523:    if (result != ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  524:      return result;
        -:  525:
    #####:  526:    ns->name = ns_name;
        -:  527:
    #####:  528:    for (i = 0; i < YR_MAX_THREADS; i++)
branch  0 never executed
branch  1 never executed
    #####:  529:      ns->t_flags[i] = 0;
        -:  530:
    #####:  531:    compiler->namespaces_count++;
        -:  532:  }
        -:  533:
    #####:  534:  compiler->current_namespace = ns;
    #####:  535:  return ERROR_SUCCESS;
        -:  536:}
        -:  537:
        -:  538:
function yr_compiler_add_file called 0 returned 0% blocks executed 0%
    #####:  539:YR_API int yr_compiler_add_file(
        -:  540:    YR_COMPILER* compiler,
        -:  541:    FILE* rules_file,
        -:  542:    const char* namespace_,
        -:  543:    const char* file_name)
        -:  544:{
        -:  545:  // Don't allow yr_compiler_add_file() after
        -:  546:  // yr_compiler_get_rules() has been called.
        -:  547:
    #####:  548:  assert(compiler->compiled_rules_arena == NULL);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  549:
        -:  550:  // Don't allow calls to yr_compiler_add_file() if a previous call to
        -:  551:  // yr_compiler_add_XXXX failed.
        -:  552:
    #####:  553:  assert(compiler->errors == 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  554:
    #####:  555:  if (file_name != NULL)
branch  0 never executed
branch  1 never executed
    #####:  556:    _yr_compiler_push_file_name(compiler, file_name);
call    0 never executed
        -:  557:
    #####:  558:  if (namespace_ != NULL)
branch  0 never executed
branch  1 never executed
    #####:  559:    compiler->last_error = _yr_compiler_set_namespace(compiler, namespace_);
call    0 never executed
        -:  560:  else
    #####:  561:    compiler->last_error = _yr_compiler_set_namespace(compiler, "default");
call    0 never executed
        -:  562:
    #####:  563:  if (compiler->last_error != ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  564:  {
    #####:  565:    compiler->errors++;
    #####:  566:    return compiler->errors;
        -:  567:  }
        -:  568:
    #####:  569:  return yr_lex_parse_rules_file(rules_file, compiler);
call    0 never executed
        -:  570:}
        -:  571:
        -:  572:
function yr_compiler_add_fd called 0 returned 0% blocks executed 0%
    #####:  573:YR_API int yr_compiler_add_fd(
        -:  574:    YR_COMPILER* compiler,
        -:  575:    YR_FILE_DESCRIPTOR rules_fd,
        -:  576:    const char* namespace_,
        -:  577:    const char* file_name)
        -:  578:{
        -:  579:  // Don't allow yr_compiler_add_fd() after
        -:  580:  // yr_compiler_get_rules() has been called.
        -:  581:
    #####:  582:  assert(compiler->compiled_rules_arena == NULL);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  583:
        -:  584:  // Don't allow calls to yr_compiler_add_fd() if a previous call to
        -:  585:  // yr_compiler_add_XXXX failed.
        -:  586:
    #####:  587:  assert(compiler->errors == 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  588:
    #####:  589:  if (file_name != NULL)
branch  0 never executed
branch  1 never executed
    #####:  590:    _yr_compiler_push_file_name(compiler, file_name);
call    0 never executed
        -:  591:
    #####:  592:  if (namespace_ != NULL)
branch  0 never executed
branch  1 never executed
    #####:  593:    compiler->last_error = _yr_compiler_set_namespace(compiler, namespace_);
call    0 never executed
        -:  594:  else
    #####:  595:    compiler->last_error = _yr_compiler_set_namespace(compiler, "default");
call    0 never executed
        -:  596:
    #####:  597:  if (compiler->last_error != ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  598:  {
    #####:  599:    compiler->errors++;
    #####:  600:    return compiler->errors;
        -:  601:  }
        -:  602:
    #####:  603:  return yr_lex_parse_rules_fd(rules_fd, compiler);
call    0 never executed
        -:  604:}
        -:  605:
        -:  606:
function yr_compiler_add_string called 0 returned 0% blocks executed 0%
    #####:  607:YR_API int yr_compiler_add_string(
        -:  608:    YR_COMPILER* compiler,
        -:  609:    const char* rules_string,
        -:  610:    const char* namespace_)
        -:  611:{
        -:  612:  // Don't allow calls to yr_compiler_add_string() after
        -:  613:  // yr_compiler_get_rules() has been called.
        -:  614:
    #####:  615:  assert(compiler->compiled_rules_arena == NULL);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  616:
        -:  617:  // Don't allow calls to yr_compiler_add_string() if a previous call to
        -:  618:  // yr_compiler_add_XXXX failed.
        -:  619:
    #####:  620:  assert(compiler->errors == 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  621:
    #####:  622:  if (namespace_ != NULL)
branch  0 never executed
branch  1 never executed
    #####:  623:    compiler->last_error = _yr_compiler_set_namespace(compiler, namespace_);
call    0 never executed
        -:  624:  else
    #####:  625:    compiler->last_error = _yr_compiler_set_namespace(compiler, "default");
call    0 never executed
        -:  626:
    #####:  627:  if (compiler->last_error != ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  628:  {
    #####:  629:    compiler->errors++;
    #####:  630:    return compiler->errors;
        -:  631:  }
        -:  632:
    #####:  633:  return yr_lex_parse_rules_string(rules_string, compiler);
call    0 never executed
        -:  634:}
        -:  635:
        -:  636:
function _yr_compiler_compile_rules called 0 returned 0% blocks executed 0%
    #####:  637:static int _yr_compiler_compile_rules(
        -:  638:    YR_COMPILER* compiler)
        -:  639:{
    #####:  640:  YARA_RULES_FILE_HEADER* rules_file_header = NULL;
    #####:  641:  YR_ARENA* arena = NULL;
        -:  642:  YR_RULE null_rule;
        -:  643:  YR_EXTERNAL_VARIABLE null_external;
        -:  644:  YR_AC_TABLES tables;
        -:  645:
    #####:  646:  uint8_t halt = OP_HALT;
        -:  647:  int result;
        -:  648:
        -:  649:  // Write halt instruction at the end of code.
    #####:  650:  yr_arena_write_data(
call    0 never executed
        -:  651:      compiler->code_arena,
        -:  652:      &halt,
        -:  653:      sizeof(uint8_t),
        -:  654:      NULL);
        -:  655:
        -:  656:  // Write a null rule indicating the end.
        -:  657:  memset(&null_rule, 0xFA, sizeof(YR_RULE));
    #####:  658:  null_rule.g_flags = RULE_GFLAGS_NULL;
        -:  659:
    #####:  660:  yr_arena_write_data(
call    0 never executed
        -:  661:      compiler->rules_arena,
        -:  662:      &null_rule,
        -:  663:      sizeof(YR_RULE),
        -:  664:      NULL);
        -:  665:
        -:  666:  // Write a null external the end.
        -:  667:  memset(&null_external, 0xFA, sizeof(YR_EXTERNAL_VARIABLE));
    #####:  668:  null_external.type = EXTERNAL_VARIABLE_TYPE_NULL;
        -:  669:
    #####:  670:  yr_arena_write_data(
call    0 never executed
        -:  671:      compiler->externals_arena,
        -:  672:      &null_external,
        -:  673:      sizeof(YR_EXTERNAL_VARIABLE),
        -:  674:      NULL);
        -:  675:
        -:  676:  // Write Aho-Corasick automaton to arena.
    #####:  677:  result = yr_ac_compile(
call    0 never executed
        -:  678:      compiler->automaton,
        -:  679:      compiler->automaton_arena,
        -:  680:      &tables);
        -:  681:
    #####:  682:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  683:    result = yr_arena_create(1024, ARENA_FLAGS_RELOCATABLE, &arena);
call    0 never executed
        -:  684:
    #####:  685:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  686:    result = yr_arena_allocate_struct(
call    0 never executed
        -:  687:        arena,
        -:  688:        sizeof(YARA_RULES_FILE_HEADER),
        -:  689:        (void**) &rules_file_header,
        -:  690:        offsetof(YARA_RULES_FILE_HEADER, rules_list_head),
        -:  691:        offsetof(YARA_RULES_FILE_HEADER, externals_list_head),
        -:  692:        offsetof(YARA_RULES_FILE_HEADER, code_start),
        -:  693:        offsetof(YARA_RULES_FILE_HEADER, ac_match_table),
        -:  694:        offsetof(YARA_RULES_FILE_HEADER, ac_transition_table),
        -:  695:        EOL);
        -:  696:
    #####:  697:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  698:  {
    #####:  699:    rules_file_header->rules_list_head = (YR_RULE*) yr_arena_base_address(
call    0 never executed
        -:  700:        compiler->rules_arena);
        -:  701:
    #####:  702:    rules_file_header->externals_list_head = (YR_EXTERNAL_VARIABLE*)
    #####:  703:		yr_arena_base_address(compiler->externals_arena);
call    0 never executed
        -:  704:
    #####:  705:    rules_file_header->code_start = (uint8_t*) yr_arena_base_address(
call    0 never executed
        -:  706:        compiler->code_arena);
        -:  707:
    #####:  708:    rules_file_header->ac_match_table = tables.matches;
    #####:  709:    rules_file_header->ac_transition_table = tables.transitions;
    #####:  710:    rules_file_header->ac_tables_size = compiler->automaton->tables_size;
        -:  711:  }
        -:  712:
    #####:  713:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  714:  {
    #####:  715:    result = yr_arena_append(
call    0 never executed
        -:  716:        arena,
        -:  717:        compiler->code_arena);
        -:  718:  }
        -:  719:
    #####:  720:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  721:  {
    #####:  722:    compiler->code_arena = NULL;
    #####:  723:    result = yr_arena_append(
call    0 never executed
        -:  724:        arena,
        -:  725:        compiler->re_code_arena);
        -:  726:  }
        -:  727:
    #####:  728:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  729:  {
    #####:  730:    compiler->re_code_arena = NULL;
    #####:  731:    result = yr_arena_append(
call    0 never executed
        -:  732:        arena,
        -:  733:        compiler->rules_arena);
        -:  734:  }
        -:  735:
    #####:  736:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  737:  {
    #####:  738:    compiler->rules_arena = NULL;
    #####:  739:    result = yr_arena_append(
call    0 never executed
        -:  740:        arena,
        -:  741:        compiler->strings_arena);
        -:  742:  }
        -:  743:
    #####:  744:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  745:  {
    #####:  746:    compiler->strings_arena = NULL;
    #####:  747:    result = yr_arena_append(
call    0 never executed
        -:  748:        arena,
        -:  749:        compiler->externals_arena);
        -:  750:  }
        -:  751:
    #####:  752:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  753:  {
    #####:  754:    compiler->externals_arena = NULL;
    #####:  755:    result = yr_arena_append(
call    0 never executed
        -:  756:        arena,
        -:  757:        compiler->namespaces_arena);
        -:  758:  }
        -:  759:
    #####:  760:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  761:  {
    #####:  762:    compiler->namespaces_arena = NULL;
    #####:  763:    result = yr_arena_append(
call    0 never executed
        -:  764:        arena,
        -:  765:        compiler->metas_arena);
        -:  766:  }
        -:  767:
    #####:  768:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  769:  {
    #####:  770:    compiler->metas_arena = NULL;
    #####:  771:    result = yr_arena_append(
call    0 never executed
        -:  772:        arena,
        -:  773:        compiler->sz_arena);
        -:  774:  }
        -:  775:
    #####:  776:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  777:  {
    #####:  778:    compiler->sz_arena = NULL;
    #####:  779:    result = yr_arena_append(
call    0 never executed
        -:  780:        arena,
        -:  781:        compiler->automaton_arena);
        -:  782:  }
        -:  783:
    #####:  784:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  785:  {
    #####:  786:    compiler->automaton_arena = NULL;
    #####:  787:    result = yr_arena_append(
call    0 never executed
        -:  788:        arena,
        -:  789:        compiler->matches_arena);
        -:  790:  }
        -:  791:
    #####:  792:  if (result == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  793:  {
    #####:  794:    compiler->matches_arena = NULL;
    #####:  795:    compiler->compiled_rules_arena = arena;
    #####:  796:    result = yr_arena_coalesce(arena);
call    0 never executed
        -:  797:  }
        -:  798:  else
        -:  799:  {
    #####:  800:    yr_arena_destroy(arena);
call    0 never executed
        -:  801:  }
        -:  802:
    #####:  803:  return result;
        -:  804:}
        -:  805:
        -:  806:
function yr_compiler_get_rules called 0 returned 0% blocks executed 0%
    #####:  807:YR_API int yr_compiler_get_rules(
        -:  808:    YR_COMPILER* compiler,
        -:  809:    YR_RULES** rules)
        -:  810:{
        -:  811:  YR_RULES* yara_rules;
        -:  812:  YARA_RULES_FILE_HEADER* rules_file_header;
        -:  813:
        -:  814:  // Don't allow calls to yr_compiler_get_rules() if a previous call to
        -:  815:  // yr_compiler_add_XXXX failed.
        -:  816:
    #####:  817:  assert(compiler->errors == 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  818:
    #####:  819:  *rules = NULL;
        -:  820:
    #####:  821:  if (compiler->compiled_rules_arena == NULL)
branch  0 never executed
branch  1 never executed
    #####:  822:     FAIL_ON_ERROR(_yr_compiler_compile_rules(compiler));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  823:
    #####:  824:  yara_rules = (YR_RULES*) yr_malloc(sizeof(YR_RULES));
call    0 never executed
        -:  825:
    #####:  826:  if (yara_rules == NULL)
branch  0 never executed
branch  1 never executed
        -:  827:    return ERROR_INSUFFICIENT_MEMORY;
        -:  828:
    #####:  829:  FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  830:      yr_arena_duplicate(compiler->compiled_rules_arena, &yara_rules->arena),
        -:  831:      yr_free(yara_rules));
        -:  832:
    #####:  833:  rules_file_header = (YARA_RULES_FILE_HEADER*) yr_arena_base_address(
call    0 never executed
        -:  834:      yara_rules->arena);
        -:  835:
    #####:  836:  yara_rules->externals_list_head = rules_file_header->externals_list_head;
    #####:  837:  yara_rules->rules_list_head = rules_file_header->rules_list_head;
    #####:  838:  yara_rules->ac_match_table = rules_file_header->ac_match_table;
    #####:  839:  yara_rules->ac_transition_table = rules_file_header->ac_transition_table;
    #####:  840:  yara_rules->ac_tables_size = rules_file_header->ac_tables_size;
    #####:  841:  yara_rules->code_start = rules_file_header->code_start;
    #####:  842:  yara_rules->time_cost = 0;
        -:  843:
    #####:  844:  memset(yara_rules->tidx_mask, 0, sizeof(yara_rules->tidx_mask));
        -:  845:
    #####:  846:  FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  847:      yr_mutex_create(&yara_rules->mutex),
        -:  848:      // cleanup
        -:  849:      yr_arena_destroy(yara_rules->arena);
        -:  850:      yr_free(yara_rules));
        -:  851:
    #####:  852:  *rules = yara_rules;
        -:  853:
    #####:  854:  return ERROR_SUCCESS;
        -:  855:}
        -:  856:
function _yr_compiler_define_variable called 0 returned 0% blocks executed 0%
    #####:  857:int _yr_compiler_define_variable(
        -:  858:    YR_COMPILER* compiler,
        -:  859:    YR_EXTERNAL_VARIABLE* external)
        -:  860:{
        -:  861:  YR_EXTERNAL_VARIABLE* ext;
        -:  862:  YR_OBJECT* object;
        -:  863:
        -:  864:  char* id;
        -:  865:
    #####:  866:  object = (YR_OBJECT*) yr_hash_table_lookup(
call    0 never executed
        -:  867:      compiler->objects_table,
        -:  868:      external->identifier,
        -:  869:      NULL);
        -:  870:
    #####:  871:  if (object != NULL)
branch  0 never executed
branch  1 never executed
        -:  872:    return ERROR_DUPLICATED_EXTERNAL_VARIABLE;
        -:  873:
    #####:  874:  FAIL_ON_ERROR(yr_arena_write_string(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  875:      compiler->sz_arena,
        -:  876:      external->identifier,
        -:  877:      &id));
        -:  878:
    #####:  879:  FAIL_ON_ERROR(yr_arena_allocate_struct(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  880:      compiler->externals_arena,
        -:  881:      sizeof(YR_EXTERNAL_VARIABLE),
        -:  882:      (void**) &ext,
        -:  883:      offsetof(YR_EXTERNAL_VARIABLE, identifier),
        -:  884:      EOL));
        -:  885:
    #####:  886:  ext->identifier = id;
    #####:  887:  ext->type = external->type;
    #####:  888:  ext->value = external->value;
        -:  889:
    #####:  890:  if (external->type == EXTERNAL_VARIABLE_TYPE_STRING)
branch  0 never executed
branch  1 never executed
        -:  891:  {
        -:  892:    char* val;
        -:  893:
    #####:  894:    FAIL_ON_ERROR(yr_arena_write_string(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  895:        compiler->sz_arena,
        -:  896:        external->value.s,
        -:  897:        &val));
        -:  898:
    #####:  899:    ext->value.s = val;
        -:  900:
    #####:  901:    FAIL_ON_ERROR(yr_arena_make_ptr_relocatable(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  902:        compiler->externals_arena,
        -:  903:        ext,
        -:  904:        offsetof(YR_EXTERNAL_VARIABLE, value.s),
        -:  905:        EOL));
        -:  906:  }
        -:  907:
    #####:  908:  FAIL_ON_ERROR(yr_object_from_external_variable(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  909:      external,
        -:  910:      &object));
        -:  911:
    #####:  912:  FAIL_ON_ERROR(yr_hash_table_add(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  913:      compiler->objects_table,
        -:  914:      external->identifier,
        -:  915:      NULL,
        -:  916:      (void*) object));
        -:  917:
    #####:  918:  return ERROR_SUCCESS;
        -:  919:}
        -:  920:
        -:  921:
function yr_compiler_define_integer_variable called 0 returned 0% blocks executed 0%
    #####:  922:YR_API int yr_compiler_define_integer_variable(
        -:  923:    YR_COMPILER* compiler,
        -:  924:    const char* identifier,
        -:  925:    int64_t value)
        -:  926:{
        -:  927:  YR_EXTERNAL_VARIABLE external;
        -:  928:
    #####:  929:  external.type = EXTERNAL_VARIABLE_TYPE_INTEGER;
    #####:  930:  external.identifier = identifier;
    #####:  931:  external.value.i = value;
        -:  932:
    #####:  933:  FAIL_ON_ERROR(_yr_compiler_define_variable(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  934:      compiler, &external));
        -:  935:
    #####:  936:  return ERROR_SUCCESS;
        -:  937:}
        -:  938:
        -:  939:
function yr_compiler_define_boolean_variable called 0 returned 0% blocks executed 0%
    #####:  940:YR_API int yr_compiler_define_boolean_variable(
        -:  941:    YR_COMPILER* compiler,
        -:  942:    const char* identifier,
        -:  943:    int value)
        -:  944:{
        -:  945:  YR_EXTERNAL_VARIABLE external;
        -:  946:
    #####:  947:  external.type = EXTERNAL_VARIABLE_TYPE_BOOLEAN;
    #####:  948:  external.identifier = identifier;
    #####:  949:  external.value.i = value;
        -:  950:
    #####:  951:  FAIL_ON_ERROR(_yr_compiler_define_variable(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  952:      compiler, &external));
        -:  953:
    #####:  954:  return ERROR_SUCCESS;
        -:  955:}
        -:  956:
        -:  957:
function yr_compiler_define_float_variable called 0 returned 0% blocks executed 0%
    #####:  958:YR_API int yr_compiler_define_float_variable(
        -:  959:    YR_COMPILER* compiler,
        -:  960:    const char* identifier,
        -:  961:    double value)
        -:  962:{
        -:  963:  YR_EXTERNAL_VARIABLE external;
        -:  964:
    #####:  965:  external.type = EXTERNAL_VARIABLE_TYPE_FLOAT;
    #####:  966:  external.identifier = identifier;
    #####:  967:  external.value.f = value;
        -:  968:
    #####:  969:  FAIL_ON_ERROR(_yr_compiler_define_variable(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  970:      compiler, &external));
        -:  971:
    #####:  972:  return ERROR_SUCCESS;
        -:  973:}
        -:  974:
        -:  975:
function yr_compiler_define_string_variable called 0 returned 0% blocks executed 0%
    #####:  976:YR_API int yr_compiler_define_string_variable(
        -:  977:    YR_COMPILER* compiler,
        -:  978:    const char* identifier,
        -:  979:    const char* value)
        -:  980:{
        -:  981:  YR_EXTERNAL_VARIABLE external;
        -:  982:
    #####:  983:  external.type = EXTERNAL_VARIABLE_TYPE_STRING;
    #####:  984:  external.identifier = identifier;
    #####:  985:  external.value.s = (char*) value;
        -:  986:
    #####:  987:  FAIL_ON_ERROR(_yr_compiler_define_variable(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  988:      compiler, &external));
        -:  989:
    #####:  990:  return ERROR_SUCCESS;
        -:  991:}
        -:  992:
        -:  993:
function yr_compiler_get_error_message called 0 returned 0% blocks executed 0%
    #####:  994:YR_API char* yr_compiler_get_error_message(
        -:  995:    YR_COMPILER* compiler,
        -:  996:    char* buffer,
        -:  997:    int buffer_size)
        -:  998:{
        -:  999:  uint32_t max_strings_per_rule;
        -: 1000:
    #####: 1001:  switch(compiler->last_error)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
        -: 1002:  {
    #####: 1003:    case ERROR_INSUFFICIENT_MEMORY:
    #####: 1004:      snprintf(buffer, buffer_size, "not enough memory");
        -: 1005:      break;
    #####: 1006:    case ERROR_DUPLICATED_IDENTIFIER:
    #####: 1007:      snprintf(
        -: 1008:          buffer,
        -: 1009:          buffer_size,
        -: 1010:          "duplicated identifier \"%s\"",
    #####: 1011:          compiler->last_error_extra_info);
        -: 1012:      break;
    #####: 1013:    case ERROR_DUPLICATED_STRING_IDENTIFIER:
    #####: 1014:      snprintf(
        -: 1015:          buffer,
        -: 1016:          buffer_size,
        -: 1017:          "duplicated string identifier \"%s\"",
    #####: 1018:          compiler->last_error_extra_info);
        -: 1019:      break;
    #####: 1020:    case ERROR_DUPLICATED_TAG_IDENTIFIER:
    #####: 1021:      snprintf(
        -: 1022:          buffer,
        -: 1023:          buffer_size,
        -: 1024:          "duplicated tag identifier \"%s\"",
    #####: 1025:          compiler->last_error_extra_info);
        -: 1026:      break;
    #####: 1027:    case ERROR_DUPLICATED_META_IDENTIFIER:
    #####: 1028:      snprintf(
        -: 1029:          buffer,
        -: 1030:          buffer_size,
        -: 1031:          "duplicated metadata identifier \"%s\"",
    #####: 1032:          compiler->last_error_extra_info);
        -: 1033:      break;
    #####: 1034:    case ERROR_DUPLICATED_LOOP_IDENTIFIER:
    #####: 1035:      snprintf(
        -: 1036:          buffer,
        -: 1037:          buffer_size,
        -: 1038:          "duplicated loop identifier \"%s\"",
    #####: 1039:          compiler->last_error_extra_info);
        -: 1040:      break;
    #####: 1041:    case ERROR_UNDEFINED_STRING:
    #####: 1042:      snprintf(
        -: 1043:          buffer,
        -: 1044:          buffer_size,
        -: 1045:          "undefined string \"%s\"",
    #####: 1046:          compiler->last_error_extra_info);
        -: 1047:      break;
    #####: 1048:    case ERROR_UNDEFINED_IDENTIFIER:
    #####: 1049:      snprintf(
        -: 1050:          buffer,
        -: 1051:          buffer_size,
        -: 1052:          "undefined identifier \"%s\"",
    #####: 1053:          compiler->last_error_extra_info);
        -: 1054:      break;
    #####: 1055:    case ERROR_UNREFERENCED_STRING:
    #####: 1056:      snprintf(
        -: 1057:          buffer,
        -: 1058:          buffer_size,
        -: 1059:          "unreferenced string \"%s\"",
    #####: 1060:          compiler->last_error_extra_info);
        -: 1061:      break;
    #####: 1062:    case ERROR_EMPTY_STRING:
    #####: 1063:      snprintf(
        -: 1064:          buffer,
        -: 1065:          buffer_size,
        -: 1066:          "empty string \"%s\"",
    #####: 1067:          compiler->last_error_extra_info);
        -: 1068:      break;
    #####: 1069:    case ERROR_NOT_A_STRUCTURE:
    #####: 1070:      snprintf(
        -: 1071:          buffer,
        -: 1072:          buffer_size,
        -: 1073:          "\"%s\" is not a structure",
    #####: 1074:          compiler->last_error_extra_info);
        -: 1075:      break;
    #####: 1076:    case ERROR_NOT_INDEXABLE:
    #####: 1077:      snprintf(
        -: 1078:          buffer,
        -: 1079:          buffer_size,
        -: 1080:          "\"%s\" is not an array or dictionary",
    #####: 1081:          compiler->last_error_extra_info);
        -: 1082:      break;
    #####: 1083:    case ERROR_NOT_A_FUNCTION:
    #####: 1084:      snprintf(
        -: 1085:          buffer,
        -: 1086:          buffer_size,
        -: 1087:          "\"%s\" is not a function",
    #####: 1088:          compiler->last_error_extra_info);
        -: 1089:      break;
    #####: 1090:    case ERROR_INVALID_FIELD_NAME:
    #####: 1091:      snprintf(
        -: 1092:          buffer,
        -: 1093:          buffer_size,
        -: 1094:          "invalid field name \"%s\"",
    #####: 1095:          compiler->last_error_extra_info);
        -: 1096:      break;
    #####: 1097:    case ERROR_MISPLACED_ANONYMOUS_STRING:
    #####: 1098:      snprintf(
        -: 1099:          buffer,
        -: 1100:          buffer_size,
        -: 1101:          "wrong use of anonymous string");
        -: 1102:      break;
    #####: 1103:    case ERROR_INCLUDES_CIRCULAR_REFERENCE:
    #####: 1104:      snprintf(
        -: 1105:          buffer,
        -: 1106:          buffer_size,
        -: 1107:          "include circular reference");
        -: 1108:      break;
    #####: 1109:    case ERROR_INCLUDE_DEPTH_EXCEEDED:
    #####: 1110:      snprintf(buffer,
        -: 1111:          buffer_size,
        -: 1112:          "too many levels of included rules");
        -: 1113:      break;
    #####: 1114:    case ERROR_LOOP_NESTING_LIMIT_EXCEEDED:
    #####: 1115:      snprintf(buffer,
        -: 1116:          buffer_size,
        -: 1117:          "loop nesting limit exceeded");
        -: 1118:      break;
    #####: 1119:    case ERROR_NESTED_FOR_OF_LOOP:
    #####: 1120:      snprintf(buffer,
        -: 1121:          buffer_size,
        -: 1122:          "'for <quantifier> of <string set>' loops can't be nested");
        -: 1123:      break;
    #####: 1124:    case ERROR_UNKNOWN_MODULE:
    #####: 1125:      snprintf(
        -: 1126:          buffer,
        -: 1127:          buffer_size,
        -: 1128:          "unknown module \"%s\"",
    #####: 1129:          compiler->last_error_extra_info);
        -: 1130:      break;
    #####: 1131:    case ERROR_INVALID_MODULE_NAME:
    #####: 1132:      snprintf(
        -: 1133:          buffer,
        -: 1134:          buffer_size,
        -: 1135:          "invalid module name \"%s\"",
    #####: 1136:          compiler->last_error_extra_info);
        -: 1137:      break;
    #####: 1138:    case ERROR_DUPLICATED_STRUCTURE_MEMBER:
    #####: 1139:      snprintf(buffer,
        -: 1140:          buffer_size,
        -: 1141:          "duplicated structure member");
        -: 1142:      break;
    #####: 1143:    case ERROR_WRONG_ARGUMENTS:
    #####: 1144:      snprintf(
        -: 1145:          buffer,
        -: 1146:          buffer_size,
        -: 1147:          "wrong arguments for function \"%s\"",
    #####: 1148:          compiler->last_error_extra_info);
        -: 1149:      break;
    #####: 1150:    case ERROR_WRONG_RETURN_TYPE:
    #####: 1151:      snprintf(buffer,
        -: 1152:          buffer_size,
        -: 1153:          "wrong return type for overloaded function");
        -: 1154:      break;
    #####: 1155:    case ERROR_INVALID_HEX_STRING:
        -: 1156:    case ERROR_INVALID_REGULAR_EXPRESSION:
        -: 1157:    case ERROR_SYNTAX_ERROR:
        -: 1158:    case ERROR_WRONG_TYPE:
    #####: 1159:      snprintf(
        -: 1160:          buffer,
        -: 1161:          buffer_size,
        -: 1162:          "%s",
    #####: 1163:          compiler->last_error_extra_info);
        -: 1164:      break;
    #####: 1165:    case ERROR_INTERNAL_FATAL_ERROR:
    #####: 1166:      snprintf(
        -: 1167:          buffer,
        -: 1168:          buffer_size,
        -: 1169:          "internal fatal error");
        -: 1170:      break;
    #####: 1171:    case ERROR_DIVISION_BY_ZERO:
    #####: 1172:      snprintf(
        -: 1173:          buffer,
        -: 1174:          buffer_size,
        -: 1175:          "division by zero");
        -: 1176:      break;
    #####: 1177:    case ERROR_REGULAR_EXPRESSION_TOO_LARGE:
    #####: 1178:      snprintf(
        -: 1179:          buffer,
        -: 1180:          buffer_size,
        -: 1181:          "regular expression is too large");
        -: 1182:      break;
    #####: 1183:    case ERROR_REGULAR_EXPRESSION_TOO_COMPLEX:
    #####: 1184:      snprintf(
        -: 1185:          buffer,
        -: 1186:          buffer_size,
        -: 1187:          "regular expression is too complex");
        -: 1188:      break;
    #####: 1189:    case ERROR_TOO_MANY_STRINGS:
    #####: 1190:       yr_get_configuration(
call    0 never executed
        -: 1191:          YR_CONFIG_MAX_STRINGS_PER_RULE,
        -: 1192:          &max_strings_per_rule);
    #####: 1193:       snprintf(
        -: 1194:          buffer,
        -: 1195:          buffer_size,
        -: 1196:          "too many strings in rule \"%s\" (limit: %d)",
    #####: 1197:          compiler->last_error_extra_info,
        -: 1198:          max_strings_per_rule);
        -: 1199:      break;
    #####: 1200:    case ERROR_INTEGER_OVERFLOW:
    #####: 1201:      snprintf(
        -: 1202:          buffer,
        -: 1203:          buffer_size,
        -: 1204:          "integer overflow in \"%s\"",
    #####: 1205:          compiler->last_error_extra_info);
        -: 1206:      break;
    #####: 1207:    case ERROR_COULD_NOT_READ_FILE:
    #####: 1208:      snprintf(
        -: 1209:          buffer,
        -: 1210:          buffer_size,
        -: 1211:          "could not read file");
        -: 1212:      break;
        -: 1213:  }
        -: 1214:
    #####: 1215:  return buffer;
        -: 1216:}
