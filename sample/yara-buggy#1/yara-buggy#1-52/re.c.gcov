        -:    0:Source:re.c
        -:    0:Graph:/home/workspace/libyara/.libs/re.gcno
        -:    0:Data:/home/workspace/libyara/.libs/re.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:
        -:   31:/*
        -:   32:
        -:   33:This module implements a regular expressions engine based on Thompson's
        -:   34:algorithm as described by Russ Cox in http://swtch.com/~rsc/regexp/regexp2.html.
        -:   35:
        -:   36:What the article names a "thread" has been named a "fiber" in this code, in
        -:   37:order to avoid confusion with operating system threads.
        -:   38:
        -:   39:*/
        -:   40:
        -:   41:#include <assert.h>
        -:   42:#include <string.h>
        -:   43:
        -:   44:#include <yara/limits.h>
        -:   45:#include <yara/globals.h>
        -:   46:#include <yara/utils.h>
        -:   47:#include <yara/mem.h>
        -:   48:#include <yara/re.h>
        -:   49:#include <yara/error.h>
        -:   50:#include <yara/threading.h>
        -:   51:#include <yara/re_lexer.h>
        -:   52:#include <yara/hex_lexer.h>
        -:   53:
        -:   54:
        -:   55:#define EMIT_BACKWARDS                  0x01
        -:   56:#define EMIT_DONT_SET_FORWARDS_CODE     0x02
        -:   57:#define EMIT_DONT_SET_BACKWARDS_CODE    0x04
        -:   58:
        -:   59:#ifndef INT16_MAX
        -:   60:#define INT16_MAX              (32767)
        -:   61:#endif
        -:   62:
        -:   63:
        -:   64:typedef uint8_t RE_SPLIT_ID_TYPE;
        -:   65:
        -:   66:
        -:   67:typedef struct _RE_REPEAT_ARGS
        -:   68:{
        -:   69:  uint16_t  min;
        -:   70:  uint16_t  max;
        -:   71:  int32_t   offset;
        -:   72:
        -:   73:} RE_REPEAT_ARGS;
        -:   74:
        -:   75:
        -:   76:typedef struct _RE_REPEAT_ANY_ARGS
        -:   77:{
        -:   78:  uint16_t   min;
        -:   79:  uint16_t   max;
        -:   80:
        -:   81:} RE_REPEAT_ANY_ARGS;
        -:   82:
        -:   83:
        -:   84:typedef struct _RE_EMIT_CONTEXT {
        -:   85:
        -:   86:  YR_ARENA*         arena;
        -:   87:  RE_SPLIT_ID_TYPE  next_split_id;
        -:   88:
        -:   89:} RE_EMIT_CONTEXT;
        -:   90:
        -:   91:
        -:   92:#define CHAR_IN_CLASS(cls, chr)  \
        -:   93:  ((cls)[(chr) / 8] & 1 << ((chr) % 8))
        -:   94:
        -:   95:
        -:   96:static bool _yr_re_is_char_in_class(
        -:   97:    RE_CLASS* re_class,
        -:   98:    uint8_t chr,
        -:   99:    int case_insensitive)
        -:  100:{
    #####:  101:  int result = CHAR_IN_CLASS(re_class->bitmap, chr);
        -:  102:
    #####:  103:  if (case_insensitive)
branch  0 never executed
branch  1 never executed
    #####:  104:    result |= CHAR_IN_CLASS(re_class->bitmap, yr_altercase[chr]);
        -:  105:
    #####:  106:  if (re_class->negated)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  107:    result = !result;
        -:  108:
        -:  109:  return result;
        -:  110:}
        -:  111:
        -:  112:
function _yr_re_is_word_char called 0 returned 0% blocks executed 0%
    #####:  113:static bool _yr_re_is_word_char(
        -:  114:    const uint8_t* input,
        -:  115:    uint8_t character_size)
        -:  116:{
    #####:  117:  int result = ((isalnum(*input) || (*input) == '_'));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  118:
    #####:  119:  if (character_size == 2)
branch  0 never executed
branch  1 never executed
    #####:  120:    result = result && (*(input + 1) == 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  121:
    #####:  122:  return result;
        -:  123:}
        -:  124:
        -:  125:
function yr_re_node_create called 0 returned 0% blocks executed 0%
    #####:  126:RE_NODE* yr_re_node_create(
        -:  127:    int type,
        -:  128:    RE_NODE* left,
        -:  129:    RE_NODE* right)
        -:  130:{
    #####:  131:  RE_NODE* result = (RE_NODE*) yr_malloc(sizeof(RE_NODE));
call    0 never executed
        -:  132:
    #####:  133:  if (result != NULL)
branch  0 never executed
branch  1 never executed
        -:  134:  {
    #####:  135:    result->type = type;
    #####:  136:    result->left = left;
    #####:  137:    result->right = right;
    #####:  138:    result->greedy = true;
    #####:  139:    result->forward_code = NULL;
    #####:  140:    result->backward_code = NULL;
        -:  141:  }
        -:  142:
    #####:  143:  return result;
        -:  144:}
        -:  145:
        -:  146:
function yr_re_node_destroy called 0 returned 0% blocks executed 0%
    #####:  147:void yr_re_node_destroy(
        -:  148:    RE_NODE* node)
        -:  149:{
    #####:  150:  if (node->left != NULL)
branch  0 never executed
branch  1 never executed
    #####:  151:    yr_re_node_destroy(node->left);
call    0 never executed
        -:  152:
    #####:  153:  if (node->right != NULL)
branch  0 never executed
branch  1 never executed
    #####:  154:    yr_re_node_destroy(node->right);
call    0 never executed
        -:  155:
    #####:  156:  if (node->type == RE_NODE_CLASS)
branch  0 never executed
branch  1 never executed
    #####:  157:    yr_free(node->re_class);
call    0 never executed
        -:  158:
    #####:  159:  yr_free(node);
call    0 never executed
    #####:  160:}
        -:  161:
        -:  162:
function yr_re_ast_create called 0 returned 0% blocks executed 0%
    #####:  163:int yr_re_ast_create(
        -:  164:    RE_AST** re_ast)
        -:  165:{
    #####:  166:  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
call    0 never executed
call    1 never executed
        -:  167:
    #####:  168:  if (*re_ast == NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  169:    return ERROR_INSUFFICIENT_MEMORY;
        -:  170:
    #####:  171:  (*re_ast)->flags = 0;
    #####:  172:  (*re_ast)->levels = 0;
    #####:  173:  (*re_ast)->root_node = NULL;
        -:  174:
    #####:  175:  return ERROR_SUCCESS;
        -:  176:}
        -:  177:
        -:  178:
function yr_re_ast_destroy called 0 returned 0% blocks executed 0%
    #####:  179:void yr_re_ast_destroy(
        -:  180:    RE_AST* re_ast)
        -:  181:{
    #####:  182:  if (re_ast->root_node != NULL)
branch  0 never executed
branch  1 never executed
    #####:  183:    yr_re_node_destroy(re_ast->root_node);
call    0 never executed
        -:  184:
    #####:  185:  yr_free(re_ast);
call    0 never executed
    #####:  186:}
        -:  187:
        -:  188:
        -:  189://
        -:  190:// yr_re_parse
        -:  191://
        -:  192:// Parses a regexp but don't emit its code. A further call to
        -:  193:// yr_re_emit_code is required to get the code.
        -:  194://
        -:  195:
function yr_re_parse called 0 returned 0% blocks executed 0%
    #####:  196:int yr_re_parse(
        -:  197:    const char* re_string,
        -:  198:    RE_AST** re_ast,
        -:  199:    RE_ERROR* error)
        -:  200:{
    #####:  201:  return yr_parse_re_string(re_string, re_ast, error);
call    0 never executed
call    1 never executed
        -:  202:}
        -:  203:
        -:  204:
        -:  205://
        -:  206:// yr_re_parse_hex
        -:  207://
        -:  208:// Parses a hex string but don't emit its code. A further call to
        -:  209:// yr_re_emit_code is required to get the code.
        -:  210://
        -:  211:
function yr_re_parse_hex called 0 returned 0% blocks executed 0%
    #####:  212:int yr_re_parse_hex(
        -:  213:    const char* hex_string,
        -:  214:    RE_AST** re_ast,
        -:  215:    RE_ERROR* error)
        -:  216:{
    #####:  217:  return yr_parse_hex_string(hex_string, re_ast, error);
call    0 never executed
        -:  218:}
        -:  219:
        -:  220:
        -:  221://
        -:  222:// yr_re_compile
        -:  223://
        -:  224:// Parses the regexp and emit its code to the provided code_arena.
        -:  225://
        -:  226:
function yr_re_compile called 0 returned 0% blocks executed 0%
    #####:  227:int yr_re_compile(
        -:  228:    const char* re_string,
        -:  229:    int flags,
        -:  230:    YR_ARENA* code_arena,
        -:  231:    RE** re,
        -:  232:    RE_ERROR* error)
        -:  233:{
        -:  234:  RE_AST* re_ast;
        -:  235:  RE _re;
        -:  236:
    #####:  237:  FAIL_ON_ERROR(yr_arena_reserve_memory(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  238:      code_arena, sizeof(int64_t) + RE_MAX_CODE_SIZE));
        -:  239:
    #####:  240:  FAIL_ON_ERROR(yr_re_parse(re_string, &re_ast, error));
branch  0 never executed
branch  1 never executed
        -:  241:
    #####:  242:  _re.flags = flags;
        -:  243:
    #####:  244:  FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  245:      yr_arena_write_data(
        -:  246:          code_arena,
        -:  247:          &_re,
        -:  248:          sizeof(_re),
        -:  249:          (void**) re),
        -:  250:      yr_re_ast_destroy(re_ast));
        -:  251:
    #####:  252:  FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  253:      yr_re_ast_emit_code(re_ast, code_arena, false),
        -:  254:      yr_re_ast_destroy(re_ast));
        -:  255:
    #####:  256:  yr_re_ast_destroy(re_ast);
call    0 never executed
        -:  257:
    #####:  258:  return ERROR_SUCCESS;
        -:  259:}
        -:  260:
        -:  261:
        -:  262://
        -:  263:// yr_re_match
        -:  264://
        -:  265:// Verifies if the target string matches the pattern
        -:  266://
        -:  267:// Args:
        -:  268://    YR_SCAN_CONTEXT* context  - Scan context
        -:  269://    RE* re                    -  A pointer to a compiled regexp
        -:  270://    char* target              -  Target string
        -:  271://
        -:  272:// Returns:
        -:  273://    See return codes for yr_re_exec
        -:  274:
        -:  275:
function yr_re_match called 0 returned 0% blocks executed 0%
    #####:  276:int yr_re_match(
        -:  277:    YR_SCAN_CONTEXT* context,
        -:  278:    RE* re,
        -:  279:    const char* target)
        -:  280:{
        -:  281:  int result;
        -:  282:
    #####:  283:  yr_re_exec(
call    0 never executed
        -:  284:      context,
    #####:  285:      re->code,
        -:  286:      (uint8_t*) target,
        -:  287:      strlen(target),
        -:  288:      0,
    #####:  289:      re->flags | RE_FLAGS_SCAN,
        -:  290:      NULL,
        -:  291:      NULL,
        -:  292:      &result);
        -:  293:
    #####:  294:  return result;
        -:  295:}
        -:  296:
        -:  297:
        -:  298://
        -:  299:// yr_re_ast_extract_literal
        -:  300://
        -:  301:// Verifies if the provided regular expression is just a literal string
        -:  302:// like "abc", "12345", without any wildcard, operator, etc. In that case
        -:  303:// returns the string as a SIZED_STRING, or returns NULL if otherwise.
        -:  304://
        -:  305:// The caller is responsible for deallocating the returned SIZED_STRING by
        -:  306:// calling yr_free.
        -:  307://
        -:  308:
function yr_re_ast_extract_literal called 0 returned 0% blocks executed 0%
    #####:  309:SIZED_STRING* yr_re_ast_extract_literal(
        -:  310:    RE_AST* re_ast)
        -:  311:{
        -:  312:  SIZED_STRING* string;
    #####:  313:  RE_NODE* node = re_ast->root_node;
        -:  314:
        -:  315:  int i, length = 0;
        -:  316:
    #####:  317:  while (node != NULL)
branch  0 never executed
branch  1 never executed
        -:  318:  {
    #####:  319:    length++;
        -:  320:
    #####:  321:    if (node->type == RE_NODE_LITERAL)
branch  0 never executed
branch  1 never executed
        -:  322:      break;
        -:  323:
    #####:  324:    if (node->type != RE_NODE_CONCAT)
branch  0 never executed
branch  1 never executed
        -:  325:      return NULL;
        -:  326:
    #####:  327:    if (node->right == NULL ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  328:        node->right->type != RE_NODE_LITERAL)
        -:  329:      return NULL;
        -:  330:
    #####:  331:    node = node->left;
        -:  332:  }
        -:  333:
    #####:  334:  string = (SIZED_STRING*) yr_malloc(sizeof(SIZED_STRING) + length);
call    0 never executed
        -:  335:
    #####:  336:  if (string == NULL)
branch  0 never executed
branch  1 never executed
        -:  337:    return NULL;
        -:  338:
    #####:  339:  string->length = length;
    #####:  340:  node = re_ast->root_node;
        -:  341:
        -:  342:  // The root node is the end of the string. So let's fill it up backwards.
    #####:  343:  for (i = length - 1; i > 0; i--)
branch  0 never executed
branch  1 never executed
        -:  344:  {
    #####:  345:    string->c_string[i] = node->right->value;
    #####:  346:    node = node->left;
        -:  347:  }
        -:  348:
    #####:  349:  if (length > 0)
branch  0 never executed
branch  1 never executed
    #####:  350:    string->c_string[0] = node->value;
        -:  351:
    #####:  352:  assert(node == NULL || node->type == RE_NODE_LITERAL);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  353:
        -:  354:  return string;
        -:  355:}
        -:  356:
        -:  357:
function _yr_re_node_contains_dot_star called 0 returned 0% blocks executed 0%
    #####:  358:int _yr_re_node_contains_dot_star(
        -:  359:    RE_NODE* re_node)
        -:  360:{
    #####:  361:  if ((re_node->type == RE_NODE_STAR || re_node->type == RE_NODE_PLUS) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  362:      re_node->left->type == RE_NODE_ANY)
        -:  363:    return true;
        -:  364:
    #####:  365:  if (re_node->left != NULL && _yr_re_node_contains_dot_star(re_node->left))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  366:    return true;
        -:  367:
    #####:  368:  if (re_node->right != NULL && _yr_re_node_contains_dot_star(re_node->right))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  369:    return true;
        -:  370:
        -:  371:  return false;
        -:  372:}
        -:  373:
        -:  374:
function yr_re_ast_contains_dot_star called 0 returned 0% blocks executed 0%
    #####:  375:int yr_re_ast_contains_dot_star(
        -:  376:    RE_AST* re_ast)
        -:  377:{
    #####:  378:  return _yr_re_node_contains_dot_star(re_ast->root_node);
call    0 never executed
        -:  379:}
        -:  380:
        -:  381:
        -:  382://
        -:  383:// yr_re_ast_split_at_chaining_point
        -:  384://
        -:  385:// In some cases splitting a regular expression in two is more efficient that
        -:  386:// having a single regular expression. This happens when the regular expression
        -:  387:// contains a large repetition of any character, for example: /foo.{0,1000}bar/
        -:  388:// In this case the regexp is split in /foo/ and /bar/ where /bar/ is "chained"
        -:  389:// to /foo/. This means that /foo/ and /bar/ are handled as individual regexps
        -:  390:// and when both matches YARA verifies if the distance between the matches
        -:  391:// complies with the {0,1000} restriction.
        -:  392:
        -:  393:// This function traverses the regexp's tree looking for nodes where the regxp
        -:  394:// should be split. It expects a left-unbalanced tree where the right child of
        -:  395:// a RE_NODE_CONCAT can't be another RE_NODE_CONCAT. A RE_NODE_CONCAT must be
        -:  396:// always the left child of its parent if the parent is also a RE_NODE_CONCAT.
        -:  397://
        -:  398:
function yr_re_ast_split_at_chaining_point called 0 returned 0% blocks executed 0%
    #####:  399:int yr_re_ast_split_at_chaining_point(
        -:  400:    RE_AST* re_ast,
        -:  401:    RE_AST** result_re_ast,
        -:  402:    RE_AST** remainder_re_ast,
        -:  403:    int32_t* min_gap,
        -:  404:    int32_t* max_gap)
        -:  405:{
    #####:  406:  RE_NODE* node = re_ast->root_node;
    #####:  407:  RE_NODE* child = re_ast->root_node->left;
        -:  408:  RE_NODE* parent = NULL;
        -:  409:
        -:  410:  int result;
        -:  411:
    #####:  412:  *result_re_ast = re_ast;
    #####:  413:  *remainder_re_ast = NULL;
    #####:  414:  *min_gap = 0;
    #####:  415:  *max_gap = 0;
        -:  416:
    #####:  417:  while (child != NULL && child->type == RE_NODE_CONCAT)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  418:  {
    #####:  419:    if (child->right != NULL &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  420:        child->right->type == RE_NODE_RANGE_ANY &&
branch  0 never executed
branch  1 never executed
    #####:  421:        child->right->greedy == false &&
branch  0 never executed
branch  1 never executed
    #####:  422:        (child->right->start > YR_STRING_CHAINING_THRESHOLD ||
branch  0 never executed
branch  1 never executed
    #####:  423:         child->right->end > YR_STRING_CHAINING_THRESHOLD))
        -:  424:    {
        -:  425:      result = yr_re_ast_create(remainder_re_ast);
        -:  426:
        -:  427:      if (result != ERROR_SUCCESS)
        -:  428:        return result;
        -:  429:
    #####:  430:      (*remainder_re_ast)->root_node = child->left;
    #####:  431:      (*remainder_re_ast)->flags = re_ast->flags;
        -:  432:
    #####:  433:      child->left = NULL;
        -:  434:
    #####:  435:      if (parent != NULL)
branch  0 never executed
branch  1 never executed
    #####:  436:        parent->left = node->right;
        -:  437:      else
    #####:  438:        (*result_re_ast)->root_node = node->right;
        -:  439:
    #####:  440:      node->right = NULL;
        -:  441:
    #####:  442:      *min_gap = child->right->start;
    #####:  443:      *max_gap = child->right->end;
        -:  444:
    #####:  445:      yr_re_node_destroy(node);
call    0 never executed
        -:  446:
    #####:  447:      return ERROR_SUCCESS;
        -:  448:    }
        -:  449:
        -:  450:    parent = node;
        -:  451:    node = child;
    #####:  452:    child = child->left;
        -:  453:  }
        -:  454:
        -:  455:  return ERROR_SUCCESS;
        -:  456:}
        -:  457:
        -:  458:
function _yr_emit_inst called 0 returned 0% blocks executed 0%
    #####:  459:int _yr_emit_inst(
        -:  460:    RE_EMIT_CONTEXT* emit_context,
        -:  461:    uint8_t opcode,
        -:  462:    uint8_t** instruction_addr,
        -:  463:    size_t* code_size)
        -:  464:{
    #####:  465:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
branch 16 never executed
branch 17 never executed
call   18 never executed
branch 19 never executed
branch 20 never executed
call   21 never executed
branch 22 never executed
branch 23 never executed
call   24 never executed
branch 25 never executed
branch 26 never executed
call   27 never executed
branch 28 never executed
branch 29 never executed
call   30 never executed
branch 31 never executed
branch 32 never executed
call   33 never executed
branch 34 never executed
branch 35 never executed
call   36 never executed
branch 37 never executed
branch 38 never executed
call   39 never executed
branch 40 never executed
branch 41 never executed
        -:  466:      emit_context->arena,
        -:  467:      &opcode,
        -:  468:      sizeof(uint8_t),
        -:  469:      (void**) instruction_addr));
        -:  470:
    #####:  471:  *code_size = sizeof(uint8_t);
        -:  472:
    #####:  473:  return ERROR_SUCCESS;
        -:  474:}
        -:  475:
        -:  476:
function _yr_emit_inst_arg_uint8 called 0 returned 0% blocks executed 0%
    #####:  477:int _yr_emit_inst_arg_uint8(
        -:  478:    RE_EMIT_CONTEXT* emit_context,
        -:  479:    uint8_t opcode,
        -:  480:    uint8_t argument,
        -:  481:    uint8_t** instruction_addr,
        -:  482:    uint8_t** argument_addr,
        -:  483:    size_t* code_size)
        -:  484:{
    #####:  485:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  486:      emit_context->arena,
        -:  487:      &opcode,
        -:  488:      sizeof(uint8_t),
        -:  489:      (void**) instruction_addr));
        -:  490:
    #####:  491:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  492:      emit_context->arena,
        -:  493:      &argument,
        -:  494:      sizeof(uint8_t),
        -:  495:      (void**) argument_addr));
        -:  496:
    #####:  497:  *code_size = 2 * sizeof(uint8_t);
        -:  498:
    #####:  499:  return ERROR_SUCCESS;
        -:  500:}
        -:  501:
        -:  502:
function _yr_emit_inst_arg_uint16 called 0 returned 0% blocks executed 0%
    #####:  503:int _yr_emit_inst_arg_uint16(
        -:  504:    RE_EMIT_CONTEXT* emit_context,
        -:  505:    uint8_t opcode,
        -:  506:    uint16_t argument,
        -:  507:    uint8_t** instruction_addr,
        -:  508:    uint16_t** argument_addr,
        -:  509:    size_t* code_size)
        -:  510:{
    #####:  511:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  512:      emit_context->arena,
        -:  513:      &opcode,
        -:  514:      sizeof(uint8_t),
        -:  515:      (void**) instruction_addr));
        -:  516:
    #####:  517:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  518:      emit_context->arena,
        -:  519:      &argument,
        -:  520:      sizeof(uint16_t),
        -:  521:      (void**) argument_addr));
        -:  522:
    #####:  523:  *code_size = sizeof(uint8_t) + sizeof(uint16_t);
        -:  524:
    #####:  525:  return ERROR_SUCCESS;
        -:  526:}
        -:  527:
        -:  528:
function _yr_emit_inst_arg_uint32 called 0 returned 0% blocks executed 0%
    #####:  529:int _yr_emit_inst_arg_uint32(
        -:  530:    RE_EMIT_CONTEXT* emit_context,
        -:  531:    uint8_t opcode,
        -:  532:    uint32_t argument,
        -:  533:    uint8_t** instruction_addr,
        -:  534:    uint32_t** argument_addr,
        -:  535:    size_t* code_size)
        -:  536:{
    #####:  537:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  538:      emit_context->arena,
        -:  539:      &opcode,
        -:  540:      sizeof(uint8_t),
        -:  541:      (void**) instruction_addr));
        -:  542:
    #####:  543:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  544:      emit_context->arena,
        -:  545:      &argument,
        -:  546:      sizeof(uint32_t),
        -:  547:      (void**) argument_addr));
        -:  548:
    #####:  549:  *code_size = sizeof(uint8_t) + sizeof(uint32_t);
        -:  550:
    #####:  551:  return ERROR_SUCCESS;
        -:  552:}
        -:  553:
        -:  554:
function _yr_emit_inst_arg_int16 called 0 returned 0% blocks executed 0%
    #####:  555:int _yr_emit_inst_arg_int16(
        -:  556:    RE_EMIT_CONTEXT* emit_context,
        -:  557:    uint8_t opcode,
        -:  558:    int16_t argument,
        -:  559:    uint8_t** instruction_addr,
        -:  560:    int16_t** argument_addr,
        -:  561:    size_t* code_size)
        -:  562:{
    #####:  563:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  564:      emit_context->arena,
        -:  565:      &opcode,
        -:  566:      sizeof(uint8_t),
        -:  567:      (void**) instruction_addr));
        -:  568:
    #####:  569:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  570:      emit_context->arena,
        -:  571:      &argument,
        -:  572:      sizeof(int16_t),
        -:  573:      (void**) argument_addr));
        -:  574:
    #####:  575:  *code_size = sizeof(uint8_t) + sizeof(int16_t);
        -:  576:
    #####:  577:  return ERROR_SUCCESS;
        -:  578:}
        -:  579:
        -:  580:
function _yr_emit_inst_arg_struct called 0 returned 0% blocks executed 0%
    #####:  581:int _yr_emit_inst_arg_struct(
        -:  582:    RE_EMIT_CONTEXT* emit_context,
        -:  583:    uint8_t opcode,
        -:  584:    void* structure,
        -:  585:    size_t structure_size,
        -:  586:    uint8_t** instruction_addr,
        -:  587:    void** argument_addr,
        -:  588:    size_t* code_size)
        -:  589:{
    #####:  590:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  591:      emit_context->arena,
        -:  592:      &opcode,
        -:  593:      sizeof(uint8_t),
        -:  594:      (void**) instruction_addr));
        -:  595:
    #####:  596:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  597:      emit_context->arena,
        -:  598:      structure,
        -:  599:      structure_size,
        -:  600:      (void**) argument_addr));
        -:  601:
    #####:  602:  *code_size = sizeof(uint8_t) + structure_size;
        -:  603:
    #####:  604:  return ERROR_SUCCESS;
        -:  605:}
        -:  606:
        -:  607:
function _yr_emit_split called 0 returned 0% blocks executed 0%
    #####:  608:int _yr_emit_split(
        -:  609:    RE_EMIT_CONTEXT* emit_context,
        -:  610:    uint8_t opcode,
        -:  611:    int16_t argument,
        -:  612:    uint8_t** instruction_addr,
        -:  613:    int16_t** argument_addr,
        -:  614:    size_t* code_size)
        -:  615:{
    #####:  616:  assert(opcode == RE_OPCODE_SPLIT_A || opcode == RE_OPCODE_SPLIT_B);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  617:
    #####:  618:  if (emit_context->next_split_id == RE_MAX_SPLIT_ID)
branch  0 never executed
branch  1 never executed
        -:  619:    return ERROR_REGULAR_EXPRESSION_TOO_COMPLEX;
        -:  620:
    #####:  621:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  622:      emit_context->arena,
        -:  623:      &opcode,
        -:  624:      sizeof(uint8_t),
        -:  625:      (void**) instruction_addr));
        -:  626:
    #####:  627:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  628:      emit_context->arena,
        -:  629:      &emit_context->next_split_id,
        -:  630:      sizeof(RE_SPLIT_ID_TYPE),
        -:  631:      NULL));
        -:  632:
    #####:  633:  emit_context->next_split_id++;
        -:  634:
    #####:  635:  FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  636:      emit_context->arena,
        -:  637:      &argument,
        -:  638:      sizeof(int16_t),
        -:  639:      (void**) argument_addr));
        -:  640:
    #####:  641:  *code_size = sizeof(uint8_t) + sizeof(RE_SPLIT_ID_TYPE) + sizeof(int16_t);
        -:  642:
    #####:  643:  return ERROR_SUCCESS;
        -:  644:}
        -:  645:
        -:  646:
function _yr_re_emit called 0 returned 0% blocks executed 0%
    #####:  647:static int _yr_re_emit(
        -:  648:    RE_EMIT_CONTEXT* emit_context,
        -:  649:    RE_NODE* re_node,
        -:  650:    int flags,
        -:  651:    uint8_t** code_addr,
        -:  652:    size_t* code_size)
        -:  653:{
        -:  654:  size_t branch_size;
        -:  655:  size_t split_size;
        -:  656:  size_t inst_size;
        -:  657:  size_t jmp_size;
        -:  658:
        -:  659:  bool emit_split;
        -:  660:  bool emit_repeat;
        -:  661:  bool emit_prolog;
        -:  662:  bool emit_epilog;
        -:  663:
        -:  664:  RE_REPEAT_ARGS repeat_args;
        -:  665:  RE_REPEAT_ARGS* repeat_start_args_addr;
        -:  666:  RE_REPEAT_ANY_ARGS repeat_any_args;
        -:  667:
        -:  668:  RE_NODE* left;
        -:  669:  RE_NODE* right;
        -:  670:
    #####:  671:  int16_t* split_offset_addr = NULL;
    #####:  672:  int16_t* jmp_offset_addr = NULL;
    #####:  673:  uint8_t* instruction_addr = NULL;
        -:  674:
    #####:  675:  *code_size = 0;
        -:  676:
    #####:  677:  switch(re_node->type)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  678:  {
    #####:  679:  case RE_NODE_LITERAL:
        -:  680:
    #####:  681:    FAIL_ON_ERROR(_yr_emit_inst_arg_uint8(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  682:        emit_context,
        -:  683:        RE_OPCODE_LITERAL,
        -:  684:        re_node->value,
        -:  685:        &instruction_addr,
        -:  686:        NULL,
        -:  687:        code_size));
        -:  688:    break;
        -:  689:
    #####:  690:  case RE_NODE_MASKED_LITERAL:
        -:  691:
    #####:  692:    FAIL_ON_ERROR(_yr_emit_inst_arg_uint16(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  693:        emit_context,
        -:  694:        RE_OPCODE_MASKED_LITERAL,
        -:  695:        re_node->mask << 8 | re_node->value,
        -:  696:        &instruction_addr,
        -:  697:        NULL,
        -:  698:        code_size));
        -:  699:    break;
        -:  700:
    #####:  701:  case RE_NODE_WORD_CHAR:
        -:  702:
        -:  703:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  704:        emit_context,
        -:  705:        RE_OPCODE_WORD_CHAR,
        -:  706:        &instruction_addr,
        -:  707:        code_size));
        -:  708:    break;
        -:  709:
    #####:  710:  case RE_NODE_NON_WORD_CHAR:
        -:  711:
        -:  712:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  713:        emit_context,
        -:  714:        RE_OPCODE_NON_WORD_CHAR,
        -:  715:        &instruction_addr,
        -:  716:        code_size));
        -:  717:    break;
        -:  718:
    #####:  719:  case RE_NODE_WORD_BOUNDARY:
        -:  720:
        -:  721:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  722:        emit_context,
        -:  723:        RE_OPCODE_WORD_BOUNDARY,
        -:  724:        &instruction_addr,
        -:  725:        code_size));
        -:  726:    break;
        -:  727:
    #####:  728:  case RE_NODE_NON_WORD_BOUNDARY:
        -:  729:
        -:  730:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  731:        emit_context,
        -:  732:        RE_OPCODE_NON_WORD_BOUNDARY,
        -:  733:        &instruction_addr,
        -:  734:        code_size));
        -:  735:    break;
        -:  736:
    #####:  737:  case RE_NODE_SPACE:
        -:  738:
        -:  739:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  740:        emit_context,
        -:  741:        RE_OPCODE_SPACE,
        -:  742:        &instruction_addr,
        -:  743:        code_size));
        -:  744:    break;
        -:  745:
    #####:  746:  case RE_NODE_NON_SPACE:
        -:  747:
        -:  748:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  749:        emit_context,
        -:  750:        RE_OPCODE_NON_SPACE,
        -:  751:        &instruction_addr,
        -:  752:        code_size));
        -:  753:    break;
        -:  754:
    #####:  755:  case RE_NODE_DIGIT:
        -:  756:
        -:  757:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  758:        emit_context,
        -:  759:        RE_OPCODE_DIGIT,
        -:  760:        &instruction_addr,
        -:  761:        code_size));
        -:  762:    break;
        -:  763:
    #####:  764:  case RE_NODE_NON_DIGIT:
        -:  765:
        -:  766:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  767:        emit_context,
        -:  768:        RE_OPCODE_NON_DIGIT,
        -:  769:        &instruction_addr,
        -:  770:        code_size));
        -:  771:    break;
        -:  772:
    #####:  773:  case RE_NODE_ANY:
        -:  774:
        -:  775:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  776:        emit_context,
        -:  777:        RE_OPCODE_ANY,
        -:  778:        &instruction_addr,
        -:  779:        code_size));
        -:  780:    break;
        -:  781:
    #####:  782:  case RE_NODE_CLASS:
        -:  783:
        -:  784:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  785:        emit_context,
        -:  786:        RE_OPCODE_CLASS,
        -:  787:        &instruction_addr,
        -:  788:        code_size));
        -:  789:
    #####:  790:    FAIL_ON_ERROR(yr_arena_write_data(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  791:        emit_context->arena,
        -:  792:        re_node->re_class,
        -:  793:        sizeof(*re_node->re_class),
        -:  794:        NULL));
        -:  795:
    #####:  796:    *code_size += sizeof(*re_node->re_class);
    #####:  797:    break;
        -:  798:
    #####:  799:  case RE_NODE_ANCHOR_START:
        -:  800:
        -:  801:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  802:        emit_context,
        -:  803:        RE_OPCODE_MATCH_AT_START,
        -:  804:        &instruction_addr,
        -:  805:        code_size));
        -:  806:    break;
        -:  807:
    #####:  808:  case RE_NODE_ANCHOR_END:
        -:  809:
        -:  810:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  811:        emit_context,
        -:  812:        RE_OPCODE_MATCH_AT_END,
        -:  813:        &instruction_addr,
        -:  814:        code_size));
        -:  815:    break;
        -:  816:
    #####:  817:  case RE_NODE_CONCAT:
        -:  818:
    #####:  819:    if (flags & EMIT_BACKWARDS)
branch  0 never executed
branch  1 never executed
        -:  820:    {
    #####:  821:      left = re_node->right;
    #####:  822:      right = re_node->left;
        -:  823:    }
        -:  824:    else
        -:  825:    {
    #####:  826:      left = re_node->left;
    #####:  827:      right = re_node->right;
        -:  828:    }
        -:  829:
    #####:  830:    FAIL_ON_ERROR(_yr_re_emit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  831:        emit_context,
        -:  832:        left,
        -:  833:        flags,
        -:  834:        &instruction_addr,
        -:  835:        &branch_size));
        -:  836:
    #####:  837:    *code_size += branch_size;
        -:  838:
    #####:  839:    FAIL_ON_ERROR(_yr_re_emit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  840:        emit_context,
        -:  841:        right,
        -:  842:        flags,
        -:  843:        NULL,
        -:  844:        &branch_size));
        -:  845:
    #####:  846:    *code_size += branch_size;
        -:  847:
    #####:  848:    break;
        -:  849:
    #####:  850:  case RE_NODE_PLUS:
        -:  851:
        -:  852:    // Code for e+ looks like:
        -:  853:    //
        -:  854:    //          L1: code for e
        -:  855:    //              split L1, L2
        -:  856:    //          L2:
        -:  857:
    #####:  858:    FAIL_ON_ERROR(_yr_re_emit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  859:        emit_context,
        -:  860:        re_node->left,
        -:  861:        flags,
        -:  862:        &instruction_addr,
        -:  863:        &branch_size));
        -:  864:
    #####:  865:    *code_size += branch_size;
        -:  866:
    #####:  867:    FAIL_ON_ERROR(_yr_emit_split(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  868:        emit_context,
        -:  869:        re_node->greedy ? RE_OPCODE_SPLIT_B : RE_OPCODE_SPLIT_A,
        -:  870:        -((int16_t) branch_size),
        -:  871:        NULL,
        -:  872:        &split_offset_addr,
        -:  873:        &split_size));
        -:  874:
    #####:  875:    *code_size += split_size;
    #####:  876:    break;
        -:  877:
    #####:  878:  case RE_NODE_STAR:
        -:  879:
        -:  880:    // Code for e* looks like:
        -:  881:    //
        -:  882:    //          L1: split L1, L2
        -:  883:    //              code for e
        -:  884:    //              jmp L1
        -:  885:    //          L2:
        -:  886:
    #####:  887:    FAIL_ON_ERROR(_yr_emit_split(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  888:        emit_context,
        -:  889:        re_node->greedy ? RE_OPCODE_SPLIT_A : RE_OPCODE_SPLIT_B,
        -:  890:        0,
        -:  891:        &instruction_addr,
        -:  892:        &split_offset_addr,
        -:  893:        &split_size));
        -:  894:
    #####:  895:    *code_size += split_size;
        -:  896:
    #####:  897:    FAIL_ON_ERROR(_yr_re_emit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  898:        emit_context,
        -:  899:        re_node->left,
        -:  900:        flags,
        -:  901:        NULL,
        -:  902:        &branch_size));
        -:  903:
    #####:  904:    *code_size += branch_size;
        -:  905:
        -:  906:    // Emit jump with offset set to 0.
        -:  907:
    #####:  908:    FAIL_ON_ERROR(_yr_emit_inst_arg_int16(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  909:        emit_context,
        -:  910:        RE_OPCODE_JUMP,
        -:  911:        -((uint16_t)(branch_size + split_size)),
        -:  912:        NULL,
        -:  913:        &jmp_offset_addr,
        -:  914:        &jmp_size));
        -:  915:
    #####:  916:    *code_size += jmp_size;
        -:  917:
    #####:  918:    if (split_size + branch_size + jmp_size >= INT16_MAX)
branch  0 never executed
branch  1 never executed
        -:  919:      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;
        -:  920:
        -:  921:    // Update split offset.
    #####:  922:    *split_offset_addr = (int16_t) (split_size + branch_size + jmp_size);
    #####:  923:    break;
        -:  924:
    #####:  925:  case RE_NODE_ALT:
        -:  926:
        -:  927:    // Code for e1|e2 looks like:
        -:  928:    //
        -:  929:    //              split L1, L2
        -:  930:    //          L1: code for e1
        -:  931:    //              jmp L3
        -:  932:    //          L2: code for e2
        -:  933:    //          L3:
        -:  934:
        -:  935:    // Emit a split instruction with offset set to 0 temporarily. Offset
        -:  936:    // will be updated after we know the size of the code generated for
        -:  937:    // the left node (e1).
        -:  938:
    #####:  939:    FAIL_ON_ERROR(_yr_emit_split(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  940:        emit_context,
        -:  941:        RE_OPCODE_SPLIT_A,
        -:  942:        0,
        -:  943:        &instruction_addr,
        -:  944:        &split_offset_addr,
        -:  945:        &split_size));
        -:  946:
    #####:  947:    *code_size += split_size;
        -:  948:
    #####:  949:    FAIL_ON_ERROR(_yr_re_emit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  950:        emit_context,
        -:  951:        re_node->left,
        -:  952:        flags,
        -:  953:        NULL,
        -:  954:        &branch_size));
        -:  955:
    #####:  956:    *code_size += branch_size;
        -:  957:
        -:  958:    // Emit jump with offset set to 0.
        -:  959:
    #####:  960:    FAIL_ON_ERROR(_yr_emit_inst_arg_int16(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  961:        emit_context,
        -:  962:        RE_OPCODE_JUMP,
        -:  963:        0,
        -:  964:        NULL,
        -:  965:        &jmp_offset_addr,
        -:  966:        &jmp_size));
        -:  967:
    #####:  968:    *code_size += jmp_size;
        -:  969:
    #####:  970:    if (split_size + branch_size + jmp_size >= INT16_MAX)
branch  0 never executed
branch  1 never executed
        -:  971:      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;
        -:  972:
        -:  973:    // Update split offset.
    #####:  974:    *split_offset_addr = (int16_t) (split_size + branch_size + jmp_size);
        -:  975:
    #####:  976:    FAIL_ON_ERROR(_yr_re_emit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  977:        emit_context,
        -:  978:        re_node->right,
        -:  979:        flags,
        -:  980:        NULL,
        -:  981:        &branch_size));
        -:  982:
    #####:  983:    *code_size += branch_size;
        -:  984:
    #####:  985:    if (branch_size + jmp_size >= INT16_MAX)
branch  0 never executed
branch  1 never executed
        -:  986:      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;
        -:  987:
        -:  988:    // Update offset for jmp instruction.
    #####:  989:    *jmp_offset_addr = (int16_t) (branch_size + jmp_size);
    #####:  990:    break;
        -:  991:
    #####:  992:  case RE_NODE_RANGE_ANY:
        -:  993:
    #####:  994:    repeat_any_args.min = re_node->start;
    #####:  995:    repeat_any_args.max = re_node->end;
        -:  996:
    #####:  997:    FAIL_ON_ERROR(_yr_emit_inst_arg_struct(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  998:        emit_context,
        -:  999:        re_node->greedy ?
        -: 1000:            RE_OPCODE_REPEAT_ANY_GREEDY :
        -: 1001:            RE_OPCODE_REPEAT_ANY_UNGREEDY,
        -: 1002:        &repeat_any_args,
        -: 1003:        sizeof(repeat_any_args),
        -: 1004:        &instruction_addr,
        -: 1005:        NULL,
        -: 1006:        &inst_size));
        -: 1007:
    #####: 1008:    *code_size += inst_size;
    #####: 1009:    break;
        -: 1010:
    #####: 1011:  case RE_NODE_RANGE:
        -: 1012:
        -: 1013:    // Code for e{n,m} looks like:
        -: 1014:    //
        -: 1015:    //            code for e              ---   prolog
        -: 1016:    //            repeat_start n, m, L1   --+
        -: 1017:    //        L0: code for e                |   repeat
        -: 1018:    //            repeat_end n, m, L0     --+
        -: 1019:    //        L1: split L2, L3            ---   split
        -: 1020:    //        L2: code for e              ---   epilog
        -: 1021:    //        L3:
        -: 1022:    //
        -: 1023:    // Not all sections (prolog, repeat, split and epilog) are generated in all
        -: 1024:    // cases, it depends on the values of n and m. The following table shows
        -: 1025:    // which sections are generated for the first few values of n and m.
        -: 1026:    //
        -: 1027:    //        n,m   prolog  repeat      split  epilog
        -: 1028:    //                      (min,max)
        -: 1029:    //        ---------------------------------------
        -: 1030:    //        0,0     -       -           -      -
        -: 1031:    //        0,1     -       -           X      X
        -: 1032:    //        0,2     -       0,1         X      X
        -: 1033:    //        0,3     -       0,2         X      X
        -: 1034:    //        0,M     -       0,M-1       X      X
        -: 1035:    //
        -: 1036:    //        1,1     X       -           -      -
        -: 1037:    //        1,2     X       -           X      X
        -: 1038:    //        1,3     X       0,1         X      X
        -: 1039:    //        1,4     X       1,2         X      X
        -: 1040:    //        1,M     X       1,M-2       X      X
        -: 1041:    //
        -: 1042:    //        2,2     X       -           -      X
        -: 1043:    //        2,3     X       1,1         X      X
        -: 1044:    //        2,4     X       1,2         X      X
        -: 1045:    //        2,M     X       1,M-2       X      X
        -: 1046:    //
        -: 1047:    //        3,3     X       1,1         -      X
        -: 1048:    //        3,4     X       2,2         X      X
        -: 1049:    //        3,M     X       2,M-2       X      X
        -: 1050:    //
        -: 1051:    //        4,4     X       2,2         -      X
        -: 1052:    //        4,5     X       3,3         X      X
        -: 1053:    //        4,M     X       3,M-2       X      X
        -: 1054:    //
        -: 1055:    // The code can't consists simply in the repeat section, the prolog and
        -: 1056:    // epilog are required because we can't have atoms pointing to code inside
        -: 1057:    // the repeat loop. Atoms' forwards_code will point to code in the prolog
        -: 1058:    // and backwards_code will point to code in the epilog (or in prolog if
        -: 1059:    // epilog wasn't generated, like in n=1,m=1)
        -: 1060:
    #####: 1061:    emit_prolog = re_node->start > 0;
    #####: 1062:    emit_repeat = re_node->end > re_node->start + 1 || re_node->end > 2;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1063:    emit_split = re_node->end > re_node->start;
    #####: 1064:    emit_epilog = re_node->end > re_node->start || re_node->end > 1;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1065:
    #####: 1066:    if (emit_prolog)
branch  0 never executed
branch  1 never executed
        -: 1067:    {
    #####: 1068:      FAIL_ON_ERROR(_yr_re_emit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1069:          emit_context,
        -: 1070:          re_node->left,
        -: 1071:          flags,
        -: 1072:          &instruction_addr,
        -: 1073:          &branch_size));
        -: 1074:
    #####: 1075:       *code_size += branch_size;
        -: 1076:    }
        -: 1077:
    #####: 1078:    if (emit_repeat)
branch  0 never executed
branch  1 never executed
        -: 1079:    {
    #####: 1080:      repeat_args.min = re_node->start;
    #####: 1081:      repeat_args.max = re_node->end;
        -: 1082:
    #####: 1083:      if (emit_prolog)
branch  0 never executed
branch  1 never executed
        -: 1084:      {
    #####: 1085:        repeat_args.max--;
    #####: 1086:        repeat_args.min--;
        -: 1087:      }
        -: 1088:
    #####: 1089:      if (emit_split)
branch  0 never executed
branch  1 never executed
        -: 1090:      {
    #####: 1091:        repeat_args.max--;
        -: 1092:      }
        -: 1093:      else
        -: 1094:      {
    #####: 1095:        repeat_args.min--;
    #####: 1096:        repeat_args.max--;
        -: 1097:      }
        -: 1098:
    #####: 1099:      repeat_args.offset = 0;
        -: 1100:
    #####: 1101:      FAIL_ON_ERROR(_yr_emit_inst_arg_struct(
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 1102:          emit_context,
        -: 1103:          re_node->greedy ?
        -: 1104:              RE_OPCODE_REPEAT_START_GREEDY :
        -: 1105:              RE_OPCODE_REPEAT_START_UNGREEDY,
        -: 1106:          &repeat_args,
        -: 1107:          sizeof(repeat_args),
        -: 1108:          emit_prolog ? NULL : &instruction_addr,
        -: 1109:          (void**) &repeat_start_args_addr,
        -: 1110:          &inst_size));
        -: 1111:
    #####: 1112:      *code_size += inst_size;
        -: 1113:
    #####: 1114:      FAIL_ON_ERROR(_yr_re_emit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1115:          emit_context,
        -: 1116:          re_node->left,
        -: 1117:          flags | EMIT_DONT_SET_FORWARDS_CODE | EMIT_DONT_SET_BACKWARDS_CODE,
        -: 1118:          NULL,
        -: 1119:          &branch_size));
        -: 1120:
    #####: 1121:      *code_size += branch_size;
        -: 1122:
    #####: 1123:      repeat_start_args_addr->offset = (int32_t)(2 * inst_size + branch_size);
    #####: 1124:      repeat_args.offset = -((int32_t) branch_size);
        -: 1125:
    #####: 1126:      FAIL_ON_ERROR(_yr_emit_inst_arg_struct(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1127:          emit_context,
        -: 1128:          re_node->greedy ?
        -: 1129:              RE_OPCODE_REPEAT_END_GREEDY :
        -: 1130:              RE_OPCODE_REPEAT_END_UNGREEDY,
        -: 1131:          &repeat_args,
        -: 1132:          sizeof(repeat_args),
        -: 1133:          NULL,
        -: 1134:          NULL,
        -: 1135:          &inst_size));
        -: 1136:
    #####: 1137:      *code_size += inst_size;
        -: 1138:    }
        -: 1139:
    #####: 1140:    if (emit_split)
branch  0 never executed
branch  1 never executed
        -: 1141:    {
    #####: 1142:      FAIL_ON_ERROR(_yr_emit_split(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1143:          emit_context,
        -: 1144:          re_node->greedy ?
        -: 1145:              RE_OPCODE_SPLIT_A :
        -: 1146:              RE_OPCODE_SPLIT_B,
        -: 1147:          0,
        -: 1148:          NULL,
        -: 1149:          &split_offset_addr,
        -: 1150:          &split_size));
        -: 1151:
    #####: 1152:      *code_size += split_size;
        -: 1153:    }
        -: 1154:
    #####: 1155:    if (emit_epilog)
branch  0 never executed
branch  1 never executed
        -: 1156:    {
    #####: 1157:      FAIL_ON_ERROR(_yr_re_emit(
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 1158:          emit_context,
        -: 1159:          re_node->left,
        -: 1160:          emit_prolog ? flags | EMIT_DONT_SET_FORWARDS_CODE : flags,
        -: 1161:          emit_prolog || emit_repeat ? NULL : &instruction_addr,
        -: 1162:          &branch_size));
        -: 1163:
    #####: 1164:      *code_size += branch_size;
        -: 1165:    }
        -: 1166:
    #####: 1167:    if (emit_split)
branch  0 never executed
branch  1 never executed
        -: 1168:    {
    #####: 1169:      if (split_size + branch_size >= INT16_MAX)
branch  0 never executed
branch  1 never executed
        -: 1170:        return ERROR_REGULAR_EXPRESSION_TOO_LARGE;
        -: 1171:
    #####: 1172:      *split_offset_addr = (int16_t) (split_size + branch_size);
        -: 1173:    }
        -: 1174:
        -: 1175:    break;
        -: 1176:  }
        -: 1177:
    #####: 1178:  if (flags & EMIT_BACKWARDS)
branch  0 never executed
branch  1 never executed
        -: 1179:  {
    #####: 1180:    if (!(flags & EMIT_DONT_SET_BACKWARDS_CODE))
branch  0 never executed
branch  1 never executed
    #####: 1181:      re_node->backward_code = instruction_addr + *code_size;
        -: 1182:  }
        -: 1183:  else
        -: 1184:  {
    #####: 1185:    if (!(flags & EMIT_DONT_SET_FORWARDS_CODE))
branch  0 never executed
branch  1 never executed
    #####: 1186:      re_node->forward_code = instruction_addr;
        -: 1187:  }
        -: 1188:
    #####: 1189:  if (code_addr != NULL)
branch  0 never executed
branch  1 never executed
    #####: 1190:    *code_addr = instruction_addr;
        -: 1191:
        -: 1192:  return ERROR_SUCCESS;
        -: 1193:}
        -: 1194:
        -: 1195:
function yr_re_ast_emit_code called 0 returned 0% blocks executed 0%
    #####: 1196:int yr_re_ast_emit_code(
        -: 1197:    RE_AST* re_ast,
        -: 1198:    YR_ARENA* arena,
        -: 1199:    int backwards_code)
        -: 1200:{
        -: 1201:  RE_EMIT_CONTEXT emit_context;
        -: 1202:
        -: 1203:  size_t code_size;
        -: 1204:  size_t total_size;
        -: 1205:
        -: 1206:  // Ensure that we have enough contiguous memory space in the arena to
        -: 1207:  // contain the regular expression code. The code can't span over multiple
        -: 1208:  // non-contiguous pages.
        -: 1209:
    #####: 1210:  FAIL_ON_ERROR(yr_arena_reserve_memory(arena, RE_MAX_CODE_SIZE));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1211:
        -: 1212:  // Emit code for matching the regular expressions forwards.
        -: 1213:
        -: 1214:  total_size = 0;
    #####: 1215:  emit_context.arena = arena;
    #####: 1216:  emit_context.next_split_id = 0;
        -: 1217:
    #####: 1218:  FAIL_ON_ERROR(_yr_re_emit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1219:      &emit_context,
        -: 1220:      re_ast->root_node,
        -: 1221:      backwards_code ? EMIT_BACKWARDS : 0,
        -: 1222:      NULL,
        -: 1223:      &code_size));
        -: 1224:
    #####: 1225:  total_size += code_size;
        -: 1226:
        -: 1227:  FAIL_ON_ERROR(_yr_emit_inst(
        -: 1228:      &emit_context,
        -: 1229:      RE_OPCODE_MATCH,
        -: 1230:      NULL,
        -: 1231:      &code_size));
        -: 1232:
    #####: 1233:  total_size += code_size;
        -: 1234:
    #####: 1235:  if (total_size > RE_MAX_CODE_SIZE)
branch  0 never executed
branch  1 never executed
        -: 1236:    return ERROR_REGULAR_EXPRESSION_TOO_LARGE;
        -: 1237:
    #####: 1238:  return ERROR_SUCCESS;
        -: 1239:}
        -: 1240:
        -: 1241:
function _yr_re_fiber_create called 0 returned 0% blocks executed 0%
    #####: 1242:static int _yr_re_fiber_create(
        -: 1243:    RE_FIBER_POOL* fiber_pool,
        -: 1244:    RE_FIBER** new_fiber)
        -: 1245:{
        -: 1246:  RE_FIBER* fiber;
        -: 1247:
    #####: 1248:  if (fiber_pool->fibers.head != NULL)
branch  0 never executed
branch  1 never executed
        -: 1249:  {
        -: 1250:    fiber = fiber_pool->fibers.head;
    #####: 1251:    fiber_pool->fibers.head = fiber->next;
        -: 1252:
    #####: 1253:    if (fiber_pool->fibers.tail == fiber)
branch  0 never executed
branch  1 never executed
    #####: 1254:      fiber_pool->fibers.tail = NULL;
        -: 1255:  }
        -: 1256:  else
        -: 1257:  {
    #####: 1258:    if (fiber_pool->fiber_count == RE_MAX_FIBERS)
branch  0 never executed
branch  1 never executed
        -: 1259:      return ERROR_TOO_MANY_RE_FIBERS;
        -: 1260:
    #####: 1261:    fiber = (RE_FIBER*) yr_malloc(sizeof(RE_FIBER));
call    0 never executed
        -: 1262:
    #####: 1263:    if (fiber == NULL)
branch  0 never executed
branch  1 never executed
        -: 1264:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1265:
    #####: 1266:    fiber_pool->fiber_count++;
        -: 1267:  }
        -: 1268:
    #####: 1269:  fiber->ip = NULL;
    #####: 1270:  fiber->sp = -1;
    #####: 1271:  fiber->rc = -1;
    #####: 1272:  fiber->next = NULL;
    #####: 1273:  fiber->prev = NULL;
        -: 1274:
    #####: 1275:  *new_fiber = fiber;
        -: 1276:
    #####: 1277:  return ERROR_SUCCESS;
        -: 1278:}
        -: 1279:
        -: 1280:
        -: 1281://
        -: 1282:// _yr_re_fiber_append
        -: 1283://
        -: 1284:// Appends 'fiber' to 'fiber_list'
        -: 1285://
        -: 1286:
function _yr_re_fiber_append called 0 returned 0% blocks executed 0%
    #####: 1287:static void _yr_re_fiber_append(
        -: 1288:    RE_FIBER_LIST* fiber_list,
        -: 1289:    RE_FIBER* fiber)
        -: 1290:{
    #####: 1291:  assert(fiber->prev == NULL);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1292:  assert(fiber->next == NULL);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1293:
    #####: 1294:  fiber->prev = fiber_list->tail;
        -: 1295:
    #####: 1296:  if (fiber_list->tail != NULL)
branch  0 never executed
branch  1 never executed
    #####: 1297:    fiber_list->tail->next = fiber;
        -: 1298:
    #####: 1299:  fiber_list->tail = fiber;
        -: 1300:
    #####: 1301:  if (fiber_list->head == NULL)
branch  0 never executed
branch  1 never executed
    #####: 1302:    fiber_list->head = fiber;
        -: 1303:
    #####: 1304:  assert(fiber_list->tail->next == NULL);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1305:  assert(fiber_list->head->prev == NULL);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1306:}
        -: 1307:
        -: 1308:
        -: 1309://
        -: 1310:// _yr_re_fiber_exists
        -: 1311://
        -: 1312:// Verifies if a fiber with the same properties (ip, rc, sp, and stack values)
        -: 1313:// than 'target_fiber' exists in 'fiber_list'. The list is iterated from
        -: 1314:// the start until 'last_fiber' (inclusive). Fibers past 'last_fiber' are not
        -: 1315:// taken into account.
        -: 1316://
        -: 1317:
function _yr_re_fiber_exists.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1318:static int _yr_re_fiber_exists(
        -: 1319:    RE_FIBER_LIST* fiber_list,
        -: 1320:    RE_FIBER* target_fiber,
        -: 1321:    RE_FIBER* last_fiber)
        -: 1322:{
    #####: 1323:  RE_FIBER* fiber = fiber_list->head;
        -: 1324:
        -: 1325:  int equal_stacks;
        -: 1326:  int i;
        -: 1327:
    #####: 1328:  if (last_fiber == NULL)
branch  0 never executed
branch  1 never executed
        -: 1329:    return false;
        -: 1330:
    #####: 1331:  while (fiber != last_fiber->next)
branch  0 never executed
branch  1 never executed
        -: 1332:  {
    #####: 1333:    if (fiber->ip == target_fiber->ip &&
branch  0 never executed
branch  1 never executed
    #####: 1334:        fiber->sp == target_fiber->sp &&
branch  0 never executed
branch  1 never executed
        -: 1335:        fiber->rc == target_fiber->rc)
        -: 1336:    {
        -: 1337:      equal_stacks = true;
        -: 1338:
    #####: 1339:      for (i = 0; i <= fiber->sp; i++)
branch  0 never executed
branch  1 never executed
        -: 1340:      {
    #####: 1341:        if (fiber->stack[i] != target_fiber->stack[i])
branch  0 never executed
branch  1 never executed
        -: 1342:        {
        -: 1343:          equal_stacks = false;
        -: 1344:          break;
        -: 1345:        }
        -: 1346:      }
        -: 1347:
    #####: 1348:      if (equal_stacks)
branch  0 never executed
branch  1 never executed
        -: 1349:        return true;
        -: 1350:    }
        -: 1351:
    #####: 1352:    fiber = fiber->next;
        -: 1353:  }
        -: 1354:
        -: 1355:  return false;
        -: 1356:}
        -: 1357:
        -: 1358:
        -: 1359://
        -: 1360:// _yr_re_fiber_split
        -: 1361://
        -: 1362:// Clones a fiber in fiber_list and inserts the cloned fiber just after.
        -: 1363:// the original one. If fiber_list is:
        -: 1364://
        -: 1365://   f1 -> f2 -> f3 -> f4
        -: 1366://
        -: 1367:// Splitting f2 will result in:
        -: 1368://
        -: 1369://   f1 -> f2 -> cloned f2 -> f3 -> f4
        -: 1370://
        -: 1371:
function _yr_re_fiber_split called 0 returned 0% blocks executed 0%
    #####: 1372:static int _yr_re_fiber_split(
        -: 1373:    RE_FIBER_LIST* fiber_list,
        -: 1374:    RE_FIBER_POOL* fiber_pool,
        -: 1375:    RE_FIBER* fiber,
        -: 1376:    RE_FIBER** new_fiber)
        -: 1377:{
        -: 1378:  int32_t i;
        -: 1379:
    #####: 1380:  FAIL_ON_ERROR(_yr_re_fiber_create(fiber_pool, new_fiber));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1381:
    #####: 1382:  (*new_fiber)->sp = fiber->sp;
    #####: 1383:  (*new_fiber)->ip = fiber->ip;
    #####: 1384:  (*new_fiber)->rc = fiber->rc;
        -: 1385:
    #####: 1386:  for (i = 0; i <= fiber->sp; i++)
branch  0 never executed
branch  1 never executed
    #####: 1387:    (*new_fiber)->stack[i] = fiber->stack[i];
        -: 1388:
    #####: 1389:  (*new_fiber)->next = fiber->next;
    #####: 1390:  (*new_fiber)->prev = fiber;
        -: 1391:
    #####: 1392:  if (fiber->next != NULL)
branch  0 never executed
branch  1 never executed
    #####: 1393:    fiber->next->prev = *new_fiber;
        -: 1394:
    #####: 1395:  fiber->next = *new_fiber;
        -: 1396:
    #####: 1397:  if (fiber_list->tail == fiber)
branch  0 never executed
branch  1 never executed
    #####: 1398:    fiber_list->tail = *new_fiber;
        -: 1399:
    #####: 1400:  assert(fiber_list->tail->next == NULL);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1401:  assert(fiber_list->head->prev == NULL);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1402:
        -: 1403:  return ERROR_SUCCESS;
        -: 1404:}
        -: 1405:
        -: 1406:
        -: 1407://
        -: 1408:// _yr_re_fiber_kill
        -: 1409://
        -: 1410:// Kills a given fiber by removing it from the fiber list and putting it
        -: 1411:// in the fiber pool.
        -: 1412://
        -: 1413:
function _yr_re_fiber_kill.isra.1 called 0 returned 0% blocks executed 0%
    #####: 1414:static RE_FIBER* _yr_re_fiber_kill(
        -: 1415:    RE_FIBER_LIST* fiber_list,
        -: 1416:    RE_FIBER_POOL* fiber_pool,
        -: 1417:    RE_FIBER* fiber)
        -: 1418:{
    #####: 1419:  RE_FIBER* next_fiber = fiber->next;
        -: 1420:
    #####: 1421:  if (fiber->prev != NULL)
branch  0 never executed
branch  1 never executed
    #####: 1422:    fiber->prev->next = next_fiber;
        -: 1423:
    #####: 1424:  if (next_fiber != NULL)
branch  0 never executed
branch  1 never executed
    #####: 1425:    next_fiber->prev = fiber->prev;
        -: 1426:
    #####: 1427:  if (fiber_pool->fibers.tail != NULL)
branch  0 never executed
branch  1 never executed
    #####: 1428:    fiber_pool->fibers.tail->next = fiber;
        -: 1429:
    #####: 1430:  if (fiber_list->tail == fiber)
branch  0 never executed
branch  1 never executed
    #####: 1431:    fiber_list->tail = fiber->prev;
        -: 1432:
    #####: 1433:  if (fiber_list->head == fiber)
branch  0 never executed
branch  1 never executed
    #####: 1434:    fiber_list->head = next_fiber;
        -: 1435:
    #####: 1436:  fiber->next = NULL;
    #####: 1437:  fiber->prev = fiber_pool->fibers.tail;
    #####: 1438:  fiber_pool->fibers.tail = fiber;
        -: 1439:
    #####: 1440:  if (fiber_pool->fibers.head == NULL)
branch  0 never executed
branch  1 never executed
    #####: 1441:    fiber_pool->fibers.head = fiber;
        -: 1442:
    #####: 1443:  return next_fiber;
        -: 1444:}
        -: 1445:
        -: 1446:
        -: 1447://
        -: 1448:// _yr_re_fiber_kill_tail
        -: 1449://
        -: 1450:// Kills all fibers from the given one up to the end of the fiber list.
        -: 1451://
        -: 1452:
        -: 1453:static void _yr_re_fiber_kill_tail(
        -: 1454:  RE_FIBER_LIST* fiber_list,
        -: 1455:  RE_FIBER_POOL* fiber_pool,
        -: 1456:  RE_FIBER* fiber)
        -: 1457:{
    #####: 1458:  RE_FIBER* prev_fiber = fiber->prev;
        -: 1459:
    #####: 1460:  if (prev_fiber != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1461:    prev_fiber->next = NULL;
        -: 1462:
    #####: 1463:  fiber->prev = fiber_pool->fibers.tail;
        -: 1464:
    #####: 1465:  if (fiber_pool->fibers.tail != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1466:    fiber_pool->fibers.tail->next = fiber;
        -: 1467:
    #####: 1468:  fiber_pool->fibers.tail = fiber_list->tail;
    #####: 1469:  fiber_list->tail = prev_fiber;
        -: 1470:
    #####: 1471:  if (fiber_list->head == fiber)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1472:    fiber_list->head = NULL;
        -: 1473:
    #####: 1474:  if (fiber_pool->fibers.head == NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1475:    fiber_pool->fibers.head = fiber;
        -: 1476:}
        -: 1477:
        -: 1478:
        -: 1479://
        -: 1480:// _yr_re_fiber_kill_all
        -: 1481://
        -: 1482:// Kills all fibers in the fiber list.
        -: 1483://
        -: 1484:
function _yr_re_fiber_kill_all called 0 returned 0% blocks executed 0%
    #####: 1485:static void _yr_re_fiber_kill_all(
        -: 1486:    RE_FIBER_LIST* fiber_list,
        -: 1487:    RE_FIBER_POOL* fiber_pool)
        -: 1488:{
    #####: 1489:  if (fiber_list->head != NULL)
branch  0 never executed
branch  1 never executed
        -: 1490:    _yr_re_fiber_kill_tail(fiber_list, fiber_pool, fiber_list->head);
    #####: 1491:}
        -: 1492:
        -: 1493:
        -: 1494://
        -: 1495:// _yr_re_fiber_sync
        -: 1496://
        -: 1497:// Executes a fiber until reaching an "matching" instruction. A "matching"
        -: 1498:// instruction is one that actually reads a byte from the input and performs
        -: 1499:// some matching. If the fiber reaches a split instruction, the new fiber is
        -: 1500:// also synced.
        -: 1501://
        -: 1502:
function _yr_re_fiber_sync called 0 returned 0% blocks executed 0%
    #####: 1503:static int _yr_re_fiber_sync(
        -: 1504:    RE_FIBER_LIST* fiber_list,
        -: 1505:    RE_FIBER_POOL* fiber_pool,
        -: 1506:    RE_FIBER* fiber_to_sync)
        -: 1507:{
        -: 1508:  // A array for keeping track of which split instructions has been already
        -: 1509:  // executed. Each split instruction within a regexp has an associated ID
        -: 1510:  // between 0 and RE_MAX_SPLIT_ID. Keeping track of executed splits is
        -: 1511:  // required to avoid infinite loops in regexps like (a*)* or (a|)*
        -: 1512:
        -: 1513:  RE_SPLIT_ID_TYPE splits_executed[RE_MAX_SPLIT_ID];
        -: 1514:  RE_SPLIT_ID_TYPE splits_executed_count = 0;
        -: 1515:  RE_SPLIT_ID_TYPE split_id, splits_executed_idx;
        -: 1516:
        -: 1517:  int split_already_executed;
        -: 1518:
        -: 1519:  RE_REPEAT_ARGS* repeat_args;
        -: 1520:  RE_REPEAT_ANY_ARGS* repeat_any_args;
        -: 1521:
        -: 1522:  RE_FIBER* fiber;
        -: 1523:  RE_FIBER* last;
        -: 1524:  RE_FIBER* next;
        -: 1525:  RE_FIBER* branch_a;
        -: 1526:  RE_FIBER* branch_b;
        -: 1527:
        -: 1528:  fiber = fiber_to_sync;
    #####: 1529:  last = fiber_to_sync->next;
        -: 1530:
    #####: 1531:  while (fiber != last)
branch  0 never executed
branch  1 never executed
        -: 1532:  {
    #####: 1533:    uint8_t opcode = *fiber->ip;
        -: 1534:
    #####: 1535:    switch (opcode)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1536:    {
    #####: 1537:      case RE_OPCODE_SPLIT_A:
        -: 1538:      case RE_OPCODE_SPLIT_B:
        -: 1539:
    #####: 1540:        split_id = *(RE_SPLIT_ID_TYPE*)(fiber->ip + 1);
        -: 1541:        split_already_executed = false;
        -: 1542:
    #####: 1543:        for (splits_executed_idx = 0;
branch  0 never executed
branch  1 never executed
        -: 1544:             splits_executed_idx < splits_executed_count;
    #####: 1545:             splits_executed_idx++)
        -: 1546:        {
    #####: 1547:          if (split_id == splits_executed[splits_executed_idx])
branch  0 never executed
branch  1 never executed
        -: 1548:          {
        -: 1549:            split_already_executed = true;
        -: 1550:            break;
        -: 1551:          }
        -: 1552:        }
        -: 1553:
    #####: 1554:        if (split_already_executed)
branch  0 never executed
branch  1 never executed
        -: 1555:        {
    #####: 1556:          fiber = _yr_re_fiber_kill(fiber_list, fiber_pool, fiber);
call    0 never executed
        -: 1557:        }
        -: 1558:        else
        -: 1559:        {
        -: 1560:          branch_a = fiber;
        -: 1561:
    #####: 1562:          FAIL_ON_ERROR(_yr_re_fiber_split(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1563:              fiber_list, fiber_pool, branch_a, &branch_b));
        -: 1564:
        -: 1565:          // With RE_OPCODE_SPLIT_A the current fiber continues at the next
        -: 1566:          // instruction in the stream (branch A), while the newly created
        -: 1567:          // fiber starts at the address indicated by the instruction (branch B)
        -: 1568:          // RE_OPCODE_SPLIT_B has the opposite behavior.
        -: 1569:
    #####: 1570:          if (opcode == RE_OPCODE_SPLIT_B)
branch  0 never executed
branch  1 never executed
    #####: 1571:            yr_swap(branch_a, branch_b, RE_FIBER*);
        -: 1572:
        -: 1573:          // Branch A continues at the next instruction
        -: 1574:
    #####: 1575:          branch_a->ip += (sizeof(RE_SPLIT_ID_TYPE) + 3);
        -: 1576:
        -: 1577:          // Branch B adds the offset encoded in the opcode to its instruction
        -: 1578:          // pointer.
        -: 1579:
    #####: 1580:          branch_b->ip += *(int16_t*)(
        -: 1581:              branch_b->ip
        -: 1582:              + 1  // opcode size
        -: 1583:              + sizeof(RE_SPLIT_ID_TYPE));
        -: 1584:
    #####: 1585:          splits_executed[splits_executed_count] = split_id;
    #####: 1586:          splits_executed_count++;
        -: 1587:        }
        -: 1588:
        -: 1589:        break;
        -: 1590:
    #####: 1591:      case RE_OPCODE_REPEAT_START_GREEDY:
        -: 1592:      case RE_OPCODE_REPEAT_START_UNGREEDY:
        -: 1593:
        -: 1594:        repeat_args = (RE_REPEAT_ARGS*)(fiber->ip + 1);
    #####: 1595:        assert(repeat_args->max > 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1596:        branch_a = fiber;
        -: 1597:
    #####: 1598:        if (repeat_args->min == 0)
branch  0 never executed
branch  1 never executed
        -: 1599:        {
    #####: 1600:          FAIL_ON_ERROR(_yr_re_fiber_split(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1601:              fiber_list, fiber_pool, branch_a, &branch_b));
        -: 1602:
    #####: 1603:          if (opcode == RE_OPCODE_REPEAT_START_UNGREEDY)
branch  0 never executed
branch  1 never executed
    #####: 1604:            yr_swap(branch_a, branch_b, RE_FIBER*);
        -: 1605:
    #####: 1606:          branch_b->ip += repeat_args->offset;
        -: 1607:        }
        -: 1608:
    #####: 1609:        branch_a->stack[++branch_a->sp] = 0;
    #####: 1610:        branch_a->ip += (1 + sizeof(RE_REPEAT_ARGS));
    #####: 1611:        break;
        -: 1612:
    #####: 1613:      case RE_OPCODE_REPEAT_END_GREEDY:
        -: 1614:      case RE_OPCODE_REPEAT_END_UNGREEDY:
        -: 1615:
        -: 1616:        repeat_args = (RE_REPEAT_ARGS*)(fiber->ip + 1);
    #####: 1617:        fiber->stack[fiber->sp]++;
        -: 1618:
    #####: 1619:        if (fiber->stack[fiber->sp] < repeat_args->min)
branch  0 never executed
branch  1 never executed
        -: 1620:        {
    #####: 1621:          fiber->ip += repeat_args->offset;
    #####: 1622:          break;
        -: 1623:        }
        -: 1624:
        -: 1625:        branch_a = fiber;
        -: 1626:
    #####: 1627:        if (fiber->stack[fiber->sp] < repeat_args->max)
branch  0 never executed
branch  1 never executed
        -: 1628:        {
    #####: 1629:          FAIL_ON_ERROR(_yr_re_fiber_split(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1630:              fiber_list, fiber_pool, branch_a, &branch_b));
        -: 1631:
    #####: 1632:          if (opcode == RE_OPCODE_REPEAT_END_GREEDY)
branch  0 never executed
branch  1 never executed
    #####: 1633:            yr_swap(branch_a, branch_b, RE_FIBER*);
        -: 1634:
    #####: 1635:          branch_a->sp--;
    #####: 1636:          branch_b->ip += repeat_args->offset;
        -: 1637:        }
        -: 1638:
    #####: 1639:        branch_a->ip += (1 + sizeof(RE_REPEAT_ARGS));
    #####: 1640:        break;
        -: 1641:
    #####: 1642:      case RE_OPCODE_REPEAT_ANY_GREEDY:
        -: 1643:      case RE_OPCODE_REPEAT_ANY_UNGREEDY:
        -: 1644:
        -: 1645:        repeat_any_args = (RE_REPEAT_ANY_ARGS*)(fiber->ip + 1);
        -: 1646:
        -: 1647:        // If repetition counter (rc) is -1 it means that we are reaching this
        -: 1648:        // instruction from the previous one in the instructions stream. In
        -: 1649:        // this case let's initialize the counter to 0 and start looping.
        -: 1650:
    #####: 1651:        if (fiber->rc == -1)
branch  0 never executed
branch  1 never executed
    #####: 1652:          fiber->rc = 0;
        -: 1653:
    #####: 1654:        if (fiber->rc < repeat_any_args->min)
branch  0 never executed
branch  1 never executed
        -: 1655:        {
        -: 1656:          // Increase repetition counter and continue with next fiber. The
        -: 1657:          // instruction pointer for this fiber is not incremented yet, this
        -: 1658:          // fiber spins in this same instruction until reaching the minimum
        -: 1659:          // number of repetitions.
        -: 1660:
    #####: 1661:          fiber->rc++;
    #####: 1662:          fiber = fiber->next;
        -: 1663:        }
    #####: 1664:        else if (fiber->rc < repeat_any_args->max)
branch  0 never executed
branch  1 never executed
        -: 1665:        {
        -: 1666:          // Once the minimum number of repetitions are matched one fiber
        -: 1667:          // remains spinning in this instruction until reaching the maximum
        -: 1668:          // number of repetitions while new fibers are created. New fibers
        -: 1669:          // start executing at the next instruction.
        -: 1670:
    #####: 1671:          next = fiber->next;
        -: 1672:          branch_a = fiber;
        -: 1673:
    #####: 1674:          FAIL_ON_ERROR(_yr_re_fiber_split(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1675:              fiber_list, fiber_pool, branch_a, &branch_b));
        -: 1676:
    #####: 1677:          if (opcode == RE_OPCODE_REPEAT_ANY_UNGREEDY)
branch  0 never executed
branch  1 never executed
    #####: 1678:            yr_swap(branch_a, branch_b, RE_FIBER*);
        -: 1679:
    #####: 1680:          branch_a->rc++;
    #####: 1681:          branch_b->ip += (1 + sizeof(RE_REPEAT_ANY_ARGS));
    #####: 1682:          branch_b->rc = -1;
        -: 1683:
    #####: 1684:          FAIL_ON_ERROR(_yr_re_fiber_sync(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1685:              fiber_list, fiber_pool, branch_b));
        -: 1686:
        -: 1687:          fiber = next;
        -: 1688:        }
        -: 1689:        else
        -: 1690:        {
        -: 1691:          // When the maximum number of repetitions is reached the fiber keeps
        -: 1692:          // executing at the next instruction. The repetition counter is set
        -: 1693:          // to -1 indicating that we are not spinning in a repeat instruction
        -: 1694:          // anymore.
        -: 1695:
    #####: 1696:          fiber->ip += (1 + sizeof(RE_REPEAT_ANY_ARGS));
    #####: 1697:          fiber->rc = -1;
        -: 1698:        }
        -: 1699:
        -: 1700:        break;
        -: 1701:
    #####: 1702:      case RE_OPCODE_JUMP:
    #####: 1703:        fiber->ip += *(int16_t*)(fiber->ip + 1);
    #####: 1704:        break;
        -: 1705:
    #####: 1706:      default:
    #####: 1707:        fiber = fiber->next;
        -: 1708:    }
        -: 1709:  }
        -: 1710:
        -: 1711:  return ERROR_SUCCESS;
        -: 1712:}
        -: 1713:
        -: 1714:
        -: 1715://
        -: 1716:// yr_re_exec
        -: 1717://
        -: 1718:// Executes a regular expression. The specified regular expression will try to
        -: 1719:// match the data starting at the address specified by "input". The "input"
        -: 1720:// pointer can point to any address inside a memory buffer. Arguments
        -: 1721:// "input_forwards_size" and "input_backwards_size" indicate how many bytes
        -: 1722:// can be accesible starting at "input" and going forwards and backwards
        -: 1723:// respectively.
        -: 1724://
        -: 1725://   <--- input_backwards_size -->|<----------- input_forwards_size -------->
        -: 1726://  |--------  memory buffer  -----------------------------------------------|
        -: 1727://                                ^
        -: 1728://                              input
        -: 1729://
        -: 1730:// Args:
        -: 1731://   YR_SCAN_CONTEXT *context         - Scan context.
        -: 1732://   const uint8_t* code              - Regexp code be executed
        -: 1733://   const uint8_t* input             - Pointer to input data
        -: 1734://   size_t input_forwards_size       - Number of accessible bytes starting at
        -: 1735://                                      "input" and going forwards.
        -: 1736://   size_t input_backwards_size      - Number of accessible bytes starting at
        -: 1737://                                      "input" and going backwards
        -: 1738://   int flags                        - Flags:
        -: 1739://      RE_FLAGS_SCAN
        -: 1740://      RE_FLAGS_BACKWARDS
        -: 1741://      RE_FLAGS_EXHAUSTIVE
        -: 1742://      RE_FLAGS_WIDE
        -: 1743://      RE_FLAGS_NO_CASE
        -: 1744://      RE_FLAGS_DOT_ALL
        -: 1745://   RE_MATCH_CALLBACK_FUNC callback  - Callback function
        -: 1746://   void* callback_args              - Callback argument
        -: 1747://   int*  matches                    - Pointer to an integer receiving the
        -: 1748://                                      number of matching bytes. Notice that
        -: 1749://                                      0 means a zero-length match, while no
        -: 1750://                                      matches is -1.
        -: 1751:// Returns:
        -: 1752://    ERROR_SUCCESS or any other error code.
        -: 1753:
function yr_re_exec called 0 returned 0% blocks executed 0%
    #####: 1754:int yr_re_exec(
        -: 1755:    YR_SCAN_CONTEXT* context,
        -: 1756:    const uint8_t* code,
        -: 1757:    const uint8_t* input_data,
        -: 1758:    size_t input_forwards_size,
        -: 1759:    size_t input_backwards_size,
        -: 1760:    int flags,
        -: 1761:    RE_MATCH_CALLBACK_FUNC callback,
        -: 1762:    void* callback_args,
        -: 1763:    int* matches)
        -: 1764:{
        -: 1765:  const uint8_t* input;
        -: 1766:  const uint8_t* ip;
        -: 1767:
        -: 1768:  uint8_t mask;
        -: 1769:  uint8_t value;
        -: 1770:  uint8_t character_size;
        -: 1771:
        -: 1772:  RE_FIBER_LIST fibers;
        -: 1773:  RE_FIBER* fiber;
        -: 1774:  RE_FIBER* next_fiber;
        -: 1775:
        -: 1776:  int bytes_matched;
        -: 1777:  int max_bytes_matched;
        -: 1778:  int match;
        -: 1779:  int input_incr;
        -: 1780:  int kill;
        -: 1781:  int action;
        -: 1782:
        -: 1783:  #define ACTION_NONE       0
        -: 1784:  #define ACTION_CONTINUE   1
        -: 1785:  #define ACTION_KILL       2
        -: 1786:  #define ACTION_KILL_TAIL  3
        -: 1787:
        -: 1788:  #define prolog { \
        -: 1789:      if ((bytes_matched >= max_bytes_matched) || \
        -: 1790:          (character_size == 2 && *(input + 1) != 0)) \
        -: 1791:      { \
        -: 1792:        action = ACTION_KILL; \
        -: 1793:        break; \
        -: 1794:      } \
        -: 1795:    }
        -: 1796:
    #####: 1797:  if (matches != NULL)
branch  0 never executed
branch  1 never executed
    #####: 1798:    *matches = -1;
        -: 1799:
    #####: 1800:  if (flags & RE_FLAGS_WIDE)
branch  0 never executed
branch  1 never executed
        -: 1801:    character_size = 2;
        -: 1802:  else
        -: 1803:    character_size = 1;
        -: 1804:
        -: 1805:  input = input_data;
    #####: 1806:  input_incr = character_size;
        -: 1807:
    #####: 1808:  if (flags & RE_FLAGS_BACKWARDS)
branch  0 never executed
branch  1 never executed
        -: 1809:  {
    #####: 1810:    max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);
branch  0 never executed
branch  1 never executed
    #####: 1811:    input -= character_size;
    #####: 1812:    input_incr = -input_incr;
        -: 1813:  }
        -: 1814:  else
        -: 1815:  {
    #####: 1816:    max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);
branch  0 never executed
branch  1 never executed
        -: 1817:  }
        -: 1818:
        -: 1819:  // Round down max_bytes_matched to a multiple of character_size, this way if
        -: 1820:  // character_size is 2 and max_bytes_matched is odd we are ignoring the
        -: 1821:  // extra byte which can't match anyways.
        -: 1822:
    #####: 1823:  max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;
        -: 1824:  bytes_matched = 0;
        -: 1825:
    #####: 1826:  FAIL_ON_ERROR(_yr_re_fiber_create(&context->re_fiber_pool, &fiber));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1827:
    #####: 1828:  fiber->ip = code;
    #####: 1829:  fibers.head = fiber;
    #####: 1830:  fibers.tail = fiber;
        -: 1831:
    #####: 1832:  FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1833:      _yr_re_fiber_sync(&fibers, &context->re_fiber_pool, fiber),
        -: 1834:      _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
        -: 1835:
    #####: 1836:  while (fibers.head != NULL)
branch  0 never executed
branch  1 never executed
        -: 1837:  {
    #####: 1838:    fiber = fibers.head;
        -: 1839:
    #####: 1840:    while (fiber != NULL)
branch  0 never executed
branch  1 never executed
        -: 1841:    {
    #####: 1842:      next_fiber = fiber->next;
        -: 1843:
    #####: 1844:      if (_yr_re_fiber_exists(&fibers, fiber, fiber->prev))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1845:        _yr_re_fiber_kill(&fibers, &context->re_fiber_pool, fiber);
call    0 never executed
        -: 1846:
    #####: 1847:      fiber = next_fiber;
        -: 1848:    }
        -: 1849:
    #####: 1850:    fiber = fibers.head;
        -: 1851:
    #####: 1852:    while (fiber != NULL)
branch  0 never executed
branch  1 never executed
        -: 1853:    {
    #####: 1854:      ip = fiber->ip;
        -: 1855:      action = ACTION_NONE;
        -: 1856:
    #####: 1857:      switch (*ip)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
        -: 1858:      {
    #####: 1859:        case RE_OPCODE_ANY:
    #####: 1860:          prolog;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1861:          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1862:          action = match ? ACTION_NONE : ACTION_KILL;
    #####: 1863:          fiber->ip += 1;
    #####: 1864:          break;
        -: 1865:
    #####: 1866:        case RE_OPCODE_REPEAT_ANY_GREEDY:
        -: 1867:        case RE_OPCODE_REPEAT_ANY_UNGREEDY:
    #####: 1868:          prolog;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1869:          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1870:          action = match ? ACTION_NONE : ACTION_KILL;
        -: 1871:
        -: 1872:          // The instruction pointer is not incremented here. The current fiber
        -: 1873:          // spins in this instruction until reaching the required number of
        -: 1874:          // repetitions. The code controlling the number of repetitions is in
        -: 1875:          // _yr_re_fiber_sync.
        -: 1876:
        -: 1877:          break;
        -: 1878:
    #####: 1879:        case RE_OPCODE_LITERAL:
    #####: 1880:          prolog;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1881:          if (flags & RE_FLAGS_NO_CASE)
branch  0 never executed
branch  1 never executed
    #####: 1882:            match = yr_lowercase[*input] == yr_lowercase[*(ip + 1)];
        -: 1883:          else
    #####: 1884:            match = (*input == *(ip + 1));
    #####: 1885:          action = match ? ACTION_NONE : ACTION_KILL;
branch  0 never executed
branch  1 never executed
    #####: 1886:          fiber->ip += 2;
    #####: 1887:          break;
        -: 1888:
    #####: 1889:        case RE_OPCODE_MASKED_LITERAL:
    #####: 1890:          prolog;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1891:          value = *(int16_t*)(ip + 1) & 0xFF;
    #####: 1892:          mask = *(int16_t*)(ip + 1) >> 8;
        -: 1893:
        -: 1894:          // We don't need to take into account the case-insensitive
        -: 1895:          // case because this opcode is only used with hex strings,
        -: 1896:          // which can't be case-insensitive.
        -: 1897:
    #####: 1898:          match = ((*input & mask) == value);
    #####: 1899:          action = match ? ACTION_NONE : ACTION_KILL;
branch  0 never executed
branch  1 never executed
    #####: 1900:          fiber->ip += 3;
    #####: 1901:          break;
        -: 1902:
    #####: 1903:        case RE_OPCODE_CLASS:
    #####: 1904:          prolog;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1905:          match = _yr_re_is_char_in_class(
    #####: 1906:              (RE_CLASS*) (ip + 1), *input, flags & RE_FLAGS_NO_CASE);
    #####: 1907:          action = match ? ACTION_NONE : ACTION_KILL;
branch  0 never executed
branch  1 never executed
    #####: 1908:          fiber->ip += (sizeof(RE_CLASS) + 1);
    #####: 1909:          break;
        -: 1910:
    #####: 1911:        case RE_OPCODE_WORD_CHAR:
    #####: 1912:          prolog;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1913:          match = _yr_re_is_word_char(input, character_size);
    #####: 1914:          action = match ? ACTION_NONE : ACTION_KILL;
branch  0 never executed
branch  1 never executed
    #####: 1915:          fiber->ip += 1;
    #####: 1916:          break;
        -: 1917:
    #####: 1918:        case RE_OPCODE_NON_WORD_CHAR:
    #####: 1919:          prolog;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1920:          match = !_yr_re_is_word_char(input, character_size);
    #####: 1921:          action = match ? ACTION_NONE : ACTION_KILL;
branch  0 never executed
branch  1 never executed
    #####: 1922:          fiber->ip += 1;
    #####: 1923:          break;
        -: 1924:
    #####: 1925:        case RE_OPCODE_SPACE:
        -: 1926:        case RE_OPCODE_NON_SPACE:
        -: 1927:
    #####: 1928:          prolog;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1929:
    #####: 1930:          switch (*input)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1931:          {
        -: 1932:            case ' ':
        -: 1933:            case '\t':
        -: 1934:            case '\r':
        -: 1935:            case '\n':
        -: 1936:            case '\v':
        -: 1937:            case '\f':
        -: 1938:              match = true;
        -: 1939:              break;
        -: 1940:            default:
        -: 1941:              match = false;
        -: 1942:          }
        -: 1943:
    #####: 1944:          if (*ip == RE_OPCODE_NON_SPACE)
branch  0 never executed
branch  1 never executed
    #####: 1945:            match = !match;
        -: 1946:
    #####: 1947:          action = match ? ACTION_NONE : ACTION_KILL;
branch  0 never executed
branch  1 never executed
    #####: 1948:          fiber->ip += 1;
    #####: 1949:          break;
        -: 1950:
    #####: 1951:        case RE_OPCODE_DIGIT:
    #####: 1952:          prolog;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1953:          match = isdigit(*input);
    #####: 1954:          action = match ? ACTION_NONE : ACTION_KILL;
branch  0 never executed
branch  1 never executed
    #####: 1955:          fiber->ip += 1;
    #####: 1956:          break;
        -: 1957:
    #####: 1958:        case RE_OPCODE_NON_DIGIT:
    #####: 1959:          prolog;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1960:          match = !isdigit(*input);
    #####: 1961:          action = match ? ACTION_NONE : ACTION_KILL;
branch  0 never executed
branch  1 never executed
    #####: 1962:          fiber->ip += 1;
    #####: 1963:          break;
        -: 1964:
    #####: 1965:        case RE_OPCODE_WORD_BOUNDARY:
        -: 1966:        case RE_OPCODE_NON_WORD_BOUNDARY:
        -: 1967:
    #####: 1968:          if (bytes_matched == 0 && input_backwards_size < character_size)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1969:          {
        -: 1970:            match = true;
        -: 1971:          }
    #####: 1972:          else if (bytes_matched >= max_bytes_matched)
branch  0 never executed
branch  1 never executed
        -: 1973:          {
        -: 1974:            match = true;
        -: 1975:          }
        -: 1976:          else
        -: 1977:          {
    #####: 1978:            assert(input <  input_data + input_forwards_size);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1979:            assert(input >= input_data - input_backwards_size);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1980:
    #####: 1981:            assert(input - input_incr <  input_data + input_forwards_size);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1982:            assert(input - input_incr >= input_data - input_backwards_size);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1983:
    #####: 1984:            match = _yr_re_is_word_char(input, character_size) != \
    #####: 1985:                    _yr_re_is_word_char(input - input_incr, character_size);
        -: 1986:          }
        -: 1987:
    #####: 1988:          if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)
branch  0 never executed
branch  1 never executed
    #####: 1989:            match = !match;
        -: 1990:
    #####: 1991:          action = match ? ACTION_CONTINUE : ACTION_KILL;
branch  0 never executed
branch  1 never executed
    #####: 1992:          fiber->ip += 1;
    #####: 1993:          break;
        -: 1994:
    #####: 1995:        case RE_OPCODE_MATCH_AT_START:
    #####: 1996:          if (flags & RE_FLAGS_BACKWARDS)
branch  0 never executed
branch  1 never executed
    #####: 1997:            kill = input_backwards_size > (size_t) bytes_matched;
        -: 1998:          else
    #####: 1999:            kill = input_backwards_size > 0 || (bytes_matched != 0);
    #####: 2000:          action = kill ? ACTION_KILL : ACTION_CONTINUE;
branch  0 never executed
branch  1 never executed
    #####: 2001:          fiber->ip += 1;
    #####: 2002:          break;
        -: 2003:
    #####: 2004:        case RE_OPCODE_MATCH_AT_END:
    #####: 2005:          kill = flags & RE_FLAGS_BACKWARDS ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2006:                 input_forwards_size > (size_t) bytes_matched;
        -: 2007:          action = kill ? ACTION_KILL : ACTION_CONTINUE;
    #####: 2008:          fiber->ip += 1;
    #####: 2009:          break;
        -: 2010:
    #####: 2011:        case RE_OPCODE_MATCH:
        -: 2012:
    #####: 2013:          if (matches != NULL)
branch  0 never executed
branch  1 never executed
    #####: 2014:            *matches = bytes_matched;
        -: 2015:
    #####: 2016:          if (flags & RE_FLAGS_EXHAUSTIVE)
branch  0 never executed
branch  1 never executed
        -: 2017:          {
    #####: 2018:            if (callback != NULL)
branch  0 never executed
branch  1 never executed
        -: 2019:            {
    #####: 2020:              if (flags & RE_FLAGS_BACKWARDS)
branch  0 never executed
branch  1 never executed
        -: 2021:              {
    #####: 2022:                FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 2023:                    callback(
        -: 2024:                        input + character_size,
        -: 2025:                        bytes_matched,
        -: 2026:                        flags,
        -: 2027:                        callback_args),
        -: 2028:                    _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
        -: 2029:              }
        -: 2030:              else
        -: 2031:              {
    #####: 2032:                FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 2033:                    callback(
        -: 2034:                        input_data,
        -: 2035:                        bytes_matched,
        -: 2036:                        flags,
        -: 2037:                        callback_args),
        -: 2038:                    _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
        -: 2039:              }
        -: 2040:            }
        -: 2041:
        -: 2042:            action = ACTION_KILL;
        -: 2043:          }
        -: 2044:          else
        -: 2045:          {
        -: 2046:            action = ACTION_KILL_TAIL;
        -: 2047:          }
        -: 2048:
        -: 2049:          break;
        -: 2050:
        -: 2051:        default:
    #####: 2052:          assert(false);
call    0 never executed
        -: 2053:      }
        -: 2054:
    #####: 2055:      switch (action)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2056:      {
    #####: 2057:        case ACTION_KILL:
    #####: 2058:          fiber = _yr_re_fiber_kill(&fibers, &context->re_fiber_pool, fiber);
call    0 never executed
    #####: 2059:          break;
        -: 2060:
    #####: 2061:        case ACTION_KILL_TAIL:
    #####: 2062:          _yr_re_fiber_kill_tail(&fibers, &context->re_fiber_pool, fiber);
    #####: 2063:          fiber = NULL;
    #####: 2064:          break;
        -: 2065:
    #####: 2066:        case ACTION_CONTINUE:
    #####: 2067:          FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 2068:              _yr_re_fiber_sync(&fibers, &context->re_fiber_pool, fiber),
        -: 2069:              _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
        -: 2070:          break;
        -: 2071:
    #####: 2072:        default:
    #####: 2073:          next_fiber = fiber->next;
    #####: 2074:          FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 2075:              _yr_re_fiber_sync(&fibers, &context->re_fiber_pool, fiber),
        -: 2076:              _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
    #####: 2077:          fiber = next_fiber;
        -: 2078:      }
        -: 2079:    }
        -: 2080:
    #####: 2081:    input += input_incr;
    #####: 2082:    bytes_matched += character_size;
        -: 2083:
    #####: 2084:    if (flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2085:    {
    #####: 2086:      FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 2087:          _yr_re_fiber_create(&context->re_fiber_pool, &fiber),
        -: 2088:          _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
        -: 2089:
    #####: 2090:      fiber->ip = code;
    #####: 2091:      _yr_re_fiber_append(&fibers, fiber);
call    0 never executed
        -: 2092:
    #####: 2093:      FAIL_ON_ERROR_WITH_CLEANUP(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 2094:          _yr_re_fiber_sync(&fibers, &context->re_fiber_pool, fiber),
        -: 2095:          _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
        -: 2096:    }
        -: 2097:  }
        -: 2098:
        -: 2099:  return ERROR_SUCCESS;
        -: 2100:}
        -: 2101:
        -: 2102://
        -: 2103:// yr_re_fast_exec
        -: 2104://
        -: 2105:// This function replaces yr_re_exec for regular expressions marked with flag
        -: 2106:// RE_FLAGS_FAST_REGEXP. These are regular expression whose code contain only
        -: 2107:// the following operations: RE_OPCODE_LITERAL, RE_OPCODE_MASKED_LITERAL,
        -: 2108:// RE_OPCODE_ANY, RE_OPCODE_REPEAT_ANY_UNGREEDY and RE_OPCODE_MATCH. Some
        -: 2109:// examples of regular expressions that can be executed with this function are:
        -: 2110://
        -: 2111://  /foobar/
        -: 2112://  /foo.*?bar/
        -: 2113://
        -: 2114:
function yr_re_fast_exec called 0 returned 0% blocks executed 0%
    #####: 2115:int yr_re_fast_exec(
        -: 2116:    YR_SCAN_CONTEXT* context,
        -: 2117:    const uint8_t* code,
        -: 2118:    const uint8_t* input_data,
        -: 2119:    size_t input_forwards_size,
        -: 2120:    size_t input_backwards_size,
        -: 2121:    int flags,
        -: 2122:    RE_MATCH_CALLBACK_FUNC callback,
        -: 2123:    void* callback_args,
        -: 2124:    int* matches)
        -: 2125:{
        -: 2126:  RE_REPEAT_ANY_ARGS* repeat_any_args;
        -: 2127:
        -: 2128:  const uint8_t* code_stack[YR_MAX_FAST_RE_STACK];
        -: 2129:  const uint8_t* input_stack[YR_MAX_FAST_RE_STACK];
        -: 2130:  int matches_stack[YR_MAX_FAST_RE_STACK];
        -: 2131:
        -: 2132:  const uint8_t* input = input_data;
        -: 2133:  const uint8_t* next_input;
        -: 2134:  const uint8_t* ip = code;
        -: 2135:  const uint8_t* next_opcode;
        -: 2136:
        -: 2137:  uint8_t mask;
        -: 2138:  uint8_t value;
        -: 2139:
        -: 2140:  int i;
        -: 2141:  int stop;
        -: 2142:  int input_incr;
        -: 2143:  int sp = 0;
        -: 2144:  int bytes_matched;
        -: 2145:  int max_bytes_matched;
        -: 2146:
    #####: 2147:  max_bytes_matched = flags & RE_FLAGS_BACKWARDS ?
    #####: 2148:      (int) input_backwards_size :
branch  0 never executed
branch  1 never executed
        -: 2149:      (int) input_forwards_size;
        -: 2150:
    #####: 2151:  input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;
branch  0 never executed
branch  1 never executed
        -: 2152:
    #####: 2153:  if (flags & RE_FLAGS_BACKWARDS)
branch  0 never executed
branch  1 never executed
    #####: 2154:    input--;
        -: 2155:
    #####: 2156:  code_stack[sp] = code;
    #####: 2157:  input_stack[sp] = input;
    #####: 2158:  matches_stack[sp] = 0;
        -: 2159:  sp++;
        -: 2160:
    #####: 2161:  while (sp > 0)
branch  0 never executed
branch  1 never executed
        -: 2162:  {
    #####: 2163:    sp--;
    #####: 2164:    ip = code_stack[sp];
    #####: 2165:    input = input_stack[sp];
    #####: 2166:    bytes_matched = matches_stack[sp];
        -: 2167:    stop = false;
        -: 2168:
    #####: 2169:    while (!stop)
branch  0 never executed
branch  1 never executed
        -: 2170:    {
    #####: 2171:      if (*ip == RE_OPCODE_MATCH)
branch  0 never executed
branch  1 never executed
        -: 2172:      {
    #####: 2173:        if (flags & RE_FLAGS_EXHAUSTIVE)
branch  0 never executed
branch  1 never executed
        -: 2174:        {
    #####: 2175:          FAIL_ON_ERROR(callback(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2176:             flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data,
        -: 2177:             bytes_matched,
        -: 2178:             flags,
        -: 2179:             callback_args));
        -: 2180:
        -: 2181:          break;
        -: 2182:        }
        -: 2183:        else
        -: 2184:        {
    #####: 2185:          if (matches != NULL)
branch  0 never executed
branch  1 never executed
    #####: 2186:            *matches = bytes_matched;
        -: 2187:
        -: 2188:          return ERROR_SUCCESS;
        -: 2189:        }
        -: 2190:      }
        -: 2191:
    #####: 2192:      if (bytes_matched >= max_bytes_matched)
branch  0 never executed
branch  1 never executed
        -: 2193:        break;
        -: 2194:
    #####: 2195:      switch (*ip)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 2196:      {
    #####: 2197:        case RE_OPCODE_LITERAL:
        -: 2198:
    #####: 2199:          if (*input == *(ip + 1))
branch  0 never executed
branch  1 never executed
        -: 2200:          {
    #####: 2201:            bytes_matched++;
    #####: 2202:            input += input_incr;
    #####: 2203:            ip += 2;
        -: 2204:          }
        -: 2205:          else
        -: 2206:          {
        -: 2207:            stop = true;
        -: 2208:          }
        -: 2209:
        -: 2210:          break;
        -: 2211:
    #####: 2212:        case RE_OPCODE_MASKED_LITERAL:
        -: 2213:
    #####: 2214:          value = *(int16_t*)(ip + 1) & 0xFF;
    #####: 2215:          mask = *(int16_t*)(ip + 1) >> 8;
        -: 2216:
    #####: 2217:          if ((*input & mask) == value)
branch  0 never executed
branch  1 never executed
        -: 2218:          {
    #####: 2219:            bytes_matched++;
    #####: 2220:            input += input_incr;
    #####: 2221:            ip += 3;
        -: 2222:          }
        -: 2223:          else
        -: 2224:          {
        -: 2225:            stop = true;
        -: 2226:          }
        -: 2227:
        -: 2228:          break;
        -: 2229:
    #####: 2230:        case RE_OPCODE_ANY:
        -: 2231:
    #####: 2232:          bytes_matched++;
    #####: 2233:          input += input_incr;
    #####: 2234:          ip += 1;
        -: 2235:
    #####: 2236:          break;
        -: 2237:
    #####: 2238:        case RE_OPCODE_REPEAT_ANY_UNGREEDY:
        -: 2239:
        -: 2240:          repeat_any_args = (RE_REPEAT_ANY_ARGS*)(ip + 1);
    #####: 2241:          next_opcode = ip + 1 + sizeof(RE_REPEAT_ANY_ARGS);
        -: 2242:
    #####: 2243:          for (i = repeat_any_args->min + 1; i <= repeat_any_args->max; i++)
branch  0 never executed
branch  1 never executed
        -: 2244:          {
    #####: 2245:            if (bytes_matched + i >= max_bytes_matched)
branch  0 never executed
branch  1 never executed
        -: 2246:              break;
        -: 2247:
    #####: 2248:            next_input = input + i * input_incr;
        -: 2249:
    #####: 2250:            if ( *(next_opcode) != RE_OPCODE_LITERAL ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2251:                (*(next_opcode) == RE_OPCODE_LITERAL &&
    #####: 2252:                 *(next_opcode + 1) == *next_input))
        -: 2253:            {
    #####: 2254:              if (sp >= YR_MAX_FAST_RE_STACK)
branch  0 never executed
branch  1 never executed
        -: 2255:                return ERROR_TOO_MANY_RE_FIBERS;
        -: 2256:
    #####: 2257:              code_stack[sp] = next_opcode;
    #####: 2258:              input_stack[sp] = next_input;
    #####: 2259:              matches_stack[sp] = bytes_matched + i;
    #####: 2260:              sp++;
        -: 2261:            }
        -: 2262:          }
        -: 2263:
    #####: 2264:          input += input_incr * repeat_any_args->min;
    #####: 2265:          bytes_matched += repeat_any_args->min;
    #####: 2266:          bytes_matched = yr_min(bytes_matched, max_bytes_matched);
        -: 2267:          ip = next_opcode;
        -: 2268:
    #####: 2269:          break;
        -: 2270:
        -: 2271:        default:
    #####: 2272:          assert(false);
call    0 never executed
        -: 2273:      }
        -: 2274:    }
        -: 2275:  }
        -: 2276:
    #####: 2277:  if (matches != NULL)
branch  0 never executed
branch  1 never executed
    #####: 2278:    *matches = -1;
        -: 2279:
        -: 2280:  return ERROR_SUCCESS;
        -: 2281:}
        -: 2282:
        -: 2283:
function _yr_re_print_node called 0 returned 0% blocks executed 0%
    #####: 2284:static void _yr_re_print_node(
        -: 2285:    RE_NODE* re_node)
        -: 2286:{
        -: 2287:  int i;
        -: 2288:
    #####: 2289:  if (re_node == NULL)
branch  0 never executed
branch  1 never executed
        -: 2290:    return;
        -: 2291:
    #####: 2292:  switch (re_node->type)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
        -: 2293:  {
        -: 2294:  case RE_NODE_ALT:
        -: 2295:    printf("Alt(");
    #####: 2296:    _yr_re_print_node(re_node->left);
call    0 never executed
        -: 2297:    printf(", ");
    #####: 2298:    _yr_re_print_node(re_node->right);
call    0 never executed
        -: 2299:    printf(")");
        -: 2300:    break;
        -: 2301:
        -: 2302:  case RE_NODE_CONCAT:
        -: 2303:    printf("Cat(");
    #####: 2304:    _yr_re_print_node(re_node->left);
call    0 never executed
        -: 2305:    printf(", ");
    #####: 2306:    _yr_re_print_node(re_node->right);
call    0 never executed
        -: 2307:    printf(")");
        -: 2308:    break;
        -: 2309:
        -: 2310:  case RE_NODE_STAR:
        -: 2311:    printf("Star(");
    #####: 2312:    _yr_re_print_node(re_node->left);
call    0 never executed
        -: 2313:    printf(")");
        -: 2314:    break;
        -: 2315:
        -: 2316:  case RE_NODE_PLUS:
        -: 2317:    printf("Plus(");
    #####: 2318:    _yr_re_print_node(re_node->left);
call    0 never executed
        -: 2319:    printf(")");
        -: 2320:    break;
        -: 2321:
    #####: 2322:  case RE_NODE_LITERAL:
    #####: 2323:    printf("Lit(%02X)", re_node->value);
        -: 2324:    break;
        -: 2325:
    #####: 2326:  case RE_NODE_MASKED_LITERAL:
    #####: 2327:    printf("MaskedLit(%02X,%02X)", re_node->value, re_node->mask);
        -: 2328:    break;
        -: 2329:
        -: 2330:  case RE_NODE_WORD_CHAR:
        -: 2331:    printf("WordChar");
        -: 2332:    break;
        -: 2333:
        -: 2334:  case RE_NODE_NON_WORD_CHAR:
        -: 2335:    printf("NonWordChar");
        -: 2336:    break;
        -: 2337:
        -: 2338:  case RE_NODE_SPACE:
        -: 2339:    printf("Space");
        -: 2340:    break;
        -: 2341:
        -: 2342:  case RE_NODE_NON_SPACE:
        -: 2343:    printf("NonSpace");
        -: 2344:    break;
        -: 2345:
        -: 2346:  case RE_NODE_DIGIT:
        -: 2347:    printf("Digit");
        -: 2348:    break;
        -: 2349:
        -: 2350:  case RE_NODE_NON_DIGIT:
        -: 2351:    printf("NonDigit");
        -: 2352:    break;
        -: 2353:
        -: 2354:  case RE_NODE_ANY:
        -: 2355:    printf("Any");
        -: 2356:    break;
        -: 2357:
    #####: 2358:  case RE_NODE_RANGE:
    #####: 2359:    printf("Range(%d-%d, ", re_node->start, re_node->end);
    #####: 2360:    _yr_re_print_node(re_node->left);
call    0 never executed
        -: 2361:    printf(")");
        -: 2362:    break;
        -: 2363:
        -: 2364:  case RE_NODE_CLASS:
        -: 2365:    printf("Class(");
    #####: 2366:    for (i = 0; i < 256; i++)
branch  0 never executed
branch  1 never executed
    #####: 2367:      if (_yr_re_is_char_in_class(re_node->re_class, i, false))
branch  0 never executed
branch  1 never executed
        -: 2368:        printf("%02X,", i);
        -: 2369:    printf(")");
        -: 2370:    break;
        -: 2371:
        -: 2372:  default:
        -: 2373:    printf("???");
        -: 2374:    break;
        -: 2375:  }
        -: 2376:}
        -: 2377:
function yr_re_print called 0 returned 0% blocks executed 0%
    #####: 2378:void yr_re_print(
        -: 2379:    RE_AST* re_ast)
        -: 2380:{
    #####: 2381:  _yr_re_print_node(re_ast->root_node);
call    0 never executed
    #####: 2382:}
