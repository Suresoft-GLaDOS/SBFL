        -:    0:Source:re_lexer.l
        -:    0:Graph:/home/workspace/libyara/re_lexer.gcno
        -:    0:Data:/home/workspace/libyara/re_lexer.gcda
        -:    0:Runs:6
        -:    0:Programs:6
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/* Lexical analyzer for regular expressions */
        -:   31:
        -:   32:%{
        -:   33:
        -:   34:/* Disable warnings for unused functions in this file.
        -:   35:
        -:   36:As we redefine YY_FATAL_ERROR macro to use our own function re_yyfatal, the
        -:   37:yy_fatal_error function generated by Flex is not actually used, causing a
        -:   38:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -:   39:function. When they include something like %option noyy_fatal_error as they do
        -:   40:with noyywrap then we can remove this pragma.
        -:   41:*/
        -:   42:
        -:   43:#ifdef __GNUC__
        -:   44:#pragma GCC diagnostic ignored "-Wunused-function"
        -:   45:#endif
        -:   46:
        -:   47:#include <assert.h>
        -:   48:#include <setjmp.h>
        -:   49:#include <stdbool.h>
        -:   50:
        -:   51:#include <yara/globals.h>
        -:   52:#include <yara/utils.h>
        -:   53:#include <yara/error.h>
        -:   54:#include <yara/limits.h>
        -:   55:#include <yara/mem.h>
        -:   56:#include <yara/re.h>
        -:   57:#include <yara/re_lexer.h>
        -:   58:#include <yara/threading.h>
        -:   59:#include <yara/strutils.h>
        -:   60:
        -:   61:
        -:   62:#ifdef _WIN32
        -:   63:#define snprintf _snprintf
        -:   64:#endif
        -:   65:
        -:   66:static uint8_t word_chars[] = {
        -:   67:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        -:   68:    0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07,
        -:   69:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        -:   70:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        -:   71:
        -:   72:
        -:   73:int escaped_char_value(
        -:   74:    char* text,
        -:   75:    uint8_t* value);
        -:   76:
        -:   77:int read_escaped_char(
        -:   78:    yyscan_t yyscanner,
        -:   79:    uint8_t* escaped_char);
        -:   80:
        -:   81:%}
        -:   82:
        -:   83:%option reentrant bison-bridge
        -:   84:%option noyywrap
        -:   85:%option nounistd
        -:   86:%option nounput
        -:   87:%option never-interactive
        -:   88:%option yylineno
        -:   89:%option prefix="re_yy"
        -:   90:
        -:   91:%option outfile="lex.yy.c"
        -:   92:
        -:   93:%option verbose
        -:   94:%option warn
        -:   95:
        -:   96:%x char_class
        -:   97:
        -:   98:digit         [0-9]
        -:   99:hex_digit     [0-9a-fA-F]
        -:  100:
        -:  101:%%
        -:  102:
        -:  103:\{{digit}*,{digit}*\} {
        -:  104:
        -:  105:  // Examples: {3,8} {0,5} {,5} {7,}
        -:  106:
        -:  107:  int hi_bound;
    #####:  108:  int lo_bound = atoi(yytext + 1);
        -:  109:
    #####:  110:  char* comma = strchr(yytext, ',');
        -:  111:
    #####:  112:  if (comma - yytext == strlen(yytext) - 2)
branch  0 never executed
branch  1 never executed
        -:  113:    // if comma is followed by the closing curly bracket
        -:  114:    // (example: {2,}) set high bound value to maximum.
        -:  115:    hi_bound = INT16_MAX;
        -:  116:  else
    #####:  117:    hi_bound = atoi(comma + 1);
        -:  118:
    #####:  119:  if (hi_bound > INT16_MAX)
branch  0 never executed
branch  1 never executed
        -:  120:  {
        -:  121:    yyerror(yyscanner, lex_env, "repeat interval too large");
        -:  122:    yyterminate();
        -:  123:  }
        -:  124:
    #####:  125:  if (hi_bound < lo_bound || hi_bound < 0 || lo_bound < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  126:  {
        -:  127:    yyerror(yyscanner, lex_env, "bad repeat interval");
        -:  128:    yyterminate();
        -:  129:  }
        -:  130:
    #####:  131:  if (hi_bound == 0 && lo_bound == 0)
branch  0 never executed
branch  1 never executed
        -:  132:  {
        -:  133:    yyerror(yyscanner, lex_env, "bad repeat interval");
        -:  134:    yyterminate();
        -:  135:  }
        -:  136:
    #####:  137:  yylval->range = (hi_bound << 16) | lo_bound;
        -:  138:
    #####:  139:  return _RANGE_;
        -:  140:}
        -:  141:
    #####:  142:
        -:  143:\{{digit}+\} {
        -:  144:
        -:  145:  // Example: {10}
        -:  146:
    #####:  147:  int value = atoi(yytext + 1);
        -:  148:
        -:  149:  // atoi can return a negative value if the input string represents a number
        -:  150:  // too large to fit in an integer.
        -:  151:
    #####:  152:  if (value > INT16_MAX || value < 0)
branch  0 never executed
branch  1 never executed
        -:  153:  {
        -:  154:    yyerror(yyscanner, lex_env, "repeat interval too large");
        -:  155:    yyterminate();
        -:  156:  }
        -:  157:
    #####:  158:  if (value == 0)
branch  0 never executed
branch  1 never executed
        -:  159:  {
        -:  160:    yyerror(yyscanner, lex_env, "bad repeat interval");
        -:  161:    yyterminate();
        -:  162:  }
        -:  163:
    #####:  164:  yylval->range = (value << 16) | value;
        -:  165:
    #####:  166:  return _RANGE_;
        -:  167:}
        -:  168:
    #####:  169:
        -:  170:\[\^ {
        -:  171:
        -:  172:  // Start of a negated character class. Example: [^abcd]
        -:  173:
    #####:  174:  BEGIN(char_class);
    #####:  175:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  176:  LEX_ENV->re_class.negated = true;
        -:  177:}
    #####:  178:
    #####:  179:\[\^\] {
        -:  180:
        -:  181:  // Start of character negated class containing a ].
        -:  182:  // Example: [^]abc] this must be interpreted as a class
        -:  183:  // not matching ], a, b, nor c
        -:  184:
    #####:  185:  BEGIN(char_class);
    #####:  186:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  187:  LEX_ENV->re_class.negated = true;
    #####:  188:  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;
        -:  189:}
    #####:  190:
    #####:  191:
        -:  192:\[\] {
        -:  193:
        -:  194:  // Start of character class containing a ].
        -:  195:  // Example: []abc] this must be interpreted as a class
        -:  196:  // matching ], a, b, or c.
        -:  197:
    #####:  198:  BEGIN(char_class);
    #####:  199:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  200:  LEX_ENV->re_class.negated = false;
    #####:  201:  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;
        -:  202:}
    #####:  203:
    #####:  204:
        -:  205:\[ {
        -:  206:
        -:  207:  // Start of character class. Example: [abcd]
        -:  208:
    #####:  209:  BEGIN(char_class);
    #####:  210:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  211:  LEX_ENV->re_class.negated = false;
        -:  212:}
    #####:  213:
    #####:  214:
        -:  215:[^\\\[\(\)\|\$\.\^\+\*\?] {
        -:  216:
        -:  217:  // Any non-special character is passed as a CHAR token to the scanner.
        -:  218:
    #####:  219:  yylval->integer = yytext[0];
    #####:  220:  return _CHAR_;
        -:  221:}
        -:  222:
        -:  223:
        -:  224:\\w {
        -:  225:  return _WORD_CHAR_;
        -:  226:}
        -:  227:
    #####:  228:
        -:  229:\\W {
    #####:  230:  return _NON_WORD_CHAR_;
        -:  231:}
        -:  232:
    #####:  233:
        -:  234:\\s {
    #####:  235:  return _SPACE_;
        -:  236:}
        -:  237:
    #####:  238:
        -:  239:\\S {
    #####:  240:  return _NON_SPACE_;
        -:  241:}
        -:  242:
    #####:  243:
        -:  244:\\d {
    #####:  245:  return _DIGIT_;
        -:  246:}
        -:  247:
    #####:  248:
        -:  249:\\D {
    #####:  250:  return _NON_DIGIT_;
        -:  251:}
        -:  252:
    #####:  253:
        -:  254:\\b {
    #####:  255:  return _WORD_BOUNDARY_;
        -:  256:}
        -:  257:
    #####:  258:\\B {
    #####:  259:  return _NON_WORD_BOUNDARY_;
        -:  260:}
        -:  261:
        -:  262:
        -:  263:\\{digit}+ {
        -:  264:
        -:  265:  yyerror(yyscanner, lex_env, "backreferences are not allowed");
        -:  266:  yyterminate();
        -:  267:}
        -:  268:
    #####:  269:
        -:  270:\\ {
        -:  271:
        -:  272:  uint8_t c;
        -:  273:
    #####:  274:  if (read_escaped_char(yyscanner, &c))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  275:  {
    #####:  276:    yylval->integer = c;
    #####:  277:    return _CHAR_;
        -:  278:  }
        -:  279:  else
        -:  280:  {
        -:  281:    yyerror(yyscanner, lex_env, "illegal escape sequence");
        -:  282:    yyterminate();
        -:  283:  }
        -:  284:}
        -:  285:
    #####:  286:
        -:  287:<char_class>\] {
        -:  288:
        -:  289:  // End of character class.
    #####:  290:  yylval->re_class = (RE_CLASS*) yr_malloc(sizeof(RE_CLASS));
call    0 never executed
    #####:  291:  memcpy(yylval->re_class->bitmap, LEX_ENV->re_class.bitmap, 32);
        -:  292:
    #####:  293:  yylval->re_class->negated = LEX_ENV->re_class.negated;
        -:  294:
    #####:  295:  BEGIN(INITIAL);
    #####:  296:  return _CLASS_;
        -:  297:}
        -:  298:
    #####:  299:
        -:  300:
        -:  301:<char_class>(\\x{hex_digit}{2}|\\.|[^\\])\-[^]] {
        -:  302:
        -:  303:  // A range inside a character class.
        -:  304:  //  [abc0-9]
        -:  305:  //      ^- matching here
        -:  306:
        -:  307:  uint16_t c;
    #####:  308:  uint8_t start = yytext[0];
    #####:  309:  uint8_t end = yytext[2];
        -:  310:
    #####:  311:  if (start == '\\')
branch  0 never executed
branch  1 never executed
        -:  312:  {
    #####:  313:    if (!escaped_char_value(yytext, &start))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  314:    {
        -:  315:      yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  316:      yyterminate();
        -:  317:    }
        -:  318:
    #####:  319:    if (yytext[1] == 'x')
branch  0 never executed
branch  1 never executed
    #####:  320:      end = yytext[5];
        -:  321:    else
    #####:  322:      end = yytext[3];
        -:  323:  }
        -:  324:
    #####:  325:  if (end == '\\')
branch  0 never executed
branch  1 never executed
        -:  326:  {
    #####:  327:    if (!read_escaped_char(yyscanner, &end))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  328:    {
        -:  329:      yyerror(yyscanner, lex_env, "illegal escape sequence");
        -:  330:      yyterminate();
        -:  331:    }
        -:  332:  }
        -:  333:
    #####:  334:  if (end < start)
branch  0 never executed
branch  1 never executed
        -:  335:  {
        -:  336:    yyerror(yyscanner, lex_env, "bad character range");
        -:  337:    yyterminate();
        -:  338:  }
        -:  339:
    #####:  340:  for (c = start; c <= end; c++)
branch  0 never executed
branch  1 never executed
        -:  341:  {
    #####:  342:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  343:  }
        -:  344:}
    #####:  345:
        -:  346:
        -:  347:<char_class>\\w {
        -:  348:
        -:  349:  int i;
        -:  350:
    #####:  351:  for (i = 0; i < 32; i++)
branch  0 never executed
branch  1 never executed
    #####:  352:    LEX_ENV->re_class.bitmap[i] |= word_chars[i];
        -:  353:}
        -:  354:
        -:  355:
        -:  356:<char_class>\\W {
        -:  357:
        -:  358:  int i;
        -:  359:
    #####:  360:  for (i = 0; i < 32; i++)
branch  0 never executed
branch  1 never executed
    #####:  361:    LEX_ENV->re_class.bitmap[i] |= ~word_chars[i];
        -:  362:}
        -:  363:
    #####:  364:
        -:  365:<char_class>\\s {
        -:  366:
    #####:  367:  LEX_ENV->re_class.bitmap[' ' / 8] |= 1 << ' ' % 8;
    #####:  368:  LEX_ENV->re_class.bitmap['\t' / 8] |= 1 << '\t' % 8;
        -:  369:}
    #####:  370:
        -:  371:
        -:  372:<char_class>\\S {
        -:  373:
        -:  374:  int i;
        -:  375:
    #####:  376:  for (i = 0; i < 32; i++)
branch  0 never executed
branch  1 never executed
        -:  377:  {
    #####:  378:    if (i == ' ' / 8)
branch  0 never executed
branch  1 never executed
    #####:  379:      LEX_ENV->re_class.bitmap[i] |= ~(1 << ' ' % 8);
    #####:  380:    else if (i == '\t' / 8)
branch  0 never executed
branch  1 never executed
    #####:  381:      LEX_ENV->re_class.bitmap[i] |= ~(1 << '\t' % 8);
        -:  382:    else
    #####:  383:      LEX_ENV->re_class.bitmap[i] = 0xFF;
        -:  384:  }
        -:  385:}
        -:  386:
        -:  387:
        -:  388:<char_class>\\d {
        -:  389:
        -:  390:  char c;
        -:  391:
    #####:  392:  for (c = '0'; c <= '9'; c++)
branch  0 never executed
branch  1 never executed
    #####:  393:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  394:}
        -:  395:
        -:  396:
        -:  397:<char_class>\\D {
        -:  398:
        -:  399:  int i;
        -:  400:
    #####:  401:  for (i = 0; i < 32; i++)
branch  0 never executed
branch  1 never executed
        -:  402:  {
        -:  403:    // digits 0-7 are in the sixth byte of the vector, let that byte alone
    #####:  404:    if (i == 6)
branch  0 never executed
branch  1 never executed
    #####:  405:      continue;
        -:  406:
        -:  407:    // digits 8 and 9 are the lowest two bits in the seventh byte of the
        -:  408:    // vector, let those bits alone.
    #####:  409:    if (i == 7)
branch  0 never executed
branch  1 never executed
    #####:  410:      LEX_ENV->re_class.bitmap[i] |= 0xFC;
        -:  411:    else
    #####:  412:      LEX_ENV->re_class.bitmap[i] = 0xFF;
        -:  413:  }
        -:  414:}
        -:  415:
    #####:  416:
        -:  417:<char_class>\\ {
        -:  418:
        -:  419:  uint8_t c;
        -:  420:
    #####:  421:  if (read_escaped_char(yyscanner, &c))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  422:  {
    #####:  423:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  424:  }
        -:  425:  else
        -:  426:  {
        -:  427:    yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  428:    yyterminate();
        -:  429:  }
        -:  430:}
        -:  431:
    #####:  432:
        -:  433:<char_class>. {
        -:  434:
    #####:  435:  if (yytext[0] >= 32 && yytext[0] < 127)
branch  0 never executed
branch  1 never executed
        -:  436:  {
        -:  437:    // A character class (i.e: [0-9a-f]) is represented by a 256-bits vector,
        -:  438:    // here we set to 1 the vector's bit corresponding to the input character.
        -:  439:
    #####:  440:    LEX_ENV->re_class.bitmap[yytext[0] / 8] |= 1 << yytext[0] % 8;
        -:  441:  }
        -:  442:  else
        -:  443:  {
        -:  444:    yyerror(yyscanner, lex_env, "non-ascii character");
        -:  445:    yyterminate();
        -:  446:  }
        -:  447:}
    #####:  448:
        -:  449:
        -:  450:<char_class><<EOF>> {
        -:  451:
        -:  452:  // End of regexp reached while scanning a character class.
        -:  453:
        -:  454:  yyerror(yyscanner, lex_env, "missing terminating ] for character class");
        -:  455:  yyterminate();
        -:  456:}
        -:  457:
    #####:  458:
        -:  459:. {
        -:  460:
    #####:  461:  if (yytext[0] >= 32 && yytext[0] < 127)
branch  0 never executed
branch  1 never executed
        -:  462:  {
    #####:  463:    return yytext[0];
        -:  464:  }
        -:  465:  else
        -:  466:  {
        -:  467:    yyerror(yyscanner, lex_env, "non-ascii character");
        -:  468:    yyterminate();
        -:  469:  }
        -:  470:}
        -:  471:
    #####:  472:
        -:  473:<<EOF>> {
        -:  474:
    #####:  475:  yyterminate();
        -:  476:}
        -:  477:
    #####:  478:%%
call    0 never executed
    #####:  479:
function escaped_char_value called 0 returned 0% blocks executed 0%
    #####:  480:int escaped_char_value(
        -:  481:    char* text,
        -:  482:    uint8_t* value)
        -:  483:{
        -:  484:  unsigned int hex_value;
        -:  485:  char hex[3];
        -:  486:
    #####:  487:  assert(text[0] == '\\');
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  488:
    #####:  489:  switch(text[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  490:  {
    #####:  491:  case 'x':
    #####:  492:    if (!isxdigit(text[2]) || !isxdigit(text[3]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:      return 0;
    #####:  494:    hex[0] = text[2];
    #####:  495:    hex[1] = text[3];
    #####:  496:    hex[2] = '\0';
    #####:  497:    sscanf(hex, "%x", &hex_value);
    #####:  498:    *value = (uint8_t) hex_value;
    #####:  499:    break;
        -:  500:
    #####:  501:  case 'n':
    #####:  502:    *value = '\n';
    #####:  503:    break;
        -:  504:
    #####:  505:  case 't':
    #####:  506:    *value = '\t';
    #####:  507:    break;
        -:  508:
    #####:  509:  case 'r':
    #####:  510:    *value = '\r';
    #####:  511:    break;
        -:  512:
    #####:  513:  case 'f':
    #####:  514:    *value = '\f';
    #####:  515:    break;
        -:  516:
    #####:  517:  case 'a':
    #####:  518:    *value = '\a';
    #####:  519:    break;
        -:  520:
    #####:  521:  default:
    #####:  522:    *value = text[1];
        -:  523:  }
        -:  524:
        -:  525:  return 1;
        -:  526:}
        -:  527:
        -:  528:
        -:  529:#ifdef __cplusplus
        -:  530:#define RE_YY_INPUT yyinput
        -:  531:#else
        -:  532:#define RE_YY_INPUT input
        -:  533:#endif
        -:  534:
        -:  535:
function read_escaped_char called 0 returned 0% blocks executed 0%
    #####:  536:int read_escaped_char(
        -:  537:    yyscan_t yyscanner,
        -:  538:    uint8_t* escaped_char)
        -:  539:{
    #####:  540:  char text[4] = {0, 0, 0, 0};
        -:  541:
    #####:  542:  text[0] = '\\';
    #####:  543:  text[1] = RE_YY_INPUT(yyscanner);
call    0 never executed
        -:  544:
    #####:  545:  if (text[1] == EOF || text[1] == 0)
branch  0 never executed
branch  1 never executed
        -:  546:    return 0;
        -:  547:
    #####:  548:  if (text[1] == 'x')
branch  0 never executed
branch  1 never executed
        -:  549:  {
    #####:  550:    text[2] = RE_YY_INPUT(yyscanner);
call    0 never executed
        -:  551:
    #####:  552:    if (text[2] == EOF || text[2] == 0)
branch  0 never executed
branch  1 never executed
        -:  553:      return 0;
        -:  554:
    #####:  555:    text[3] = RE_YY_INPUT(yyscanner);
call    0 never executed
        -:  556:
    #####:  557:    if (text[3] == EOF || text[3] == 0)
branch  0 never executed
branch  1 never executed
        -:  558:      return 0;
        -:  559:  }
        -:  560:
    #####:  561:  return escaped_char_value(text, escaped_char);
call    0 never executed
        -:  562:}
        -:  563:
        -:  564:
function re_yyfatal called 0 returned 0% blocks executed 0%
    #####:  565:void yyfatal(
        -:  566:    yyscan_t yyscanner,
        -:  567:    const char *error_message)
        -:  568:{
    #####:  569:  jmp_buf* recovery_state = (jmp_buf*) yr_thread_storage_get_value(
call    0 never executed
        -:  570:      &yr_recovery_state_key);
        -:  571:
    #####:  572:  longjmp(*recovery_state, 1);
        -:  573:}
        -:  574:
        -:  575:
function re_yyerror called 0 returned 0% blocks executed 0%
    #####:  576:void yyerror(
        -:  577:    yyscan_t yyscanner,
        -:  578:    RE_LEX_ENVIRONMENT* lex_env,
        -:  579:    const char *error_message)
        -:  580:{
        -:  581:  // if lex_env->last_error was set to some error code before
        -:  582:  // don't overwrite it, we are interested in the first error, not in
        -:  583:  // subsequent errors like "syntax error, unexpected $end" caused by
        -:  584:  // early parser termination.
        -:  585:
    #####:  586:  if (lex_env->last_error == ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
        -:  587:  {
    #####:  588:    lex_env->last_error = ERROR_INVALID_REGULAR_EXPRESSION;
        -:  589:
    #####:  590:    strlcpy(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
    #####:  591:        lex_env->last_error_message,
        -:  592:        error_message,
        -:  593:        sizeof(lex_env->last_error_message));
        -:  594:  }
    #####:  595:}
        -:  596:
        -:  597:
function yr_parse_re_string called 0 returned 0% blocks executed 0%
    #####:  598:int yr_parse_re_string(
        -:  599:  const char* re_string,
        -:  600:  RE_AST** re_ast,
        -:  601:  RE_ERROR* error)
        -:  602:{
        -:  603:  yyscan_t yyscanner;
        -:  604:  jmp_buf recovery_state;
        -:  605:  RE_LEX_ENVIRONMENT lex_env;
        -:  606:
    #####:  607:  lex_env.last_error = ERROR_SUCCESS;
    #####:  608:  lex_env.last_error_message[0] = '\0';
        -:  609:
    #####:  610:  yr_thread_storage_set_value(&yr_recovery_state_key, &recovery_state);
call    0 never executed
        -:  611:
    #####:  612:  if (setjmp(recovery_state) != 0)
branch  0 never executed
branch  1 never executed
        -:  613:    return ERROR_INTERNAL_FATAL_ERROR;
        -:  614:
    #####:  615:  FAIL_ON_ERROR(yr_re_ast_create(re_ast));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  616:
    #####:  617:  yylex_init(&yyscanner);
call    0 never executed
    #####:  618:  yyset_extra(*re_ast, yyscanner);
    #####:  619:  yy_scan_string(re_string, yyscanner);
call    0 never executed
    #####:  620:  yyparse(yyscanner, &lex_env);
call    0 never executed
    #####:  621:  yylex_destroy(yyscanner);
call    0 never executed
        -:  622:
    #####:  623:  if (lex_env.last_error != ERROR_SUCCESS)
branch  0 never executed
branch  1 never executed
        -:  624:  {
    #####:  625:    yr_re_ast_destroy(*re_ast);
call    0 never executed
    #####:  626:    *re_ast = NULL;
        -:  627:
    #####:  628:    strlcpy(
call    0 never executed
    #####:  629:        error->message,
        -:  630:        lex_env.last_error_message,
        -:  631:        sizeof(error->message));
        -:  632:
    #####:  633:    return lex_env.last_error;
        -:  634:  }
        -:  635:
        -:  636:  return ERROR_SUCCESS;
        -:  637:}
